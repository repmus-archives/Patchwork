;;; theses utils need PW to be already constructed.(in-package :pw)(defun sources-to-recompile (root)  "Gets the list of outdated fasl"  (let* (res         (all-sources (directory root)))    (mapc #'(lambda (lisp-file)              (let ((fasl-file (compile-file-pathname lisp-file)))                (when (or (not (probe-file fasl-file))                          (> (file-write-date lisp-file) (file-write-date fasl-file)))                  (push lisp-file res))))          all-sources)    res))(defun out-of-date (root prefix)  (mapcar #'(lambda (path) (unexpand-pathname prefix path))          ( sources-to-recompile root )))(defun recompile-changed-files (root prefix)  (mapc #'(lambda (file) (compile-file file :verbose t))        (out-of-date root prefix)))(defun delete-files (dir)  (mapc #'(lambda (file)            (print file)            (unlock-file file)            (if (probe-file file)              (delete-file file :if-does-not-exist nil)              (error "file ~S" file)))  (directory dir)))(defun delete-sources (root)  (let ((all-sources (directory root)))    (mapc #'(lambda (source-file)              (let ((compiled-file (compile-file-pathname source-file)))                (unless (or (not (probe-file compiled-file))                            (> (file-write-date source-file) (file-write-date compiled-file)))                  (delete-file source-file  :if-does-not-exist nil)                  (print source-file)                  )))          all-sources)    t))(defun unexpand-pathname (host pathname)  (let* ((pd (pathname-directory pathname))         (pn (pathname-name pathname))         (pt (pathname-type pathname))         (ph (pathname-directory (truename host)))         (dirs (loop for dir in (loop for dir1 on  pd                                      for dir2 in ph                                      finally return dir1)                     collect dir                     collect ";")))    (apply 'concatenate 'string           `(,host ,. dirs  ,pn "." ,pt))))(defun p-directory (generic-path host)  "lists files in generic-path, like directory does, but with logical filename, with respect to host"   (let ((file-list (directory generic-path)))    (mapcar #'(lambda (filepath) (unexpand-pathname host (namestring filepath)))            file-list))); lists a directory with logical filenames ; (p-directory "CL:PW-code;**;*.lisp" "CL:PW-code;"); tracks lisp files with no pfsl or an out-of-date pfsl file; (out-of-date  "PW:**;*.lisp" "PW:"); (out-of-date "CL:PW-inits;**;*.lisp" "CL:PW-inits;"); (out-of-date  "CL:**;*.lisp" "CL:"); (out-of-date "CL:user-library;**;*.lisp" "CL:user-library;"); recompile changed file in selected directories; (recompile-changed-files "CL:PW-inits;**;*.lisp" "CL:PW-inits;"); (recompile-changed-files "PW:**;*.lisp" "PW:"); (recompile-changed-files "CL:user-library;**;*.lisp" "CL:user-library;"); (delete-file "CL:pw-inits;Load+Update;make-pw-Music-image.pfsl"); (delete-file "CL:pw-inits;pw-init.pfsl"); delete sources in selected directories;(delete-sources "CL:PW-inits;**;*.lisp");(delete-sources "PW:**;*.lisp");(delete-sources "CL:user-library;**;*.lisp"); compile every file in sources folder; (mapc #'(lambda (file) (compile-file file :verbose t)) (p-directory "CL:PW-code;**;*.lisp" "CL:PW-code;")); compile every file in inits folder; (mapc #'(lambda (file) (compile-file file :verbose t)) (p-directory "CL:PW-inits;**;*.lisp" "CL:pw-inits;")); compile every file in user-lib folder; (mapc #'(lambda (file) (compile-file file :verbose t)) (p-directory "PW-LIB:**;*.lisp" "PW-LIB:"))