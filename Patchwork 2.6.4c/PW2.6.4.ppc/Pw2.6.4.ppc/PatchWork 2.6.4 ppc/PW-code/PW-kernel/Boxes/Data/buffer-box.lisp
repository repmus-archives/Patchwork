;;;;=========================================================;;;;;;;;  PATCH-WORK;;;;  By Mikael Laurson, Jacques Duthen, Camilo Rueda.;;;;  © 1986-1992 IRCAM ;;;;;;;;=========================================================;;;; A general buffer box;;(defpackage "C-PATCH-BUFFER"  (:use "COMMON-LISP" "CCL")  (:import-from "PATCH-WORK" "C-PATCH" "DECOMPILE" "PATCH-VALUE" "INPUT-OBJECTS"                "PW-CONTROLS" "H" "W" "OUT-PUT" "X" "Y" "TYPE-LIST" "ACTIVE-MODE"                "PW-FUNCTION" "MAKE-PW-STANDARD-BOX" "DEFUNP" "PW-FUNCTION-STRING"                "SBOX" "C-PW-FUNCTIONAL" "C-RADIO-BUTTON")  (:export "C-PATCH-BUFFER" "THE-BUFFER" "BUFFER" "C-RADIO-BUTTON" "GET-LOCK-BUTTON-FUN"           "VALUE"))(in-package "C-PATCH-BUFFER")#|(defclass C-radio-button (static-text-dialog-item) ())(defmethod type-list ((self C-radio-button)) )(defmethod decompile ((self C-radio-button)) )|#(defclass C-patch-buffer (C-patch)  ((the-buffer :initform nil :initarg :the-buffer :accessor the-buffer)   (lock :initform nil :accessor lock)   (value :initform nil :accessor value)))(defmethod decompile ((self C-patch-buffer))  `(sbox ',(type-of self) ',(pw-function self) ,(pw-function-string self)         ,(active-mode self) ,(view-position self) '(0)         ,(make-point (w self) (- (h self) 7))))(defmethod initialize-instance :after ((self C-patch-buffer) &key ctrls)  (declare (ignore ctrls))  (set-view-size self (w self) (+ (h self) 7))  (set-view-position (out-put self)                      (make-point (x (out-put self)) (+ (y (out-put self)) 7)))  (setf (lock self)        (make-instance 'C-radio-button                       :view-position (make-point (- (truncate (w self) 2) 5)                                                  (- (h self) 22))                       :view-size (make-point 8 8)                       :dialog-item-text (get-initial-button-text self)                       :view-font '("Monaco" 8)                       :view-container self                       :dialog-item-action (get-lock-button-fun self))))(defmethod get-lock-button-fun ((self C-patch-buffer))  #'(lambda (item)    (if (value (view-container item))      (set-dialog-item-text item "o")      (set-dialog-item-text item "x"))    (setf (value (view-container item))          (not (value (view-container item))))))(defmethod get-initial-button-text ((self C-patch-buffer)) "o")(defmethod patch-value ((self C-patch-buffer) obj)  (let ((in (car (input-objects self))))    (if (value self)      (the-buffer self)      (setf (the-buffer self) (patch-value in obj)))))(defunp Buffer ((buff nilNum)) nil        "The buffer module stores the results of patch calculations connected to its input. It has two states: open (indicated by a small o on the module) and closed (indicated by x). The user can switch between these two states by clicking on the o or the x. When the module is open, it behaves exactly like the module const. When it is closed it returns the last value evaluated. It is advisable to close the module immediately after evaluation to avoid recalculating the input."  (declare (ignore buff)))#|(in-package :pw)(add-patch-box *active-patch-window*                (make-patch-box  'C-patch-buffer:C-patch-buffer 'Buff                                 '(*nil-numbox-pw-type* "value") '()))(unintern 'pw-function)|#(defpackage "C-PATCH-ACCUM"  (:use "COMMON-LISP" "C-PATCH-BUFFER")  (:import-from "PATCH-WORK" "C-PATCH"  "PATCH-VALUE" "INPUT-OBJECTS" "PW-CONTROLS"                "DEFUNP")  (:import-from "CCL" "SET-DIALOG-ITEM-TEXT" "VIEW-CONTAINER")  (:export "C-PATCH-ACCUM" "THE-BUFFER" "ACCUM" "*ACCUM-BUFFER-LIMIT*"))(in-package "C-PATCH-ACCUM")(defvar *accum-buffer-limit* 400);changed by aaa 29-08-95 from pw-modifs(defclass C-patch-accum (C-patch-buffer pw::C-pw-functional )  ((my-buffer-limit :initform 400 :accessor my-buffer-limit)   (the-buffer :initform (make-list 400 :initial-element 0)               :accessor the-buffer)   (end-ptr :initform 0 :accessor end-ptr)   (end-limit :initform 0 :accessor end-limit)   (accum-buffer-limit :initform 400 :accessor accum-buffer-limit)))#|(defclass C-patch-accum (C-patch-buffer)  ((my-buffer-limit :initform 400 :accessor my-buffer-limit)   (the-buffer :initform (make-list 400 :initial-element 0)               :accessor the-buffer)   (end-ptr :initform 0 :accessor end-ptr)   (end-limit :initform 0 :accessor end-limit)   (accum-buffer-limit :initform 400 :accessor accum-buffer-limit)))|#(defmethod get-lock-button-fun ((self C-patch-accum))  (eval `(function (lambda (item)                     (if (value (view-container item))                       (progn (set-dialog-item-text item "o") (init-buffer ,self))                       (set-dialog-item-text item "x"))                     (setf (value (view-container item))                           (not (value (view-container item))))))))(defmethod init-buffer ((self C-patch-accum))  (setf (end-ptr self) 0)  (setf (end-limit self) 0))(defmethod patch-value ((self C-patch-accum) obj)  (let ((new-size (and (second (pw-controls self))                       (patch-value (second (input-objects self)) obj) ))        (limit (my-buffer-limit self)))    (when new-size      (if (> new-size limit)        (setf (cdr (last (the-buffer self))) (make-list (- new-size limit))              (my-buffer-limit self) new-size))      (setf (accum-buffer-limit self) new-size))    (if (value self)      (subseq (the-buffer self) 0 (end-limit self))      (progn        (unless (<= (incf (end-limit self)) (accum-buffer-limit self))          (decf (end-limit self)))        (setf (nth (end-ptr self) (the-buffer self))              (patch-value (first (input-objects self)) obj))        (or (< (incf (end-ptr self)) (accum-buffer-limit self)) (setf (end-ptr self) 0))        (subseq (the-buffer self) 0 (end-limit self))))))(defunp accum ((data Nilnum)               &optional (nb-elems fix>0 (:value 400))) nil " The accum module accumulates results of calculations of a patch that is connected to its input. It has two states: open (indicated by a small ‘o’ on the module) and closed (indicated by 'x'). The user can switch between these two states by clicking on the 'o' or the 'x' When the module is open, it accumulates in a list the result of each evaluation—of the patch connected to its input, or the value at its input. When it is closed it returns the last value evaluated. The module is reinitialized by a change of state from closed to open. This module takes a list of maximum length 400 elements. This value can be modified by the opening of the optional input to the accum module, by clicking on the 'E' found on the right. When the list reaches its maximum value the resulting list begins to wraparound in a circular fashion, writing over old values. "  (declare (ignore data nb-elems)))