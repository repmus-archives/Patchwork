(defpackage "INIT"  (:use "COMMON-LISP")  (:export "DEF-LOGICAL-PATH" "CONVERT-MAC-PATHNAMES" "DEF-ROOT-PATH" "BUILD-LOGICAL-HOSTS"));; =============================================================================-======;; For bootstrap reasons...(in-package "INIT")(defpackage "RESTORE-LISP" (:use "COMMON-LISP"))(in-package "INIT")(setf *load-verbose* t);; =============================================================================-======(defmacro def-logical-path (&rest l-host-dir)  "Defines portable common lisp logical pathnames."  (let ((body ()))    (loop      (when (endp l-host-dir) (return))      (push `(logical-pathname-translations ,(pop l-host-dir)) body)      (push `(list (list "**;" ,(pop l-host-dir))) body))    `(setf ,.(nreverse body))))(defun convert-mac-pathnames ()  "Converts the macintosh logical directories to portable common lisp."  (let ((subdir (make-pathname :directory '(:relative :wild-inferiors))))    (dolist (assoc CCL:*logical-directory-alist*)      (def-logical-path (car assoc) (merge-pathnames subdir (cdr assoc))))))(defun def-root-path ()  "Restores the root logical directory of the volume containing the image restored."  (let ((home-dir (pathname-directory (truename (user-homedir-pathname)))) root-dir)    (unless (and (eq (first home-dir) :ABSOLUTE)                 (consp (rest home-dir))                 (not (consp (second home-dir))))      (error "The home directory ~S is not absolute." home-dir))    ;(ccl:def-logical-directory "root" (format () "~A:" (second home-dir)))    (setq root-dir          (make-pathname           :directory (list (first home-dir) (second home-dir) :wild-inferiors)))    (def-logical-path "root" root-dir)))(defvar *original-mcl-pathname* (truename "ccl:"))(defun build-logical-hosts ()  (def-root-path)  (let* ((home-dir (butlast (pathname-directory (truename (user-homedir-pathname)))))         (home-dir (cons (first home-dir) (cddr home-dir)))         (ccl-dir (append (butlast home-dir) (last (pathname-directory  *original-mcl-pathname*))))         (cl-path (format () "root:~A**;"                          (substitute #\; #\: (namestring (make-pathname :directory home-dir)))))         (ccl-path1 (format () "root:~A*.*"                            (substitute #\; #\: (namestring (make-pathname :directory ccl-dir)))))         (ccl-path2 (format () "root:~A**;"                            (substitute #\; #\: (namestring (make-pathname :directory ccl-dir))))))    (setf (logical-pathname-translations "CL") (list (list "**;" cl-path)))     (setf (logical-pathname-translations "PW") '(("**;" "CL:PW-code;**;")))    (setf (logical-pathname-translations "RESTORE") '(("**;" "CL:PW-inits;RESTORE;**;")))    (setf (logical-pathname-translations "ccl")          (append (butlast (logical-pathname-translations "ccl") 2)                  (list (list "ccl:ccl;*.*" ccl-path1) (list "ccl:**;" ccl-path2))))));(convert-mac-pathnames)(def-root-path)