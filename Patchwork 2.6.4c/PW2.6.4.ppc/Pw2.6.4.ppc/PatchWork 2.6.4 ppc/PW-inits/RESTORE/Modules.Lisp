;; =============================================================================-======;; [jack] 901116               Modules.Lisp;; =============================================================================-======;; Modules -- CLPF V1.0 by Jacques Duthen © 1990 IRCAM(defpackage "MODULE" (:use "COMMON-LISP")  (:export   "LOADED-P" "LOAD-AGAIN" "LIBLOAD" "LOAD-ONCE" "LIBLOAD-ONCE"   "SEARCH-PATH" "NEW-SEARCH-PATH" "REMOVE-SEARCH-PATH"   ))(in-package "MODULE");; all that will become available from the package "LISP"(import '(is-loaded-p    load-again libload load-once libload-once   search-path new-search-path remove-search-path   new-restore-lisp-function) "COMMON-LISP")(export  '(is-loaded-p   load-again libload load-once libload-once   search-path new-search-path remove-search-path   new-restore-lisp-function) "COMMON-LISP");; =============================================================================-======;; defining/extending lisp modules facility;; [X3J13 voted to eliminate the module facility];; =============================================================================-======(defvar *loaded-modules* ()  "The list of modules which have been already loaded")(defvar *loading-modules* ()  "The list of modules which are being loaded");; The path is still "CCL:*module-search-path*";; and the work is still done by the function "CCL:require" !(defun search-path ()  "Returns the search path."  CCL:*module-search-path*)(defun remove-search-path (dir)  "Removes the directory or the list of directories from the module search path.This can be useful for changing the order of the path (for efficiency search)."  (setf CCL:*module-search-path*        (remove dir CCL:*module-search-path* :test #'equal)))(defun new-search-path (dir &key (top nil))  "Adds a new directory or a list of new directories to the module search path.If :top is T (not the default), the insertion is done at the beginning of the list."  (unless (listp dir) (setq dir (list dir)))  (setf CCL:*module-search-path*         (if top          (append dir CCL:*module-search-path*)          (append CCL:*module-search-path* dir)))  dir);; =============================================================================-======(defun is-loaded-p (module-name)  "Returns the non-null <module-name> when it has already been loaded."  (when (or (member module-name *loaded-modules* :test #'string-equal)            (member module-name CCL:*modules* :test #'string-equal))    module-name))(defun loading-p (filename)  "Returns the non-null <filename> when it is already being loaded."  (when (member filename *loading-modules* :test #'equal)    filename))(unless (fboundp 'original-load)  (setf (symbol-function 'original-load) (symbol-function 'common-lisp:load))  (setf (documentation 'original-load 'function) (documentation 'common-lisp:load 'function))  'original-load)(defun load-again (filename &rest args &key verbose print if-does-not-exist)  (declare (ignore if-does-not-exist print verbose))  (let ((module-name (pathname-name filename)))    (if (loading-p filename)      (error "Trying to load ~S while loading it." filename)      (let ((*loading-modules* (cons filename *loading-modules*))            (loaded? (is-loaded-p module-name)))        (values          (apply #'original-load filename args)          (progn            (push module-name *loaded-modules*)            (unless loaded? module-name)))))))(let ((ccl:*warn-if-redefine-kernel* nil))  (setf (symbol-function 'load) (symbol-function 'load-again)))(defun libload (module-name &aux pathname pathname-host pathname-dir)  (cond   ((not (stringp module-name))    (error "~S should be a string." module-name))   ((and (setq pathname-host (pathname-host (setq pathname (pathname module-name))))         (not (eq pathname-host :unspecific)))    (error "~S should not have the host ~S" module-name pathname-host))   ((and (setq pathname-dir (pathname-directory pathname))         (not (eq pathname-dir :unspecific)))    (error "~S should not have the directory ~S" module-name pathname-dir)))  (if (loading-p module-name)    (error "Trying to load ~S while loading it." module-name)    (values     (unless (is-loaded-p module-name) module-name)     (progn       (setf CCL:*modules* (delete module-name CCL:*modules* :test #'string-equal))       (prog1         (CCL:require module-name)         (push module-name *loaded-modules*))))))(defun load-once (filename &rest args &key verbose print if-does-not-exist)  (declare (ignore if-does-not-exist print verbose))  (unless (is-loaded-p (pathname-name filename))    (apply #'load-again filename args)))(defun libload-once (module-name)  (unless (is-loaded-p module-name)    (libload module-name)));; =============================================================================-======;; ---- utility for new-restore-lisp-function ----(defun adjoin-new-last (item list &key (test #'eql) (last t) (if-exists :error))  "Adds physically <item> at the end of <list> (or at its beginning if :last is nil).  If the same item (using the test \"eql\" by default) was already present in <list>,the behaviour of \"adjoin-new-last\" depends on the value of :if-exists,:error (the default) signals an error,:old (or :new) keeps only the old (or new) one,:both keeps both the old one and the new one."  (let ((existed? (member item list :test test)))    (when (and existed? (eq if-exists :new))      (setq list (delete item list :test test)))    (cond     ((or (not existed?) (eq if-exists :new) (eq if-exists :both))      (setq list            (if last              (nconc list (list item))              (cons item list))))     ((eq if-exists :old))     ((eq if-exists :error)      (error "~S was already stored in:~%~S." item list))     (t      (error "~S is an unvalid value for :if-exists" if-exists))))  list);; =============================================================================-======(load-once "RESTORE:Restore-Lisp");; =============================================================================-======