(in-package :pw)(setf *save-compiled-file* nil);(if (egc-mmu-support-available-p) (egc t));;;=====================================;;; Boxes that MIGHT be added to Kernel(defunp list-div ((list list) (divisor fix>0 (:value 2))) list"divise la liste en sous-listes de dimension <divisor>"  (let ((long (1- (length list))) res )    (for  (i 0 divisor long)      (let* ((inter (1- (+ i divisor )))             (inter (if (< inter long) inter long)))        (setq res (push (l-nth list (epw::arithm-ser i 1 inter)) res))))    (nreverse res)))(defunp insert ((item list (:value 'toto) ) (inter fix>0)                 (liste list) &optional (nb fix>0)  ) list"insère un élément <item> dans une liste, à intervalle régulier<inter> = intervalle de séparationext.: <nb> = nombre de ces éléments"  (let* ((separ (make-list   nb :initial-element item))         (liste (list-div liste inter))         res)    (dolist (m  liste) (push  (x-append m separ  ) res))    (flat (nreverse res))))(make-box-menu-recordables *bpf-popUp-menu*)(PW-addmenu  *pw-List-menu* '(interlock subs-posn group-list first-n last-n))(egc nil);;; bug corrections in pw 2.6.4(in-package :pw);A Common Lisp Bug(in-package :ccl)(let ((*warn-if-redefine* nil)      (*warn-if-redefine-kernel* nil))(defun arglist-from-compiled-def (lfun &optional (conser #'cons)                                        &aux (res nil) argnames)  (multiple-value-bind (nreq nopt restp nkeys allow-other-keys                        optinit lexprp                        ncells nclosed)          (function-args lfun)    (declare (ignore optinit ncells nclosed))    #+ppc-target    (when (typep lfun 'interpreted-function)      (setq argnames (evalenv-names (%nth-immediate lfun 0))))    (macrolet ((push (elt list)                     `(setf ,list (funcall conser ,elt ,list))))      (flet ((push-various-args (prefix count)               (dotimes (i (the fixnum count))                 (push (make-arg prefix i) res))))        (declare (dynamic-extent #'push-various-args))        (cond (lexprp               nil)              ((and (eq 0 (+ nreq nopt (or nkeys 0))) (not restp))               nil)              (t                (if argnames                 (setq res (reverse (butlast argnames (- (length argnames) nreq))))                 (push-various-args "ARG" nreq))               (when (> nopt 0)                 (push '&optional res)                 (if argnames                   (setq res (append (reverse (subseq argnames nreq (+ nreq nopt))) res))                   (push-various-args "OPT" nopt)))               (when restp                 (push '&rest res)                 (if argnames                   (push (nth (+ nreq nopt) argnames) res)                   (push 'the-rest res)))               (when nkeys                 (push '&key res)                 (let ((keyvect (lfun-keyvect lfun)))                   (dotimes (i (length keyvect))                     (push (elt keyvect i) res))))               (when allow-other-keys                 (push '&allow-other-keys res))               (nreverse res))))))))