;; ============================================================================================;;                                PAQUET   Systèmes dynamiques;; ============================================================================================;;          V1.2;;                                               functions by Mikhail Malt   1994 Paris IRCAM;========================================================================================(defvar ALEA)(defpackage "ALEA"   (:use "COMMON-LISP" "CCL")  (:import-from "PW" defunp))(in-package "ALEA");================les logistiques======================(ccl::export '(kaos kaos1 kaos2  lorentz   lorentz2  henon  ginger ginger2 rossler torus henon-heilles  IFSx choixaux midpoint1 midpoint2));=======================================================================;================ORBITALS===============================================;=======================================================================;=======================================================================; CETTE PREMIÈRE PARTIE SE CONSQTITUE D'UNE SÉRIE DE MODULES QUI GÉNERENT DES ;SOLUTIONS NUMERIQUES D'EQUATIONS DIFFERENTIELLES(pw::defunp kaos ((seed fix/float) (lambda numbers?) (long fix>0)) list"Génère une séquence de longueur <long> fondée sur l'équation logistique  yn = xn-1 * lambda * (1 - xn-1)  où <lambda> est une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un, et<long> est la longueur de la liste générée, où le nombre d'itérations.   "(let ((res (cons seed nil)) (xn seed))  (dotimes (n long res) (setf res (cons (setf xn (* (if (listp lambda) (nth n lambda) lambda) xn (- 1 xn))) res)))  (reverse res)))(pw::defunp alea::kaosn1 ((seed fix/float) (lambda fix/float) (gamma fix/float) (long fix>0) (fn? fix>0 (:value 1))) list"Génère une séquence de longueur <long> fondée sur une variation de l'équation logistique  yn = xn-1 * lambda - gamma *xn-1 ^2  où <lambda> et <gamma>sont des paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un  et<long> est la longueur de la liste générée, où le nombre d'itérations.   La sortie de ce module est une liste des valeurs de chaque itération  "(let ((res (cons seed nil)) (xn seed))  (dotimes (n long res)     (setf res           (cons           (dotimes (m fn? xn)           (setf res (cons (setf xn (- (* lambda xn) (* xn xn gamma))) res)) )           res)))  (reverse res)))(pw::defunp alea::kaosn ((seed fix/float) (lambda numbers?) (long fix>0) (fn? fix>0 (:value 1))) list"Génère une séquence de longueur <long> fondée sur l'équation logistique  yn = xn-1 * lambda * (1 - xn-1)  où <lambda> est un nombre ou une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un . <fn> est le degré d'itération de l'équation logistique ,si <fn>= n la séquence calculée sera celle de la fonction composée yn= y(yn-2), et<long> est la longueur de la liste générée, où le nombre d'itérations.La sortie de ce module est une liste des valeurs de chaque itération "(let ((res (cons seed nil)) (xn seed))  (dotimes (n long res)     (setf res           (cons           (dotimes (m fn? xn)           (setf xn (* (if (listp lambda) (nth n lambda) lambda) xn (- 1 xn))) )           res)))  (reverse res)))(pw::defunp alea::Verhulst ((seed fix/float) (lambda numbers?) (long fix>0)) list"Génère une séquence de longueur <long> fondée sur l'équation logistique de Pierre François Verhulst  yn = xn-1 + xn-1 * lambda * (1 - xn-1) pour décrire la croissance des populations. où <lambda> est un nombre ou une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un (soit la population initiale comme ratio d'une population maximale),  et<long> est la longueur de la liste générée, où le nombre d'itérations. La sortie de ce module est une liste des valeurs de chaque itération.   "(let ((res (cons seed nil)) (xn seed))  (dotimes (n long res)     (setf res (cons (setf xn (+ xn (* (if (listp lambda) (nth n lambda) lambda) xn (- 1 xn)))) res)))  (reverse res)))(pw::defunp alea::Verhulst2 ((seed fix/float) (lambda numbers?)                              (long fix>0) (dt fix/float)) list"Génère une séquence de longueur <long> fondée sur l'équation logistique de Pierre François Verhulst  yn = xn-1 + xn-1 * lambda * (1 - xn-1)  pour décrire la croissance des populations. où <lambda> est un nombre ou une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un (soit la population initiale comme ratio d'une population maximale),  et<long> est la longueur de la liste générée, où le nombre d'itérations. Cette version permet l'étude de la variation du paramètre de temps <dt>. <dt> est une valeur de temps pour l'intégration numérique des équations.La sortie de ce module est une liste des valeurs de chaque itération "(let ((res (cons seed nil)) (xn seed))  (dotimes (n long res)     (setf res (cons (setf xn (+ xn (* dt (if (listp lambda) (nth n lambda) lambda) xn (- 1 xn)))) res)))  (reverse res)))(pw::defunp baker1 ((seed fix/float (:value 0.9)) (int fix>0)) list"Transformation du boulanger -Stretch and fold-Pour cette transformation on considère que la pâte a une longueurinitiale égale à un. Un grain d'épice est placé au moment zéroà la coordonée <seed>. Ce modèle permet de trouver sa positionaprès un nombre <int> d'itérations, on sachant que ce modèle reproduitle travail d'un boulanger sur une pâte  de façon que chaque itération correspondà l'étirement de la pâte du double de sa longueur et le repliment  sur elle mêmede façon qu'elle retrouve la longueur un.La sortie de ce module est une liste des valeurs de chaque itération"(let ((aux) (xn seed))  (cons xn aux)  (dotimes (n int (reverse aux))    (push (setf xn                 (if (> xn .5)                   (- 2 (* 2 xn))                  (* 2 xn)))          aux))))(pw::defunp baker2 ((seed fix/float (:value 0.85)) (int fix>0)) list"Transformation du boulanger -Stretch cut and past-Pour cette transformation on considère que la pâte a une longueurinitiale égale à un. Un grain d'épice est placé au moment zéroà la coordonée <seed>. Ce modèle permet de trouver sa positionaprès un nombre <int> d'itérations, on sachant que ce modèle reproduitle travail d'un boulanger sur une pâte  de façon que chaque itération correspondà l'étirement de la pâte du double de sa longueur, la division de la pâte endeux morceaux et ...... La sortie de ce module est une liste des valeurs de chaque itération"(let ((aux) (xn seed))  (cons xn aux)  (dotimes (n int (reverse aux))    (push (setf xn                 (if (< xn .5)                  (* 2 xn)                  (-  (* 2 xn) 1)                  ))          aux))));======le vrai===========(defun lorentzeq (x y z a r c )"equation de base du système d'équations diferentielles"  (list (*  a (- y x))        (- (* x (- r z)) y)        (-  (* x y) (* c z))))(pw::defunp lorentz ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))                       (zinit fix/float (:value 1.0))                       (a fix/float (:value 10)) (R fix/float (:value 28))                       (c fix/float (:value 2.67)) (dt fix/float (:value .02))                       (pas fix>0 (:value 100))) list            "Système à equations  de lorentz:dx= -ax + aydy= Rx - y - xzdz= -cz + xy Ces équations donnent une description approximée d'une couche fluidechaufée par le bas. Le fluide chaud qui est en dessous est plusléger et tend a monter. Commence, alors un mouvement de convection.Si la différence de temperature entre le haut et le bas est sufisament intense,la convection se fait d'une façon trubulente et irregulière.Le paramètre <R> est proportionnel à la différence de température, on l'appel le nombre de Reynolds.Le paramètre <a> est le nombre de Prandtl.<xinit>, <yinit> et <zinit> sont les coordonées initiales.<pas> est le nombre d'itérations, où de points générés.<dt> est une valeur de temps pour l'intégration numérique des équationsLa sortie de ce module est une liste de coordonées en trois dimensions:((xinit yinit zinit) (x0 y0 z0) (x1 x2 x3) ... (xn yn zn))"    (let ((aux) (x xinit) (y yinit) (z zinit) (fk) (ffk) )    (dotimes (n pas (reverse aux))      (setf fk (lorentzeq x y z a R c))      (setf ffk (lorentzeq (+ x (* dt (nth 0 fk)))                           (+ y (* dt (nth 1 fk)))                           (+ z (* dt (nth 2 fk)))                           a R c))      (push (list              (setf x (+ x                        (* (/ dt 2)                           (+ (nth 0 fk) (nth 0 ffk)))))             (setf y (+ y                        (* (/ dt 2)                           (+ (nth 1 fk) (nth 1 ffk)))))             (setf z (+ z                        (* (/ dt 2)                           (+ (nth 2 fk) (nth 2 ffk))))))            aux))))(pw::defunp lorentz2 ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))                       (zinit fix/float (:value 1.0))                       (a fix/float (:value 10)) (R fix/float (:value 28))                       (c fix/float (:value 2.67)) (dt fix/float (:value .02))                       (pas fix>0 (:value 100))) list" "(lorentz xinit yinit zinit a R c dt pas));====================================(pw::defunp naviereq ((x1 fix/float) (x2 fix/float) (x3 fix/float)                      (x4 fix/float) (x5 fix/float)                       (reyn fix/float) ) list            "A model obtained by a suitable five-mode truncation of the Navier-Stokes equations for a two-dimensional incompressible fluid on a torus, where <reyn> is the Reynolds number,and exibits  an interesting variety of different behaviors for different ranges of <reyn>. For the critical values of <reyn>, the most interestingfeature is the stochastic behavior observed when  R1 < <reyn> < R2.With 28.73 < R1 > 29.0 and R2 ± = 33.43"  (list   (+ (* x1 -2) (* 4 x2 x3) (* 4 x4 x5))   (+ (* x2 -9) (* 3 x1 x3) )   (+ (* x3 -5) (* -7 x1 x2) reyn )   (+ (* x4 -5) (*  (- x1) x5)  )   (+ (* x1 x4 -3) (- x5)  )))(pw::defunp navier-stokes ((x1-in fix/float (:value 1)) (x2-in fix/float (:value 1)) (x3-in fix/float (:value 1))                           (x4-in fix/float (:value 1)) (x5-in fix/float (:value 1))                            (reyn fix/float (:value 28)) (dt fix/float (:value .04)) (pas fix>0 (:value 100))) list            "A model obtained by a suitable five-mode truncation of the Navier-Stokes equations for a two-dimensional incompressible fluid on a torus:dx1= -2*x1 + 4*x2*x3 + 4*x4*x5dx2= -9*x2 + 3*x1*x3dx3= -5*x3 - 7*x1*x2 + reyndx4= -5*x4 - x1*x5dx5= -x5 - 3*x1*x4Where <reyn> is the Reynolds number,and exibits  an interesting variety of different behaviors for different ranges of <reyn>. For the critical values of <reyn>, the most interestingfeature is the stochastic behavior observed when  R1 < <reyn> < R2.With 28.73 < R1 > 29.0 and R2 ± = 33.43.<x1>, <x2>, <x3>, <x4> et <x5> sont les coordonées initiales.<pas> est le nombre d'itérations, où de points générés.<dt> est une valeur de temps pour l'intégration numérique des équationsLa sortie de ce module est une liste de coordonées en cinq dimensions:((x1-in x2-in x3-in x4-in x5-in) ... (x1n x2n x3n x4n x5n))"  (let ((aux) (x1 x1-in) (x2 x2-in) (x3 x3-in) (x4 x4-in) (x5 x5-in)(fk) (ffk) )    (dotimes (n pas (reverse aux))      (setf fk (naviereq x1 x2 x3 x4 x5 reyn))      (setf ffk (naviereq (+ x1 (* dt (nth 0 fk)))                          (+ x2 (* dt (nth 1 fk)))                          (+ x3 (* dt (nth 2 fk)))                          (+ x4 (* dt (nth 3 fk)))                          (+ x5 (* dt (nth 4 fk)))                          reyn))      (push (list              (setf x1 (+ x1(* (/ dt 2)(+ (nth 0 fk) (nth 0 ffk)))))             (setf x2 (+ x2(* (/ dt 2)(+ (nth 1 fk) (nth 1 ffk)))))             (setf x3 (+ x3(* (/ dt 2)(+ (nth 2 fk) (nth 2 ffk)))))             (setf x4 (+ x4(* (/ dt 2)(+ (nth 3 fk) (nth 3 ffk)))))             (setf x5 (+ x5(* (/ dt 2)(+ (nth 4 fk) (nth 4 ffk))))))            aux))));;=========================================(pw::defunp stein ((seed fix/float) (lambda numbers? (:value 1.7)) (long fix>0)) list"equation itérative quadratique :Xn+1=lambda*sin(pi*Xn). où <lambda> est un nombre ou une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un . <long> est la longueur de la liste générée, où le nombre d'itérations.La sortie de ce module est une liste des valeurs de chaque itération Voir l'article:UNIVERSAL BEHAVIOR IN NONLINEAR SYSTEMS de Mitchell J. FEIGENBAUM,dans Los Alamos Science 1 4-27 (1980)"(let ((res) (xn seed))  (dotimes (n long res)     (setf res           (cons (setf xn (* (if (listp lambda) (nth n lambda) lambda) (sin (* xn 3.141592653589793)))) res)))  (reverse res)))(pw::defunp stein1 ((seed fix/float) (lambda numbers? (:value 2.3)) (long fix>0)) list"equation itérative quadratique :Xn+1=lambda*xn^2*sin(pi*Xn)Variation de l'équation Xn+1=lambda*sin(pi*Xn). où <lambda> est un nombre ou une liste de  paramètres qui définissent  la 'turbulence' des valeurs générés. <seed> est une valeure initiale entre zéro et un . <long> est la longueur de la liste générée, où le nombre d'itérations.La sortie de ce module est une liste des valeurs de chaque itérationVoir l'article:UNIVERSAL BEHAVIOR IN NONLINEAR SYSTEMS de Mitchell J. FEIGENBAUM,dans Los Alamos Science 1 4-27 (1980)"(let ((res) (xn seed))  (dotimes (n long res)     (setf res           (cons (setf xn (* (if (listp lambda) (nth n lambda) lambda) xn xn (sin (* xn 3.141592653589793)))) res)))  (reverse res)));=============================================(pw::defunp henon ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))              (a fix/float (:value 1.4)) (b fix/float (:value 0.3))               (pas fix>0 (:value 100))) list"Ce modèle  est  une version simplifié de la dynamique du systèmede Lorentz. Il fut sugeré par l'astronome français Michel Hénon en 1976.Xn+1= yn - a*xn^2 + 1Yn+1= b*xnavec a= 1.4  et b=0.3<xinit> et <yinit> sont des valeurs initiales<a> et <b> sont les paramètres, et<pas> est le nombre d'itérations, où de points générés.La sortie de ce module est une liste de coordonées en deux dimensions:((xinit yinit ) (x0 y0 ) (x1 x2 ) ... (xn yn ))See David RUELLE in 'Strange Attractors', The Mathematical Intelligencer 2 126-37 (1980). "  (let (auxlist)    (do ((x xinit (+ 1 y (- (* a x x ))))         (y yinit (* b x))         (n 1 (+ 1 n)))        ((= n pas) (reverse auxlist))      (push (list x y ) auxlist))))(pw::defunp alea::henon-heilles ((xinit fix/float (:value .1)) (yinit fix/float (:value .1))                            (ydot fix/float (:value .1)) (E  fix/float (:value 1/8))                            (dt fix/float (:value .02))                            (pas fix>0 (:value 100)))list"Ce système fut originalelment introduit comme un modèle simplifié du mouvement individuel d'une étoiledans un champ gravitationnel:dx^2/dt^2= -x-2xy  dy^2/dt^2= -y+y^2-x^2oùx et y sont les coordonnées de l'étoile,E est l'energie totale du système,E= 1/2 * (x^2 + y^2 + 2*x^2*y - 2/3*y^3) + 1/2 * (dx^2 + dy^2) La valeur maximale permise à E est 1/6.<xinit>, <yinit> et <ydot> sont des valeurs initiales,<E> est la valeur de l'énergie, <dt> est une valeur de temps pour l'intégration numérique des équations, et <pas> est le nombre d'itérations, où de points générés.La sortie de ce module est une liste de coordonées en deux dimensions:((xinit yinit ) (x0 y0 ) (x1 x2 ) ... (xn yn ))See Rick Bidlack, 1992, Chaotic Systems as Simple (but Complex) compositional Algorithms, in CMJ vol16,n°3. And Robert H. G. Helleman (1980) -SELF-GENERATED CHAOTIC BEHAVIOR IN NONLINEAR MECHANICS- inFundamentals Problems in Statistical Mechanics vol 5 pp 165-233."  (let ((auxlist)         (xdot (sqrt (+ (* 2.0 E)                       (- (* yinit yinit))                       (* yinit yinit yinit (/ 4.0 3.0))                       (- (* ydot ydot)))))        (xdotdot) (ydotdot) (x xinit) (y yinit))    (dotimes (n pas (reverse auxlist))      (setf xdotdot (+ (- x) (- (* 2.0 x y))))      (setf ydotdot (+ (- y) (- (* x x)) (* y y)))      (setf xdot (+ xdot (* xdotdot dt)))      (setf ydot (+ ydot (* ydotdot dt)))      (setf x (+ x (* xdot dt)))      (setf y  (+ y (* ydot dt)))      (push (list x y xdot ydot) auxlist))))(pw::defunp alea::torus ((Iinit fix/float (:value 1.0)) ( Tinit fix/float (:value 1.0))                   (K fix/float (:value 1.0))  (pas fix>0 (:value 100))) list            "Ce système d'équations est dérivé d'un modelè d'un pendule qui des perturbations périodiques:In+1 = In + K * sin TnTn+1 = Tn + In+1 oùK est un paramètre de perturbationI et T sont les variables de l'espace de phasesprises en modulo 2*pi entre 0 et 2*pi.<Init> et <Tinit> sont les valeurs initiales<K> est le paramètre de perturbation<pas> est le nombre d'itérations, où de points générés.La sortie de ce module est une liste de coordonées en deux dimensions:((Iinit Tinit ) (I0 T0 ) (I1 T2 ) ... (In Tn ))See Rick Bidlack, 1992, Chaotic Systems as Simple (but Complex) compositional Algorithms, in CMJ vol16,n°3"  (let ((auxlist) )    (do* ((I (mod Iinit (* 2 #,pi))  (mod (+ I (* k (sin TT))) (* 2 #,pi)))         (TT (mod Tinit (* 2 #,pi)) (mod (+ I  TT) (* 2 #,pi)))         (n 1 (+ 1 n)))        ((= n pas) (reverse auxlist))      (push (list I TT ) auxlist))));================================================(defun rosslereq (x y z a b c )"equation de base du système d'équations diferentielles"  (list (- (+ y z))        (+  x (* a y))        (+ b (* x z) (- (* c z)))))(pw::defunp rossler ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))                       (zinit fix/float (:value 1.0))                       (a fix/float (:value .2)) (b fix/float (:value .2))                       (c fix/float (:value 5.7)) (dt fix/float (:value .02))                       (pas fix>0 (:value 100))) list            "Le système d'équations de Rosslerdx/dt = - (x + y)dy/dt = x + a*ydz/dt = b + x*z - c*zest un système artificiel avec le seul propos de céer un modèle simple pour l'étude d'un attracteur étrange.<xinit>, <yinit> et <zinit> sont les coordonées initiales.<pas> est le nombre d'itérations, où de points générés.<a>, <b> et <c> sont les paramètres du système.<dt> est une valeur de temps pour l'intégration numérique des équationsLa sortie de ce module est une liste de coordonées en trois dimensions:((xinit yinit zinit) (x0 y0 z0) (x1 x2 x3) ... (xn yn zn))Voir Otto E. Rossler, AN EQUATION FOR CONTINOUS CHAOS, in Phys. Lett 57A (1976) pp 397-398.  "  (let ((aux) (x xinit) (y yinit) (z zinit) (fk) (ffk) )        (dotimes (n pas (reverse aux))      (setf fk (rosslereq x y z a b c))      (setf ffk (rosslereq (+ x (* dt (nth 0 fk)))                           (+ y (* dt (nth 1 fk)))                           (+ z (* dt (nth 2 fk)))                           a b c))      (push (list              (setf x (+ x                        (* (/ dt 2)                           (+ (nth 0 fk) (nth 0 ffk)))))             (setf y (+ y                        (* (/ dt 2)                           (+ (nth 1 fk) (nth 1 ffk)))))             (setf z (+ z                        (* (/ dt 2)                           (+ (nth 2 fk) (nth 2 ffk))))))            aux))));::::::::::::::UTILS:::::::::::::::::::::::::::::::::::::;(defun sign (x)  (if (< x 0) -1 1)); (sign -6);==========================================================(pw::defunp ginger ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))             (cr fix/float (:value .9)) (pas fix>0)) list"Système d'equations itératives  : Xn+1 = 1 - yn - cr*(abs x)Yn+1 = xnoù<xinit> et <yinit> sont des valeurs initiales<cr> est un paramètre de contrôle entre zéro et un, et<pas> est le nombre d'itérations, où de points générés.La sortie de ce module est une liste de coordonées en deux dimensions:((xinit yinit ) (x0 y0 ) (x1 x2 ) ... (xn yn ))  "  (do     ((x xinit (- 1  y (- (* cr (abs x)))))     (y  yinit x)     (n  1 (+ 1 n))     (auxlist nil))    ((>= n pas) (reverse auxlist))    (push (list x y) auxlist)    ))(pw::defunp ginger2 ((xinit fix/float (:value 1.0)) (yinit fix/float (:value 1.0))             (crin fix/float (:value .8)) (crend fix/float (:value .99))(pas fix>0)) list"Système d'equations itératives  : Xn+1 = 1 - yn - cr*(abs x)Yn+1 = xnavec un paramètre de contrôle évolutifoù<xinit> et <yinit> sont des valeurs initiales<crin> est un paramètre de contrôle initial entre zéro et un<crend> est un paramètre de contrôle final entre zéro et un.Pendant les calculs, ou l'évolution du système il existe une interpolationdes valeurs de <cr> entre <crin> et <crend>., et<pas> est le nombre d'itérations, où de points générés.La sortie de ce module est une liste de coordonées en deux dimensions:((xinit yinit ) (x0 y0 ) (x1 x2 ) ... (xn yn ))  "  (do     ((cr crin (+ cr (/ (- crend crin) pas)))     (x xinit (- 1  y (- (* cr (abs x)))))     (y  yinit x)     (n  1 (+ 1 n))     (auxlist nil))    ((>= n pas) (reverse auxlist))    (push (list x y) auxlist)    ));=============================================================;=============Iterated function systems=====================;=============================================================(pw::defunp alea::choixaux ((vectprob numbers?)  (listobjets list )) list"Ce module éfétue un choix entre plusieurs alternatives (<listobjets>) à partird'un vecteur de probabilités <vectprob>"(nth (do ((indice 0 (+ indice 1))     (u (/ (random 10000.0) 10000.0))     (valeur 0))      ; déf de var    ((> valeur u) (- indice 1))  (setf valeur (+ valeur (nth  indice vectprob)))) listobjets));(alea::choixaux '(.33 .2 .1 .27 .1) '(0 1 2 3 4))(pw::defunp alea::IFSx ((data list) (ints fix>0)                         (objet list (:value '((1 1)):type-list (list  pw::c-break-point-function)))                         (efact fix/float (:value 100)) (ffact fix/float (:value 100))                         (mode menu (:menu-box-list (("deter" .  1) ("random" .  2)) ))) list            "Iterated function system sequentiel<Objet> est une liste de listes contenant les coordonées d'un objet (-une figure-)ou une <BPF> avec un objet géometrique.<ints> est le nombre d'itérations souhaitées<data> est une liste de listes contenant des données pour les transformations linèaires       À cette entrée on branche soit un module <ifs-lib>, soit un module <make-w>        (qui permet de construire ses propres transformations linèaires),        soit un module <make3-w> (qui équivaut à trois <make-w>)        ou un module <app-W-trans> (utilisé pour grouper les modules <make-w>.<efact> est un facteur multiplicatif pour le facteur de translation horizontale<ffact> est un facteur multiplicatif pour le facteur de translation verticale<mode> cette entrée est en fait un menu déroulant qui permet de choisir       le mode de fonctionement soit déterministe, soit probabiliste.La sortie de ce module est une liste de coordonées en deux dimensions de l'objet transformé:( (x0 y0 ) (x1 x2 ) ... (xn yn ))"  (let* ((objet (if (listp objet) objet (pw::mat-trans (list (pw::x-points objet) (pw::y-points objet)))))         (list (pw::mat-trans data))         (lenifs (length list))         (vectprob (pw::flat(last data))) ;option random         (listfunct  (pw::arithm-ser 0 1 (1- (length (pw::mat-trans data))))) ;option random         (aux1 nil) (aux nil)         (x ) (y ) (pair) (k nil))        (dotimes (n ints )      ; Késième équation            (dotimes (tr lenifs)        (case mode           (1 (setf k tr))          (2 (setf k (alea::choixaux vectprob listfunct))))        (dotimes (m  (length objet) pair)  ;applique la transformation <k> à tous les points de l'objet                    (setf  x (+ (* (nth 0 (nth k list)) (first (nth m objet)))                      (* (nth 1 (nth k list)) (second (nth m objet)))                      (* efact (nth 4 (nth k list)))))          (setf y (+ (* (nth 2 (nth k list)) (first (nth m objet)))                     (* (nth 3 (nth k list)) (second (nth m objet)))                     (* ffact (nth 5 (nth k list)))))          (push (list x y) aux1))        )            (setf aux  aux1)                       ;(append aux1 aux)      (setf objet aux1)      (setf aux1 nil))        (reverse aux) ))                 ;(pw::defunp alea::app-W-trans (&rest (list list)) list"Ce module st utilisé pour grouper deux ou plusieurs modules <make-w> pour la construction d'un système de transformations linèaires  .OBS: ce module est chargé fermé sur la fenêtre et il a besoin d'être ouvert."(pw::mat-trans  (mapcar #'(lambda (l) (pw::flat l)) list)))(pw::defunp alea::ifs-lib ((data menu (:menu-box-list (("syerp" . 1) ("tree0". 2)                                                        ("fern". 3) ("drag". 4) ("cantor". 5) ("twig". 6)                                                        ("cristal". 7) ("fern1" .  8)                                                         ("tree1" .  9)   ("castle" . 10)                                                       ("cloud" .  11) ("frnsqr" . 12)                                                        ("jewel" .  13) ("jewel2" .  14)                                                       ("frntre7" .  15) ("fern2" .    16)                                                       ("plant1" .  17) ("plant2" .  18) ("mountain" .  19))                                                      :type-list (no-connection)))) list" bibliothèque de données pour des IFSxL'entrée de ce module est un menu déroulant qui permet le choix d'un modèle particulier de transformations linèaires.À l'évaluation le module rendra une liste avec sept sous listes:En sachant que chaque  transformation se compose de deux matricesA  =  | a1 b1| et  t  = |e1|  et d'une probabilité associée  p1      | c1 d1|          |f1|   où  A est une transformation  des coordonnées et t est une translation.La liste de sortie correspondra aux sept groupes de données:((a1 a2 a3 ... an) (b1 b2 b3 ... bn) (c1 c2 c3 ... cn) (d1 d2 d3 ... dn)                   (e1 e2 e3 ... en) (f1 f2 f3 ... fn) (p1 p2 p3 ... pn))Il est vivement conseillé que pour la construction de transformations linèaireson utilise le modules <make-w>, <make3-w> et <app-W-trans>. "  (case data    (1 '((0.5 0.5 0.5) (0 0 0) (0 0 0) (0.5 0.5 0.5) (0 0.5 0) (0 0.5 0.5) (0.33 0.33 0.34)))    (2  '((0.195 0.462 -0.058 -0.035 -0.637) (-0.488 0.414 -0.07 0.07 0) (0.344 -0.252 0.453 -0.469 0)          (0.443 0.361 -0.111 -0.022 0.501) (0.4431 0.2511 0.5976 0.4884 0.8562)          (0.2452 0.5692 0.0969 0.5069 0.2513) (.2 .2 .2 .2 .2)))    (3  '((0 0.85 0.2 -0.15) (0 0.04 -0.26 0.28) (0 -0.04 0.23 0.26) (0.16 0.85 0.22 0.24) (0.5 0.075 0.4 0.575)          (0 0.183 0.049 -0.084) (.25 .25 .25 .25)))    (4  '((0 0 0) (0.577 0.577 0.577) (-0.577 -0.577 -0.577) (0 0 0) (0.0951 0.4413 0.0952)          (0.5893 0.7893 0.9853) (0.33 0.33 0.34)))    (5  '((0.333 0 0) (0 0.333 -0.333) (0 1.0 1) (0.333 0 0) (0.333 0.666 0.333) (0.666 0 0) (0.33 0.33 0.34)))    (6  '((0.387 0.441 -0.468) (0.43 -0.091 0.02) (0.43 -0.009 -0.113) (-0.387 -0.322 0.015) (0.256 0.4219 0.4)          (0.522 0.5059 0.4) (0.33 0.33 0.34)))    (7   '((0.382 0.382 0.382 0.382 0.382) (0 0 0 0 0) (0 0 0 0 0) (0.382 0.382 0.382 0.382 0.382)           (0.3072 0.6033 0.0139 0.1253 0.492) (0.619 0.4044 0.4044 0.0595 0.0595) (.2 .2 .2 .2 .2)))    (8 '((0 .85 .20 -.15) (0 .04 -.26 .28)(0 -.04 .23  .26)(.16 .85 .22 .24)         (0 0 0 0)(0 1.60 1.60 .44)(.01  .85  .07  .07) (.25 .25 .25 .25)))            (9 '((0 .42 .42 .10)(0 -.42 .42 0)(0 .42 -.42 0)(.50 .42 .42 .10)(0 0 0 0)         (0 .20 .20 .20)(.05 .40 .40 .15) (.25 .25 .25 .25)))          (10 '((.5 .5 .4 .5) (0 0 0 0) (0 0 0 0) (.5 .5 .4 .5) (0 .2 0 .2)           (0 0 .1 .1) (.25 .25 .25 .25)))        (11 '((.45 .42 .42 .1) (0 -.42 .42 0) (0 .42 -.42 0) (.50 .42 .42 .10) (0 0 .23 0)           (0 .20 .20 .20) (.17 .40 .40 .15)))        (12 '((.25 .67 .35 .18) (0 .02 -.13 .14)(0 -.02 .11 .13) (.33 .67 .36 .37)           (.50 25. .50 25.) (.50 1.3 25.80 25.22) (.02 .79 .05 .10)))     (13 '((0 .42 .42 -.67) (0 -.42 .42 0) (0 .42 -.42 0) (.50 .42 .42 .10)           (0 0 0 0) (.31 .20 .20 .20) (.14 .40 .40 .15)))    (14 '((0 .42 .42 .10) (0 -.42 .42 0) (0 .42 -.42 0) (.50 .42 .42 .10) (0 .31 -.30 0)           (0 .20 .20 .20) (.05 .40 .40 .15)))    (15 '((0 .71 .26 -.07) (0 -.10 -.06 .19) (0 .10 .04 .18) (.26 .71 .27 .19) (0 0  0 0)           (1.18 1.18 .36 .1) (.71 .16 .08 .05)))    (16 '((0 1.01 .23 -.16) (0 .4 -.29 .28) (0 -.04 .24 .28) (.16 .91 .24 .26) (0 0  0 0)           (1.61 1.71 .44 .01) (.89 .07 .07 .06)))    (17 '((0 .42 .42 .10) (0 -.42 .42 0) (0 .42 -.42 0) (.50 .76 .42 .10) (0 0 0 0)           (0 .20 .20 .20) (.05 .40 .40 .15)))    (18 '((0 .42 .42 .10) (0 -.42 .42 0) (0 .42 -.42 0) (.50 .42 .77 .10) (0 0 0 0)          (0 .20 .20 .20) (.05 .40 .40 .15)))    (19 '((.43 .71 .34 .63) (-.04 -.12 .08 -.40) (-.09 .15 .23 .01) (.53 .48 .41 .49)           (.51 .14 0 .16) (.29 .21 .44 .49) (.29 .28 .20 .49)))))(pw::defunp alea::make-w ((r fix/float (:value 1)) (s fix/float (:value 1))                     (tet1 fix/float) (tet2 fix/float)                     (e fix/float) (f fix/float)                     (approx fix/float (:value 4)) &optional (prob numbers? (:value .5))) list"construction d'une matrice  pour  une transformation linèaire, où<r> coef de contraction pour l'axe x <s> coef de contraction pour l'axe y (tet1> décalage angulaire pour l'axe x<tet2>  décalage angulaire pour l'axe y<e> translation horizontale <f> translation verticale<prob> est une probabilité affectée à la transformation linèaire au cas        d'un système de transformations<approx> est le nombre de décimalespour les données de sortie (soit la matrice)En sachant que chaque  transformation se compose de deux matricesA  =  | a1 b1| et  t  = |e1|     et d'une probabilité associée  p1      | c1 d1|          |f1|   où  A est une transformation  des coordonnées et t est une translation.Il est possible de réécrire la matrice A commeA  =  | a1 b1|     A  =  | r*(cos tet1) -s*(sin tet2)|       | c1 d1|           | r*(sin tet1)  s*(cos tet2)| où r et s sont des facteurs de contraction pour les axes x et y respectivementet tet1 et tet2 sont les décalages angulaires pour les axes x et y respectivement            "(let ((tet1 (alea::deg->rad tet1)) (tet2 (alea::deg->rad tet2)))  (pw::g-round (mapcar 'list                       (pw::x-append (* r (cos tet1))                                    (* (- s) (sin tet2))                                    (* r (sin tet1))                                    (* s (cos tet2))                                    e  f prob)) approx)))(pw::defunp alea::make3-w ((r0 fix/float (:value 1)) (s0 fix/float(:value 1))                            (tet10 fix/float) (tet20 fix/float)                            (e0 fix/float) (f0 fix/float)                            (r1 fix/float(:value 1)) (s1 fix/float(:value 1))                            (tet11 fix/float) (tet21 fix/float)                            (e1 fix/float) (f1 fix/float)                            (r2 fix/float(:value 1)) (s2 fix/float(:value 1))                            (tet12 fix/float) (tet22 fix/float)                            (e2 fix/float) (f2 fix/float)                            (approx fix/float (:value 4))                            &optional (prob1 numbers? (:value .33))                           (prob2 numbers? (:value .34)) (prob3 numbers? (:value .33))) list"construction d'une matrice pour  un système de trois transformations linèaires, où <rn> coef de contraction pour l'axe x <sn> coef de contraction pour l'axe y (tet1n> décalage angulaire pour l'axe x<tet2n>  décalage angulaire pour l'axe y<en> translation horizontale <fn> translation verticale<probn> est une probabilité affectée à la transformation linèaire au cas        d'un système de transformations<approx> est le nombre de décimalespour les données de sortie (soit la matrice)En sachant que chaque  transformation se compose de deux matricesA  =  | a1 b1| et  t  = |e1|     et d'une probabilité associée  p1      | c1 d1|          |f1|   où  A est une transformation  des coordonnées et t est une translation.Il est possible de réécrire la matrice A commeA  =  | a1 b1|     A  =  | r*(cos tet1) -s*(sin tet2)|       | c1 d1|           | r*(sin tet1)  s*(cos tet2)| où r et s sont des facteurs de contraction pour les axes x et y respectivementet tet1 et tet2 sont les décalages angulaires pour les axes x et y respectivement  "  (pw::mat-trans    (pw::flat-low    (list (alea::make-w r0 s0 tet10 tet20 e0 f0 approx prob1)          (alea::make-w r1 s1 tet11 tet21 e1 f1 approx prob2)          (alea::make-w r2 s2 tet12 tet22 e2 f2 approx prob3)))));============================================================;============fractus=========================================;============================================================(pw::defunp  alea::midpoint1  ((liste1 list) (niveaux  fix>0)                         (prc-x fix/float) (prc-y fix/float)) list"Construit une liste de doublets <x y> à partir de l'algorithmede deplacement du point moyen.<liste1> est une liste de listes, où chaque sous-liste est une          paire de valeurs indiquant les coordonnés des points fixes,         <liste1> poura, aussi être une BPF, dans ce cas les coordonnés des points         seront prises comme données.<niveaux> est un entier qui indique la profondeur de la transformation de <liste1><prc-x> est le pourcentage d'aléa introduit dans les 'x'<prc-y> est le pourcentage d'aléa introduit dans les 'y'.Pour cette version la variation est fondée dans une distribution uniforme.La sortie de ce module est une liste de coordonées en deux dimensions de la <liste1> transformée:( (x0 y0 ) (x1 x2 ) ... (xn yn ))"  (let ((aux) (xnew) (ynew)         (liste1 (if (listp liste1) liste1 (alea::paires liste1))))    (dotimes (n niveaux liste1)      (dotimes (m (1- (length liste1)) )        (setf xnew (pw::g-alea                    (/ (+ (first (nth m liste1))                          (first (nth (1+ m) liste1)))                          2)                    prc-x))                (setf ynew (pw::g-alea                    (/ (+ (second (nth m liste1))                          (second (nth (1+ m) liste1)))                          2)                    prc-y))        (push (list xnew ynew) aux))      (setf liste1 (pw::sort-list (append aux liste1) '< 'first))      (setf aux nil))))(pw::defunp gauss ((mu fix/float (:value 0)) (sigma fix/float (:value 1))) float"génére un nombre avec une distribution de gauss , avec une  moyenne  <mu> et unelargeur de bande <sigma>.Il est important de savoir que la distribution de gauss n'est pas bornée,et que 99.74 % des resultats tombent entre -3*sigma et +3*sigma,mais pour l'algorithme utilisé ici, les resultats seront bornés entre -6*sigma et +6*sigma. Pour la plus grande partie des cas cette aproximationest acceptable, puisque a peine deux resultats en un milliard, d'un vrai processusgaussien, tombent hors de ces limites."(let ((s 0))  (for (n 1 1 12)  (setf s (+ s (random 1.0))))           (+ (* (- s 6) sigma) mu)))(pw::defunp  alea::midpoint2  ((liste1 list) (niveaux  fix>0)                         (sig-x fix/float) (sig-y fix/float)) list"Construit une liste de doublets <x y> à partir de l'algorithmede deplacement du point moyen.<liste1> est une liste de listes, où chaque sous-liste est une          paire de valeurs indiquant les coordonnés des points fixes,         <liste1> poura, aussi être une BPF, dans ce cas les coordonnés des points         seront prises comme données.<niveaux> est un entier qui indique la profondeur de la transformation de <liste1><prc-x> est le paramètre de dispersion de la variation gaussienne introduit dans les 'x'<prc-y> est le paramètre de dispersion de la variation gaussienne introduit dans les 'y'.Pour cette version la variation est fondée dans une distribution gaussienneLa sortie de ce module est une liste de coordonées en deux dimensions de la <liste1> transformée:( (x0 y0 ) (x1 x2 ) ... (xn yn ))"  (let ((aux) (xnew) (ynew)        (liste1 (if (listp liste1) liste1 (alea::paires liste1))))    (dotimes (n niveaux liste1)      (dotimes (m (1- (length liste1)) )        (setf xnew (+ (alea::gauss  0 sig-x)                    (/ (+ (first (nth m liste1))                          (first (nth (1+ m) liste1)))                          2)                    ))                (setf ynew (+ (alea::gauss  0 sig-y)                    (/ (+ (second (nth m liste1))                          (second (nth (1+ m) liste1)))                          2)                   ))        (push (list xnew ynew) aux))      (setf liste1 (pw::sort-list (append aux liste1) '< 'first))      (setf aux nil))));ATTENTION MIDPOINT2 UTILISE GAUSS!!;;;=========================================================;;; FRACT-GEN!!!!!!!!!!!!!!!!!!!!!!!!;==================================================================;     FONCTIONS AUXILIAIRES;==================================================================(pw::defunp distance ((xo fix/float) (yo  fix/float) (x1 fix/float) ( y1 fix/float)) number"calcule la distance dans le plan entre deux points de coordonnées <xo yo> et <x1 y1>"(sqrt (+ (*  (- x1 xo) (- x1 xo))         (*  (- y1 yo) (- y1 yo)))))(pw::defunp angle ((xo fix/float) (yo  fix/float) (x1 fix/float) ( y1 fix/float)) number"calcule l'angle dans le plan formé à partir du segment de droite formé par  deux points de coordonnées <xo yo> et <x1 y1> et l'axe des 'x'"(cond ((and (= 0 (- x1 xo)) (> (- y1 yo) 0)) #,(/ pi 2))      ((and (= 0 (- x1 xo)) (< (- y1 yo) 0)) (/ #,(* 3 pi) 2))      ((and (> 0 (- x1 xo)) (= (- y1 yo) 0)) #,pi)      ((and (< 0 (- x1 xo)) (= (- y1 yo) 0)) 0)            ((and (< (- y1 yo) 0) (< (- x1 xo) 0)) (+ #,pi (atan (/ (- y1 yo) (- x1 xo)))))            ((and (>= (- y1 yo) 0) (< (- x1 xo) 0)) (+ #,pi (atan (/ (- y1 yo) (- x1 xo)))))            (t (atan (/ (- y1 yo) (- x1 xo))))))(pw::defunp rad->deg ((radi fix/float)) numbers?"Conversion de radians en degrés "(/ (* 180.0 radi) #,pi))(pw::defunp deg->rad ((deg fix/float)) numbers?"Conversion de degrés en radians"  (/ (* deg #,pi) 180.0));LA SORTIE DE <INTERPOINTS> EST UNE DOUBLE LISTE DES POINT ENTRE;<XO, YO> (INCLUSIF) ET <X1,Y1> (EXCLUSIF);==================================================================(pw::defunp fract-gen ((xlist list) (ylist list) (int fix>0) &OPTIONAL (tab object (:value '()))) list            "génération de courbes fractales à partir de données graphiques"  (let* ((xlist (if tab (pw::x-points tab) xlist))         (ylist (if tab (pw::y-points tab) ylist))         (dno (distance(first xlist) (first ylist)                     (epw::l-last xlist) (epw::l-last ylist)))         (radius nil)          (teta nil)           (list-aux))    ;construction des transformations à partir de la courbe 'graine'    (dotimes (n (1- (length xlist)))      (push (distance(nth n xlist) (nth n ylist) (nth (1+ n) xlist) (nth (1+ n) ylist)) radius)      (push (angle (nth n xlist) (nth n ylist) (nth (1+ n) xlist) (nth (1+ n) ylist)) teta))    (setf radius (reverse radius))    (setf teta (reverse teta))    ;construction des itérations    (dotimes ( n int (reverse list-aux))      (setf list-aux nil)      (dotimes (m (- (length xlist) 1)   (reverse list-aux))        (let ((factcomp (/ (distance(nth m xlist) (nth m ylist) (nth (1+ m) xlist) (nth (1+ m) ylist)) dno) )              (teta2 (angle (nth m xlist) (nth m ylist) (nth (1+ m) xlist) (nth (1+ m) ylist)))              (px (nth m xlist)) (py (nth m ylist)) )          (push (list px py) list-aux)          (dotimes (n  (1- (length radius)) (reverse list-aux))            ;calcule des points en coordonnées absolutes et            ; transformation en fonction de la droite formé à partir            ;du segment de droite formé par  deux points de             ;coordonnées <xo yo> et <x1 y1>            (push (list                    (setf px (+ (* (nth n radius)                                   factcomp                                   (cos (+ teta2 (nth n teta))))                               px))                   (setf py (+ (* (nth n radius)                                   factcomp                                   (sin (+ teta2 (nth n teta))))                               py)))                  list-aux))))      (push (list (epw::l-last xlist) (epw::l-last ylist)) list-aux)      (setf xlist  (first (pw::mat-trans (reverse list-aux))))      (setf ylist (second (pw::mat-trans (reverse list-aux)))))))(pw::defunp alea::fract-gen1 ((obj1 list (:type-list (list object)))                                                             (int fix>0)                                &OPTIONAL (obj2 list (:type-list (list object) :value '()))) list            "génération de coordonnées des points de courbes fractales à partir de données graphiques<obj1> paires de coordonnées ou une BPF<int> est le nombre d'itérations<obj2> paires de coordonnées ou une BPFLe module <fract-gen1> applique la figure, ou l'objet défini par <obj1> sur lui même,ou sur un autre objet <obj2> au cas où cette entrée optionelle est ouverte.La sortie de ce module est une liste de coordonées en deux dimensions :( (x0 y0 ) (x1 x2 ) ... (xn yn ))"  (let*     ((xlist1 (if (listp obj1) (first (pw::mat-trans obj1)) (pw::x-points obj1)))     (ylist1 (if (listp obj1) (second (pw::mat-trans obj1)) (pw::y-points obj1)))     (xlist2 (if obj2 (if (listp obj2) (first (pw::mat-trans obj2)) (pw::x-points obj2)) xlist1))     (ylist2 (if obj2 (if (listp obj2) (second (pw::mat-trans obj2)) (pw::y-points obj2)) ylist1))     (dno (alea::distance(first xlist1) (first ylist1)                          (epw::l-last xlist1) (epw::l-last ylist1)))     (radius nil)      (teta nil)       (list-aux))    ;construction des transformations à partir de la courbe 'graine'    (dotimes (n (1- (length xlist1)))      (push (alea::distance(nth n xlist1) (nth n ylist1) (nth (1+ n) xlist1) (nth (1+ n) ylist1)) radius)      (push (alea::angle (nth n xlist1) (nth n ylist1) (nth (1+ n) xlist1) (nth (1+ n) ylist1)) teta))    (setf radius (reverse radius))    (setf teta (reverse teta))    ;construction des itérations    (dotimes ( n int (reverse list-aux))      (setf list-aux nil)      (dotimes (m (- (length xlist2) 1)   (reverse list-aux))        (let ((factcomp (/ (alea::distance(nth m xlist2) (nth m ylist2) (nth (1+ m) xlist2) (nth (1+ m) ylist2)) dno) )              (teta2 (alea::angle (nth m xlist2) (nth m ylist2) (nth (1+ m) xlist2) (nth (1+ m) ylist2)))              (px (nth m xlist2)) (py (nth m ylist2)) )          (push (list px py) list-aux)          (dotimes (n  (1- (length radius)) (reverse list-aux))            ;calcule des points en coordonnées absolutes et            ; transformation en fonction de la droite formé à partir            ;du segment de droite formé par  deux points de             ;coordonnées <xo yo> et <x1 y1>            (push (list                    (setf px (+ (* (nth n radius)                                   factcomp                                   (cos (+ teta2 (nth n teta))))                               px))                   (setf py (+ (* (nth n radius)                                   factcomp                                   (sin (+ teta2 (nth n teta))))                               py)))                  list-aux))))      (push (list (epw::l-last xlist2) (epw::l-last ylist2)) list-aux)      (setf xlist2  (first (pw::mat-trans (reverse list-aux))))      (setf ylist2 (second (pw::mat-trans (reverse list-aux)))))));============================================================(pw::defunp alea::paires ((bpf object)) list"retourne une liste avec les coordonées des points d'une BPF"  (pw::mat-trans (list (pw::x-points bpf) (pw::y-points bpf))));=========================================================#|(defvar ALEA)(defpackage "ALEA"   (:use "COMMON-LISP" "CCL")  (:import-from "PW" defunp))(in-package "ALEA")(defparameter *CHAOS-menu*           (pw::new-menu "CHAOS"))(ccl:add-menu-items patch-work::*pw-menu-patch* *CHAOS-menu*);:::::::::::::::::::::::orbitals::::::::::::::::::::::::::::::::::(defparameter *orbitals-menu*           (pw::new-menu "orbitals"))(pw::pw-addmenu *orbitals-menu* '(alea::Verhulst Verhulst2 alea::kaosn kaosn1 baker1 baker2 lorentz navier-stokes steinstein1 henon henon-heilles torus rossler ginger ginger2))(add-menu-items *CHAOS-menu* *orbitals-menu* );:::::::::::::::::::::::IFS:::::::::::::::::::::::::::::::::::(defparameter *IFS-menu*           (pw::new-menu "IFS"))(pw::pw-addmenu *IFS-menu* '(alea::ifs-lib alea::IFSx alea::make-w alea::make3-w alea::app-W-trans))(add-menu-items *CHAOS-menu* *IFS-menu* );:::::::::::::::::::::::::FRACTALS:::::::::::::::::::::::::::::(defparameter *fractus-menu*           (pw::new-menu "fractus"))(pw::pw-addmenu *fractus-menu* '(midpoint1 midpoint2  alea::fract-gen1))(add-menu-items *CHAOS-menu* *fractus-menu* );:::::::::::::::::::::::::UTILS:::::::::::::::::::::::::::::(defparameter *UTILS-menu*           (pw::new-menu "UTILS"))(pw::pw-addmenu *UTILS-menu* '(distance angle rad->deg deg->rad paires alea::choixaux))(add-menu-items *CHAOS-menu* *UTILS-menu* )|#