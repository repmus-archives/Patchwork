;======================================================================================================;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;======================================================================================================;;                         LIBRAIRIE DE MANIPULATIONS COMBINATOIRES;         INSPIRÉES(?) DANS ET PAR LA TECHNIQUE COMPOSITIONNELLE DE BRIAN FERNEYHOUGH;;======================================================================================================;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;======================================================================================================;;;      Cette librairie a été conçu pendant le passage du compositeur Brian Ferneyhough par la pédagogie;       de l'IRCAM.;       Pendant les mois de mars/avril 1993 à janvier-avril 1996.;                                                                    by Mikhail Malt     IRCAM 1993-1996                                                             ;;;;;(in-package "COMMON-LISP-USER");pour l'index de positions(defvar index 0);pour des posiions(defvar position 0);pour des listes auxilliaires(defvar aux1 nil)(defvar aux2 nil);=====================manipulations fréquentielles================================(pw::defunp ratio-freq ((fund  midic) (ratio numbers?)) list"calcule une liste de fréquences avec des relations <ratio>"  (let ((note (pw::mc->f fund))  (aux))    (push note aux)    (dolist (n ratio)      (push (setf note (* note n)) aux))    (pw::f->mc (reverse aux))))(pw::defunp ratio  ((init numbers?) (ratio fix/float)  (n fix>0)) list"prend en entrée un intervalle <init> en midicents et un <ratio>pour construire une liste de <n> éléments avec des ratios decroissants d'intervallesentre eux"  (let ((aux (first init)) (val))    (dotimes (x  n)      (push aux val)      (setf aux (* aux ratio)))    (reverse val)));==============================piqué (still) from Laurent Poittier=======================(pw::defunp geomt ((init fix/float ) (n fix>0)  (pas fix/float)) list "Construit une série géometrique de <n> éléments avec valeur initiale <init> et facteur multiplicatif <pas> "  (if (= n 0)()    (cons init (geomt (* pas init) (1- n) pas))));=================================================================================(pw::defunp g-subs (( sequence list)                    (old numbers? ) (new numbers?)) numbers?   "substitue <old> par <new> à n'importe quel niveau <old> et <new> peuvent être un nombre ou un symbole.<new> peut être aussi une liste"  (epw::deep-mapcar/1  #'(lambda (x) (if (equalp x old) new x)) sequence))(defun subs-prof-list (liste1 liste2)  (cond ((null liste1) nil)        ((atom liste1) (nth (incf index) liste2))        (t (cons ( subs-prof-list (first liste1) liste2)                  ( subs-prof-list(rest liste1) liste2)))))(pw::defunp gl-subs ((list1 list) (list2 list))list"substitution des éléments de la liste2 (plate)               dans la liste1 (avec plusieurs niveaux)"  (let ((index -1) )    (subs-prof-list list1 list2))) ;; ==================================================================================== ;;                                PAQUET   combine;; ==================================================================================== ;;          V1.0;;                                 functions by Mikhail Malt   08/10/1993 Paris IRCAM (pw::defunp ser-op ((serie list (:value '(6000 6300 6600 6400 6500 7100)))                     (oper menu (:menu-box-list (("-O-" . 1) ("-R-". 2) ("-I-". 3) ("-RI-". 4))                                               :type-list (no-connection)))                    &optional                    (mode menu (:menu-box-list (("interv" . 1) ("note". 2) )                                               :type-list (no-connection)))                    (in/pi fix/float)) list            "Les quatre opérations de base de la musique sérielle.Les entrées optionnelles permetent d'obtenir les quatres formes avec des contrôles différents. OBS: dans le mode <interv> la transposition est indiquée en midicents!!"  (case oper     (1 (if   (or (= 1 mode) (= 2 mode))  (case mode                                            (1 (pw::g+ in/pi serie))                                           (2 (pw::dx->x in/pi (pw::x->dx serie))))             serie))    (2 (if   (or (= 1 mode) (= 2 mode)) (case mode                                           (1 (pw::g+ in/pi (reverse serie)))                                          (2 (pw::dx->x in/pi (pw::x->dx (reverse serie)))))             (reverse serie)))    (3 (if   (or (= 1 mode) (= 2 mode)) (case mode                                           (1 (pw::g+ in/pi (pw::dx->x (first serie) (pw::g* -1 (pw::x->dx serie)))))                                          (2 (pw::dx->x in/pi (pw::g* -1 (pw::x->dx serie)))))             (pw::dx->x (first serie) (pw::g* -1 (pw::x->dx serie)))))    (4 (if   (or (= 1 mode) (= 2 mode)) (case mode                                           (1 (pw::g+ in/pi (pw::dx->x (first serie) (reverse (pw::g* -1 (pw::x->dx serie))))))                                          (2 (pw::dx->x in/pi (reverse (pw::g* -1 (pw::x->dx serie))))))             (reverse (pw::dx->x (first serie) (pw::g* -1 (pw::x->dx serie))))))))(pw::defunp rot90 ((serie list (:value '(6000)))  &optional (mod fix (:value 12))) list            "La rotation de 90° selon Walter O'Connell. Inversion entre dates et hauteurs"  (m->mc    (second     (pw::mat-trans      (pw::sort-list       (pw::mat-trans (list (mc->m serie mod) (pw::arithm-ser 0 1(1- mod))))      '<  'first)))))(pw::defunp space ((serie list (:value '(6000))) (gen fix (:value 1)) &optional (mod fix (:value 12))) list            "transformation d'une série par changement d'espace.<gen> est le générateur du nouveau espace et<mod> est le modulo sur lequel nous travaillons ce dernier estun parametre optionnel il est par défaut 12"  (let ((aux nil) )    (dotimes (n mod aux)      (push (list n (mod (* n gen) mod)) aux))   (setf aux (reverse aux))    (mapcar  #'(lambda (x) (pw::g+ (pw::g* 1200 (- (first (octave x)) 3))                                    (m->mc (second (assoc (mc->m x mod) aux)) mod))) serie)))(pw::defunp retire ((liste list) (place fix) (n-elem fix>0)) list            "retire les <n-elem> éléments de la liste <liste> à partir de la place<place>. OBS: place=0 c'est-à-dire premier élément de liste"  (subseq  liste place n-elem))(pw::defunp segment ((liste list) (place fix) (n-elem fix>0)                     (lecture menu (:menu-box-list (("lin" . 1) ("circ". 2) )                                                   :type-list (no-connection)))) list            "retire les <n-elem> éléments de la liste <liste> à partir de la place<place>. OBS: place=0 c'est-à-dire premier élément de liste.Il est possible de choisir deux types de lectures -lineaire- ou -circulaire-"  (case lecture    (1 (if (> (length liste) (+ place n-elem)) (subseq  liste place  (+ place n-elem))           (nthcdr place (butlast liste 0))))    (2 (let ((aux))         (dotimes (n n-elem (reverse aux))           (push (nth (mod (+ n place ) (length liste)) liste) aux))))))(pw::defunp l-segment ((liste list) (place list) (n-elem list)                     (lecture menu (:menu-box-list (("lin" . 1) ("circ". 2) )                                                   :type-list (no-connection)))) list            "retire les <n-elem> éléments de la liste <liste> à partir de la place<place>. OBS: place=0 c'est-à-dire premier élément de liste.Il est possible de choisir deux types de lectures -lineaire- ou -circulaire-.Cette version autorise des listes por <place> et pour <n-elem>.Comme toujours la liste plus courte sera considérée!"  (mapcar #'(lambda (x y) (segment liste x  y lecture)) place  n-elem))(pw::defunp analyse ((accord list)) list            "analyse un accord ou une liste et retourne une liste avec tous les intervallescontenus dans chaque accord"  (sort    (remove nil            (pw::flat             (maplist  #'(lambda (x) (pw::g- (rest x) (first x))) accord))) #'<))(pw::defunp l-analyse ((accord list)) list            "analyse un accord ou une liste et retourne une liste avec tous les intervallescontenus dans chaque accord"    (cond   ((listp (first accord)) (mapcar  #'(lambda (x) (analyse (sort   x '<))) accord))   (t (analyse (sort   accord '<)))))      (pw::defunp mc->M ((liste midics?) &optional (mod fix (:value 12))) list"conversion d'une liste de midicents en classes residuelles modulo <mod>Le module par défaut est 12, il est possible d'utiliser d'autres modulos.Le do3 est toujours la note de référence"  (pw::g-mod (pw::g/ liste (pw::g/ 100 (/ mod 12)))  mod))(pw::defunp M->mc ((liste list) &optional (mod fix (:value 12)) (ref midic (:value 6000))) list"conversion d'une liste classes residuelles modulo <mod> en midicents  Le module par défaut est 12, il est possible d'utiliser d'autres modulos.Le do3 est toujours la note de référence"  (pw::g+ ref  (pw::g* liste (pw::g/ 1200 mod)  )))(pw::defunp octave ((midic midic)) numbers?"retourne l'octave à partir de c3=octave 3"(let ((midic (pw::list! midic)))(mapcar #'(lambda (x) (pw::g- (pw::g-div x 1200) 2) ) midic)));=====================================================================================================;============================================================================;;                PERMUTATIONS;;==================FONCTIONS AUXILIAIRES================================(defun construct-memo (aux2 liste-base memo-pos)  "CONSTRUCTION DE LA LISTE DES POSITIONS APPARIÉES"  (dotimes (n (length aux2) memo-pos)    (if (eql (nth n aux2) (nth n liste-base))       (setf (nth n memo-pos) (nth n aux2))))  memo-pos)    (defun construct-aux2 (aux2 aux3 memo-pos)  "CONSTRUCTION DE LA LISTE PERMUTÉE"  (let ( (indice 0))    (dotimes (m (length aux2))      (if (eql 0 (nth m memo-pos)) (prog ()                                     (setf (nth m aux2)                                            (nth indice aux3))                                     (setf indice (1+ indice)))          (setf (nth m aux2) (nth m memo-pos) )))    aux2)) (defun construct-aux3 (aux2 memo-pos)  "construction de la liste à permuter"  (let ((aux3))    (dotimes (n (length aux2))      (if (= 0 (nth n memo-pos))        (push (nth n aux2) aux3)))    (reverse aux3)));= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = (pw::defunp permutations ((bag list)) list            "Return a list of all the permutations of the input."  ;; If the input is nil, there is only one permutation:  ;; nil itself  (if (null bag)    '(())    ;; Otherwise, take an element, e, out of the bag.    ;; Generate all permutations of the remaining elements,    ;; And add e to the front of each of these.    ;; Do this for all possible e to generate all permutations.    (mapcan #'(lambda (e)                (mapcar #'(lambda (p) (cons e p))                        (permutations                         (remove e bag :count 1 :test #'eq))))            bag)));-----------------------------------------------------------------------------------(defun combx (vals n)  (cond   ((<=  n 0) vals)   (t (pw::flat-once        (pw::cartesian vals (combx vals (1- n)) 'pw::x-append)))))(pw::defunp combinations ((vals list) (n fix>=0)) list            "combination de <vals> n a n"  (let ((n (1- n)))    (combx vals n)));------------------------------------------------------------------------(pw::defunp messiaen ((list list) &optional (max fix>0 (:value 10))) list"permutation cyclique à la manière de messiaen"(let ((ref list)      (permut nil)      (n 1)      (aux (list list)))  (while (not (or (equal ref permut) (>= n max)))    (setf permut (first aux))    (setf permut (pw::posn-match permut list))    (push permut aux)    (incf n))  (reverse aux)));(messiaen '(6 2 8 5 3 4 1 7 0) 30);----------------------------------------------------------------------------(pw::defunp prolifer ((serie1 list) (serie2 list) &optional (mod fix>=0 (:value 12))) list"les séries proliferantes selon Baraqué"(let* ((factmod (/ 1200 mod))       ;(modser1 (pw::g-mod (pw::g/ serie1 factmod) mod))      (modser2 (pw::g-mod (pw::g/ serie2 factmod) mod)))  (pw::posn-match serie1 modser2)));------------------------------------------------------------------------------(pw::defunp saw ((list list) (pas fix>0)) list"permutation avec alternance"(pw::flat (pw::mat-trans (reverse (pw::list-modulo list pas)))))(pw::defunp rand-saw ((list list) (pas fix>0)) list"permutation avec alternance"(pw::flat (pw::mat-trans (pw::permut-random (pw::list-modulo list pas)))))(pw::defunp circ-saw ((list list) (pas fix>0) &optional (del fix (:value 1))) list"permutation avec alternance"(pw::flat (pw::mat-trans (pw::permut-circ  (pw::list-modulo list pas) del))))(pw::defunp oscil-permut ((list list)) list"oscillation entre les extremes"(let ((explode (pw::list-explode list 2)))(pw::flat (pw::mat-trans (list (first explode) (reverse (second explode)))))))(pw::defunp oscil-permutn ((list list) (deep fix>0)) list"oscillation entre les extremes avec contrôle de profondeur"(let ((aux list))  (dotimes (n deep aux)    (setf aux (oscil-permut aux)))))(pw::defunp rev-saw ((list list) (pas fix>0)) list"permutation en scie inversée"(pw::flat  (reverse (pw::list-explode  list pas))));----------------------------------------------------------------------(pw::defunp kreus0 ((list list)) list"Kreuspiel permutation"(let* ((longlist (length list))       (longlist/2 (pw::g-div longlist 2))       (half1 (pw::permut-circ                (pw::posn-match list                                (pw::arithm-ser 0 1 (1- longlist/2))) 1))       (half2 (pw::permut-circ                (pw::posn-match list                                (pw::arithm-ser longlist/2 1 (1- longlist))) -1)))(pw::x-append (butlast half1)              (first  half2)              (pw::last-elem half1)              (rest half2))))(pw::defunp kreus ((list list) (pas fix>0)) list"Kreuspiel permutation"(let ((aux list))(dotimes (n pas aux)  (setf aux (kreus0 aux)))))(pw::defunp kreus0-1 ((list list)) list"Kreuspiel permutation"(let* ((longlist (length list))       (longlist/2 (pw::g-div longlist 2))       (half1 (pw::permut-circ                (pw::posn-match list                                (pw::arithm-ser 0 1 (1- longlist/2))) -1))       (half2 (pw::permut-circ                (pw::posn-match list                                (pw::arithm-ser longlist/2 1 (1- longlist))) 1)))(pw::x-append (pw::last-elem half2)              (rest half1)              (butlast half2)              (first  half1)              )))(pw::defunp kreus-1 ((list list) (pas fix>0)) list"Kreuspiel permutation"(let ((aux list))(dotimes (n pas aux)  (setf aux (kreus0-1 aux)))));--------------------------------------------------------------------------(defun spiral-out-left (list)  (let* ((long (length list))         (index (pw::g-ceiling (pw::g/ long 2))))    (pw::posn-match list                    (pw::x-append (reverse (pw::arithm-ser index 1 (1- long)))                                  (pw::permut-circ (reverse (pw::arithm-ser 0 1 (1- index))) -1)))))(defun spiral-out-rigth (list)  (let* ((long (length list))         (index (pw::g-div long 2)))    (pw::posn-match list                    (pw::x-append (pw::permut-circ (reverse (pw::arithm-ser index 1 (1- long))) 1)                                  (reverse (pw::arithm-ser 0 1 (1- index)))                                  ))))(defun spiral-in-left (list)  (let* ((long (length list))         (index (pw::g-ceiling (pw::g/ long 2))))    (pw::posn-match list                    (pw::x-append (reverse (pw::arithm-ser index 1 (1- long)))                                  (pw::permut-circ (reverse (pw::arithm-ser 0 1 (1- index))) 1)))))(defun spiral-in-rigth (list)  (let* ((long (length list))         (index (pw::g-div long 2)))    (pw::posn-match list                    (pw::x-append (pw::permut-circ (reverse (pw::arithm-ser index 1 (1- long))) -1)                                  (reverse (pw::arithm-ser 0 1 (1- index)))                                  ))))(pw::defunp spiral ((list list) (mode menu (:menu-box-list (("out-l" . 1) ("out-r". 2)                                              ("in-l" . 3) ("in-r" . 3))                             :type-list (no-connection)))                                 (deep fix>0)) list       "spiral permutation"(let ((aux (list list)))  (dotimes (n deep (reverse aux))    (push (funcall  (case mode                     (1 'spiral-out-left)                     (2 'spiral-out-rigth)                      (3 'spiral-in-left)                       (4  'spiral-in-rigth))  (first aux)) aux))));--------------------------------------------------------------------------;----------------------------------------------------------------------------------(pw::defunp permut-dyn ((liste list )) list"calcule une permutation dynamique d'une liste complète jusqu'à sa mise en ordre. "(let ((aux1  )      (aux2 (copy-list liste))      (aux3 nil)      (memo-pos (pw::create-list (length liste) 0))       (liste-base (pw::sort-list  liste)))  (loop    (setf aux1 (append aux2 aux1))  (if (equal  liste-base aux2)     (return (reverse (epw::list-explode aux1 (/ (length aux1) (length liste))))) )  (setf memo-pos (construct-memo aux2 liste-base memo-pos)) ; memo-pos mémorise les positions pas appariées  (setf aux3 (construct-aux3 aux2 memo-pos))                   ; aux3 contient les éléments pas matchés!  (setf aux3  (pw::permut-random aux3))                    ; permutation de aux3  (setf aux2 (construct-aux2 aux2 aux3  memo-pos))         ; reconstruction de la liste à partir d'élém. permut et élém. fixes!   )))(pw::defunp permut-dyn1 ((lis1 list ) (lis2 list )) list"calcule une permutation dynamique entre <liste> et <liste2>.Les deux listes doivent contenir les mêmes éléments!!"(let ((aux1  nil)      (aux2 (copy-list lis1))      (aux3 nil)      (memo-pos (pw::create-list (length lis1) 0))       (liste-base (copy-list lis2)))  (loop    (setf aux1 (append aux2 aux1))    (if (equal  liste-base aux2)     (return (reverse (epw::list-explode aux1 (/ (length aux1) (length lis1))))) )  (setf memo-pos (construct-memo aux2 liste-base memo-pos))  (setf aux3 (construct-aux3 aux2 memo-pos))  (setf aux3  (pw::permut-random aux3))  (setf aux2 (construct-aux2 aux2 aux3  memo-pos))    )));====================================================================;= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ;==========cette fonction vérifie si un élément est plus petit que 1 et l'égale à 1===========;             version récursive(defun verifier1 (liste)  (cond ((null liste) nil)        ((atom liste) (if (< liste 1) 1 liste))        (t (cons (verifier1 (car liste))                 (verifier1 (cdr liste))))))(defun verifierx (liste   x)  (cond ((null liste) nil)        ((atom liste) (if (<= liste x) x liste))        (t (cons (verifierx (car liste) x)                 (verifierx (cdr liste) x)))));====================================================================; ramène par pas une liste à 1(pw::defunp single-to-1 ((liste list)) list"prend une liste simple et la réduit à une liste de 1"(let ((aux )  (len (length liste)))  (dotimes (m len aux)    (push  (verifier1 (pw::g- liste m)) aux))  (reverse aux)))(pw::defunp single-to-x ((liste list)  (x fix>0)) list"prend une liste simple et la réduit à une liste de  x"(do ((aux )      (aux1)     (indice 0 (1+ indice))      (liste-de-x (pw::create-list (length liste) x)))    ((equal aux1 liste-de-x )  (reverse aux))  (setf aux1 (verifierx (pw::g- liste indice) x))  (push   aux1 aux))); = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = (pw::defunp permut->to-1 ((liste list )) list"prend une liste de permutations ( de permut-dyn par exemple), où n'importe  et la ramène à 1"(let ((aux )      (aux1)      (liste-de-1 (pw::create-list (length (first liste)) 1)))  (dotimes (n (length liste) aux)    (push  (setf aux1 (verifier1 (pw::g- (nth n liste) n) )) aux)    (if (equal aux1 liste-de-1 ) (return aux)))  (if (equal aux1 liste-de-1 )    (reverse aux)    (do ((indice 1 (+ indice 1)))        ((equal aux1 liste-de-1 )  (reverse aux))      (push (setf aux1 (verifier1 (pw::permut-random (pw::g- aux1 indice)) )) aux)))));observation!!! les decrements sont faits indépendament, même si la permutation c'est répétée!!!!!; (pw::defunp permut->to-x ((liste list ) (x fix>0)) list"prend une liste de permutations ( de permut-dyn par exemple), où n'importe  et la ramène à x"(let ((aux )      (aux1)      (liste-de-1 (pw::create-list (length (first liste)) x)))  (dotimes (n (length liste) aux)    (push  (setf aux1 (verifierx (pw::g- (nth n liste) n) x)) aux)    (if (equal aux1 liste-de-1 ) (return aux)))  (if (equal aux1 liste-de-1 )    (reverse aux)    (do ((indice 1 (+ indice 1)))        ((equal aux1 liste-de-1 )  (reverse aux))      (push (setf aux1 (verifierx (pw::permut-random (pw::g- aux1 indice)) x)) aux)))))        ;========================================================================;=====================teste de registre==================================== (pw::defunp teste1 (( variable numbers?) (binf numbers?) (bsup numbers?) (mod numbers?)) numbers?"test la <variable>est entre binf et bsup, et la ramène à l'interieure par +/- mod "   (let ((variable (/ variable 100)) )   (* 100 (if (> variable bsup) (- bsup (- mod  (pw::ll/mod (- variable bsup)  mod)))        (if (< variable binf) (+ binf (- mod  (pw::ll/mod (- binf variable )  mod)))  variable) )    )))(pw::defunp teste1a (( variable numbers?) (binf numbers?) (bsup numbers?) (mod numbers? (:value 12))) numbers?"test la <variable>est entre binf et bsup, et la ramène à l'interieure par +/- mod, variable est une liste, et les bornes sont fixes. <Variable> est en midicents et <binf> et <bsup> sont en midi "      (mapcar #'(lambda (l) (teste1 l binf bsup mod))  variable)    );============================================================================;=============================OPERATIONS SUR LES PULSES DES RTM!!!!!=================== (pw::defunp puls/mes ((mesures list) (pulses list)) list            "construction d'une streucture rythmiqueayant une séquence de <mesures> (subdivisions) avec <pulses> pulsespar mesure"  (mapcar #'(lambda (m p) (list m  p))            mesures (mapcar #'(lambda (x) (pw::create-list x 1)) pulses)))(pw::defunp make-measures ((mesures numbers?(:value 4)) (figure numbers? (:value 4))) list"construction d'une listes de mesures pour l'entrée <measures> de RTM"(let* ((mesures (pw::list! mesures)) (figure (pw::create-list (length mesures) 1 (pw::list! figure))))  (epw::g-oper 'list mesures figure)));ce module substitue toutes les pulsations par la liste de subdivisions;<sub>, <sub> est une liste au format de rtm!!!!!!#|;old(defun subs-pulse (liste  sub)  "ce module substitue toutes les pulsations par la liste de subdivisions<sub>, <sub> est une liste au format de rtm!!!!!!ATTENTION:<liste> est une mesure!!!"  (cond ((null liste) nil)        ((atom liste ) sub)        (t  (first liste)            (dotimes (n (length (second liste)) liste)              (if (atom (nth n (second liste)))                 (setf (nth n (second liste)) sub)                (subs-pulse (nth n (second liste))   sub)) )) ))|#;Substitutions de pulses;<sub>, <sub> est une liste au format de rtm!!!!!!(defun subs-pulse (liste  sub)  "ce module substitue toutes les pulsations par la liste de subdivisions<sub>, <sub> est une liste au format de rtm!!!!!!ATTENTION:<liste> est une mesure!!!"  (cond ((null liste) nil)        ((atom liste ) sub)        (t  (first liste)            (dotimes (n (length (second liste)) liste)              (if (atom (nth n (second liste)))                 (setf (nth n (second liste)) (list (nth n (second liste)) sub ))    ;(setf (nth n (second liste)) sub)                (subs-pulse (nth n (second liste)) sub)) )) ))(pw::defunp subst-pulses ((objet  list (:value '() :type-list (list  pw::measure-line)))                          (sub list)) list            "ce module substitue toutes les pulsations par la liste de subdivisions<sub>, <sub> est une liste au format de rtm!!!!!!ATTENTION:<objet> est la sortie d'une RTM avec une structure quelconque!!!"  (let ((mesures (cond                   ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                  ((listp objet) objet)                  (t (error "l'entrée <objet> n'a pas le bon type!!!")))))    (mapcar #'(lambda (x) (subs-pulse x sub)) mesures)));++++++++++++++++++++++++++++++++++++++++;+++++++++++++++++++++++++++++++++++++++;;;;version pour une liste de <sub>(defun g-subs-pulse (liste)  "ce module substitue toutes les pulsations par la liste de subdivisions!!!!!!ATTENTION:<liste> est une mesure!!!"  (dotimes (n (length (second liste)) liste)              (if (atom (nth n (second liste)))                (progn ()                       (setf (nth n (second liste))                              (list (nth n (second liste)) (nth (mod index (length aux1)) aux1))) ;(setf (nth n (second liste)) (nth (mod index (length aux1)) aux1))                       (incf index))                (g-subs-pulse (nth n (second liste)))) )) (defun double-list (chose)  (cond    ((null chose) '(()))   ((atom chose) (list (list chose)))   ((listp chose) (if (listp (car chose)) chose (list chose)))   (t (pw::list! chose))));(double-list 4);(double-list '(4));(double-list '((4 5)))(pw::defunp l-subst-pulses ((objet  list (:value '() :type-list (list  pw::measure-line)))                          (sub list (:value '((1 2)))) )list"ce module substitue toutes les pulsations par la liste de subdivisions<sub>, <sub> est une liste simple avec des proportions ou une liste de listes avec des subdivisions (ou des proportions)!!!!!!ATTENTION:<objet> est la sortie d'une RTM avec une structure quelconque!!!"  (let ((mesures (cond                   ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                  ((listp objet) objet)                  (t (error "l'entrée <objet> n'a pas le bon type!!!"))))      (index 0) (aux1 (double-list sub)) )  (mapcar #'(lambda (x) (g-subs-pulse x )) mesures)));++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++;..........................................................................;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++(defun subs-propo (liste1 liste2   place)  "liste1, est la liste de la mesure   liste2, est une liste pour les subdivisions. l'élém. 'n' indique qu'on va subdiviser           la n'ème pulsation en 'n' parties   sub est un pointeur qui indique quelle est la prochaine subdivision   index, doit être toujours zéro   place, est la liste des positions des pulses qui seront subdivisés"    (dotimes (n (length (second liste1)) liste1 )    (cond      ((and (atom (nth n (second liste1))) (plusp  (nth n (second liste1))))      (progn ()             (incf index)             (if (appartient? index place)               (progn ()                      (setf (nth n (second liste1))                             (list (nth n (second liste1))                                   (nth position liste2)))                      (incf position)))))     ((listp (nth n (second liste1)))      (subs-propo (nth n (second liste1)) liste2  place))     (t )))   liste1);==============================================================;=====================================================================================================(pw::defunp subst-puls ((objet  list (:value '() :type-list (list  pw::measure-line)))                             (proportions  list)                             (lecture menu (:menu-box-list (("lin" . 1) ("circ". 2))                                                          :type-list (no-connection)))                            (places list)) list            "substitution des pulses d'une liste de <mesures> par une de <proportions) et de <places>.   L'argument <lecture> determine le mode de lecture de la liste de mesures soit linèairement,   soit circulairement!!!!!   <objet> est la sortie d'une boite <rtm>!!!!!Cette fonction saute les pauses!!<proportions> est une liste de listes"  (let* ((mesures (cond                    ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                   ((listp objet) objet)                   (t (error "l'entrée <objet> n'a pas le bon type!!!"))))        (long-mesures (length mesures))        (index 0)         (position 0)        (n-mesure 0)         (aux-mesure nil)        (aux-liste nil)        (aux1 nil))    (loop      (setf aux1             (subs-propo  (nth (case lecture                                  (1  n-mesure)                                  (2  (mod n-mesure long-mesures))) mesures)                            proportions                           places))      (setf aux-mesure aux1) ;la nouvelle mesure      (push aux-mesure aux-liste)      (if (case lecture            (1  (>= n-mesure (- long-mesures 1)))            (2  (>= index (pw::g-max places))))         (return (reverse aux-liste))        (incf n-mesure))      )));=========================================================================== ;partial reverse         ::::::::::::::::::::::::::::::::::::::::;==============================================================(defun my-listp (valeur  )  (if (listp valeur) (list (first valeur ) (reverse ( second valeur )) ) valeur));(my-listp  '(7 (1 -1 1 -2)) )(defun retro-mesure (mesure)"construit le rétrograde d'une mesure"(list (first mesure) (mapcar #'my-listp (reverse (second mesure)))));==============================================================;total reverse         ::::::::::::::::::::::::::::::::::::::::;==============================================================(defun reverse-pulse-mes (liste)  "liste= mesurereverse d'une mesure-spéculaire"  (cond ((null liste) nil)        ((atom liste ) liste)        (t (let ((aux))             (list (first liste)                                (dolist (n  (second liste)  aux)                            (push (if (atom  n) n                                          ( reverse-pulse-mes n))                             aux )))))))(pw::defunp reverse-mes ((objet  list (:value '() :type-list (list  pw::measure-line)))                         (measu menu (:menu-box-list (("retro" . 1) ("norm". 2))                                                     :type-list (no-connection)))                         (pulse menu (:menu-box-list (("total" . 1) ("local". 2) ("norma". 3))                                                     :type-list (no-connection)))) numbers?            "inversion des pulses dans les mesure d'une RTM<objet> est la sortie d'une RTM avec une structure quelconque<measu> est le mode d'action sur les mesures        -retro- les mesures sont retrogradées        -norm- les mesures ne sont pas retrogradées<pulse> est le mode d'action (retrogradation) sur les pulses de chaque mesure        -total- les pulses d'une mesure sont totalement retrogradés        -local- seulement le premier niveau des pulses est retrogradé        -norma- aucune action sur les pulses"  (let ((mesures (cond                   ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                  ((listp objet) objet)                  (t (error "l'entrée <objet> n'a pas le bon type!!!")))))    (setf mesures           (case pulse            (1 (mapcar #'(lambda (x) (reverse-pulse-mes x))  mesures))            (2 (mapcar #'(lambda (x) (retro-mesure x))  mesures))            (3  mesures)))    (case measu      (1 (reverse mesures))      (2 mesures))    ));=======================================================================;::::::::::::::::PERMUTATIONS:::::::::::::::::::::::::::::::::;=======================================================================(pw::defunp permut-mes ((objet  list (:value '() :type-list (list  pw::measure-line)))                         (circ numbers? (:value 1))) list            "permutation circulaire du premier niveaux de pulses d'une mesure.<objet> est la sortie d'un module `RTM<circ> est un argument optionnel indiquant de combien de pas est la permutation circulaire       il peut être soit un nombre soit une liste (une permutation différente pour chaque mesure"  (let* ((mesures (cond                    ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                   ((listp objet) objet)                   (t (error "l'entrée <objet> n'a pas le bon type!!!"))))         (circ (pw::create-list (length mesures) 1 (pw::list! circ))))    (mapcar #'(lambda (x c) (list (first x) (pw::permut-circ (second x) c))) mesures circ)))(pw::defunp permut-struct ((objet  list (:value '() :type-list (list  pw::measure-line)))                            (circ numbers? (:value 1))) list            "permutation circulaire des mesures d'une séquence<objet> est la sortie d'un module `RTM<circ> est un argument optionnel indiquant de combien de pas est la permutation circulaire"  (let* ((mesures (cond                    ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                   ((listp objet) objet)                   (t (error "l'entrée <objet> n'a pas le bon type!!!")))))    (pw::permut-circ mesures circ)));=======================================================================;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;========================================================================(pw::defunp subs-pulse1 ((liste list) ) list            "ce module subdivise toutes les pulsations d'une mesure par <sub>"  (cond ((null liste) nil)        (t  (first liste)            (dotimes (n (length (second liste)) liste)                            (cond                ((and (atom (nth n (second liste))) (plusp (nth n (second liste))))                (setf (nth n (second liste))                       (if (< (nth (mod index (length aux1)) aux1) 0)                        (list (abs (nth n (second liste))) (list -1))                        (list (nth n (second liste)) (make-list (abs (nth (mod index (length aux1)) aux1)) :initial-element 1))))                (incf index))               ((listp (nth n (second liste))) (subs-pulse1 (nth n (second liste)) ))               (t )) )) ));:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(pw::defunp div-pul-lis ((objet  list (:value '() :type-list (list  pw::measure-line)))                         (sub numbers?))list            "ce module subdivise toutes les pulsations d'une mesure par <sub>,l'entrée mesures doit être la sortie d'une rtm!!!<sub peut être une subdivision ou une liste de subdivisions"  (let ((mesures (cond                   ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                  ((listp objet) objet)                  (t (error "l'entrée <objet> n'a pas le bon type!!!"))))        (index 0) (aux1 (pw::list! sub)))    (mapcar #'(lambda (l) (subs-pulse1 l) )  mesures)));==============================================================================(pw::defunp mesures1 ((liste list)) list"calcul de mesures dans une liste, (1 3 6 8) -> ((1 3) (3 6) (6 8))"(let ((aux))(dotimes (n (length liste))  (push (list (nth n liste)               (if (= n (- (length liste) 1) )  (nth 0 liste) (nth (1+ n) liste))) aux))(reverse aux)));==============================================================================(pw::defunp make-mesure-c ((liste list) (princip list) (secondaires list) (pat list))list  "liste= mesure la structure de la mesure devra avoir la syntaxe suivante:(mesure (proportion1 proportion2 (proportion3 (sous-prop31 sous-prop32 (sous-prop31 (pattern))))))Les indices comme <mesure>, <proportion3> et <sous-prop31> qu'indiquent en combien de pulsationsse subdivisera une liste de proportions, ou un pattern, seront pris de la librairie PRINCIP.Les proportions secondaires de la librairie SECONDAIRES.Pour indiquer qu'on veut un pattern il faut indiquer-la proportion du pattern (librairie PRINCIP)-et le pattern comme une liste d'un élément ->> (2 (0)) (2 (0))  indique le pattern d'indice zéro dans l'espace de deux pulsations!!!"  (cond ((null liste) nil)        ((atom liste ) (nth (mod liste (length princip)) princip))        (t (let ((aux))             (list   (nth (mod (first liste) (length princip)) princip)           ;mesure  ou proportion principale d'une liste de subdivisions                     (dolist (n  (second liste)  (reverse aux))        ;subdivisions                       (push                         (cond ((atom  n) (nth (mod n (length secondaires)) secondaires))       ;verifie si il existe encore des subdivisions!!                              ((and (atom  (first n)) (= 1 (length (second n))))                                (list (nth (mod (first n) (length princip)) princip)                                     (nth (mod (first (second n)) (length pat)) pat)))                              (t (make-mesure-c n princip secondaires pat)))                             aux ))))))); ici la lecture des indices est faite de façon circulaire!!!!!!!;================================================================================(pw::defunp l-make-mesure-c ((mesures list) (princip list) (secondaires list) (pat list))list  "liste= mesure la structure de la mesure devra avoir la syntaxe suivante:(mesure (proportion1 proportion2 (proportion3 (sous-prop31 sous-prop32 (sous-prop31 (pattern))))))Les indices comme <mesure>, <proportion3> et <sous-prop31> qu'indiquent en combien de pulsationsse subdivisera une liste de proportions, ou un pattern, seront pris de la librairie PRINCIP.Les proportions secondaires de la librairie SECONDAIRES.Pour indiquer qu'on veut un pattern il faut indiquer-la proportion du pattern (librairie PRINCIP)-et le pattern comme une liste d'un élément ->> (2 (0)) (2 (0))  indique le pattern d'indice zéro dans l'espace de deux pulsations!!!"(mapcar #'(lambda (m) (make-mesure-c m princip secondaires pat)) mesures));//////////////////////////////////////////////////////////////////////////////////////////;==========================================================================================;///////////////////////////////////////////////////////////////////////////////////////////(defun appartient? (element liste)"cette fonction retourne 't si <element> appartient à <liste>où nil au cas contraire" (not (null (member element liste)))) ;===========================================================================================;::::::::::::::::::::::fonction auxiliaire de subd-puls-mes3:::::::::::::::::::::::::::::::(defun subs-pulsex3 (liste1 liste2   place)  "liste1, est la liste de la mesure   liste2, est une liste pour les subdivisions. l'élém. 'n' indique qu'on va subdiviser           la n'ème pulsation en 'n' parties   sub est un pointeur qui indique quelle est la prochaine subdivision   index, doit être toujours zéro   place, est la liste des positions des pulses qui seront subdivisés"    (dotimes (n (length (second liste1)) liste1 )    (cond      ((and (atom (nth n (second liste1))) (plusp  (nth n (second liste1))))      (progn ()             (incf index)             (if (appartient? index place)               (progn ()                      (if (<=  (nth position liste2) 0)                          (setf (nth n (second liste1)) (pw::g* (nth n (second liste1)) (- 1)))                        (setf (nth n (second liste1))                               (list (nth n (second liste1))                                     (make-list (nth position liste2) :initial-element 1))))                      (incf position)))))     ((listp (nth n (second liste1)))      (subs-pulsex3 (nth n (second liste1)) liste2  place))     (t ))    )   liste1);==============================================================;=====================================================================================================(pw::defunp subd-puls-mes3 ((objet  list (:value '() :type-list (list  pw::measure-line)))                             (subdivisions  list)                             (lecture menu (:menu-box-list (("lin" . 1) ("circ". 2))                                                          :type-list (no-connection)))                            (places list)) list            "subdivision des pulses d'une liste de <mesures> par une de <subdivisions> et de <places>.   L'argument <lecture> determine le mode de lecture de la liste de mesures soit linèairement,   soit circulairement!!!!!   <objet> est la sortie d'une boite <rtm>!!!!!Cette fonction saute les pauses!!"  (let* ((mesures (cond                    ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                   ((listp objet) objet)                   (t (error "l'entrée <objet> n'a pas le bon type!!!"))))         (long-mesures (length mesures))         (index 0)          (position 0)         (n-mesure 0)          (aux-mesure nil)         (aux-liste nil)         (aux1 nil))    (loop      (setf aux1             (subs-pulsex3  (nth (case lecture                                  (1  n-mesure)                                  (2  (mod n-mesure long-mesures))) mesures)                            subdivisions                           places))      (setf aux-mesure aux1) ;la nouvelle mesure      (push aux-mesure aux-liste)      (if (case lecture            (1  (>= n-mesure (- long-mesures 1)))            (2  (>= index (pw::g-max places))))         (return (reverse aux-liste))        (incf n-mesure))      )));..............................................................................;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++(defun count-pulse (liste )  "compte le nombre de pulses dans une mesure"  (cond ((null liste) nil)        ((atom liste) 0)        (t  (dolist (n (second liste) index)              (cond                 ((and (atom n) (plusp n) (integerp n)) (incf index))               ((listp n) (count-pulse n ))               (t nil)) )) ))(pw::defunp npulses ((objet  list (:value '() :type-list (list  pw::measure-line)))) numbers?            "retourne le nombre de pulses (pas les pauses) d'une RTM"  (let ((mesures (cond                   ((typep objet 'pw::c-measure-line) (pw::rtm-dim objet 1))                  ((listp objet) objet)                  (t (error "l'entrée <objet> n'a pas le bon type!!!")))))    (apply '+ (mapcar #'(lambda (x) (let ((index 0))                                      (count-pulse x)))                      mesures))));==============================================================;============MUZAK- FUNCTIONS==================================;==============================================================;::::::::::::::::::::::::fonction auxiliaire:::::::::::::::::::(pw::defunp retirex ((liste list) (place fix>0) (n-elem fix>0))list"retirex les <n-elem> éléments de la liste <liste> à partir de la place<place>. OBS: place=1 c'est-à-dire premier élément de liste"  (let ((aux))    (dotimes (n n-elem (reverse aux))      (push (nth (mod (+ n place (- 1)) (length liste)) liste) aux))))#|(pw::defunp retire ((liste list) (place fix>0) (n-elem fix>0)) list"retire les <n-elem> éléments de la liste <liste> à partir de la place<place>. OBS: place=0 c'est-à-dire premier élément de liste"(nthcdr place (butlast liste (- (length liste) (+ place n-elem)))))|#;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(pw::defunp muzak2 ((liste list) (transp list)                     (n-pitch list) (mod fix>0 (:value  12))) list"Cyclically read through it <liste> , transposing (according to a <transp> list) to a new level after a certain number of pithes are read (<n-pitch> list)OBS:!:!:! Cette fonction permet la manipulation de séries numeriques modulo <mod>"  (let ((aux) (aux1 liste) (pointeur (butlast (pw::dx->x 1 n-pitch) 1)))    (push (retirex aux1 (first pointeur) (first n-pitch)) aux)    (dotimes (n (1- (length n-pitch)) (pw::flat (reverse aux)))      (setf aux1 (pw::g-mod (pw::g+ aux1 (nth (mod n (length transp)) transp)) mod))      (push          (retirex    aux1  (nth (1+ n) pointeur)  (nth (1+ n) n-pitch)) aux))))(pw::defunp muzak3 ((liste list) (inlock list) (places list) (n-pitches list)) list"interlock <inlock> sequence with <liste>.<places> se réfère à <liste> et <n-pitches> à <inlock>"(let ((aux)       (plik (butlast (pw::dx->x 1 n-pitches) 1))      (pins (rest (pw::dx->x 0 places)))      (indice 0))  (dotimes (n (length liste) (reverse aux))    (push  (nth n liste) aux)    (if (appartient? (1+ n) pins)      (progn ()           (setf aux  (append (reverse (retirex inlock (nth indice plik)  (nth indice n-pitches))) aux))             (incf indice))))))(pw::defunp muzak4 ((serie list) (int  list)) list"After each pitch, add another pitch in a specified intervallic relationship to it.<int> is the intervallic list "(let ((aux) (pointeur 0))  (dotimes (n (length serie))    (push (list (mod (+ (nth n serie)                        (nth pointeur int) ) 12)                (nth n serie))          aux)    (setf pointeur (mod (incf pointeur) (length int))))  (reverse (pw::flat aux))))(pw::defunp muzak5 ((serie list) (mod fix>0 (:value  12))) list" Transpose all pitches so that their intervallic structure  is related to the first pitchOBS:!:!:! Cette fonction permet la manipulation de séries numeriques modulo <mod>"(pw::g-mod (pw::g+ (first serie) (cons 0  (pw::x->dx serie))) mod))(pw::defunp muzak6 ((liste list) (n-pitch list) (mod fix>0 (:value  12))) list"After a certain number of pitches (les places impaires de <liste>),invert the others <n-pitches>OBS:!:!:! Cette fonction permet la manipulation de séries numeriques modulo <mod>"  (let ((aux)        (places (butlast (epw::dx->x 1 n-pitch) 1))        (interv (cons 0 (pw::x->dx liste))))    (dotimes (n (/ (length n-pitch) 2) aux)          (push (reverse              (append (retirex interv (nth (* 2 n) places) (nth (* 2 n) n-pitch))                     (pw::g-mod (pw::g- mod (retirex interv (nth (1+ (* 2 n)) places) (nth (1+ (* 2 n)) n-pitch))) mod)))            aux))    (pw::g-mod (rest (epw::dx->x  (first liste) (reverse (pw::flat aux)))) mod)))(pw::defunp muzak7 ((serie list)  (ref-serie list)) list"Replace every pitch, in <serie>, which is not contained in <ref-serie>with the next available pitch from <ref-serie>"(let ((indice 0) (aux) )  (dotimes (n (length serie ))    (if (appartient?  (nth n serie) ref-serie)           (push  (nth n serie) aux)      (progn ()                (push (nth indice ref-serie) aux)             (setf indice (mod (incf indice) (length ref-serie))))))  (reverse aux)));==============================================================================;===============append-mes==================================================;==============================================================================(in-package :pw)(pw::defunp append-mes ((rtm nilNum) (nth numbers?)                        &rest (resto nilNum (:value nil))) list            "construction d'une séquence rythmique à partir de mesures empruntées à d'autres rtms.L'entrée <rtm> accepte la sortie d'une <rtm><nth> accepte soit un nombre (l'index de la mesure choisie)soit une liste avec les index des mesures choisies"  (let ((rtms (when resto (first (epw::list-modulo resto 2)) ))        (nths (when resto (mapcar 'pw::list! (second (epw::list-modulo resto 2))) )))    (make-instance 'pw::C-measure-line :measures                    (apply 'pw::x-append (pw::posn-match (pw::get-slot rtm 'measures) nth)                           (if resto                          (mapcar #'(lambda (r n) (pw::posn-match (pw::get-slot r 'measures) n)) rtms nths)                          '(()))))))(defclass C-pw-duplo (pw::C-pw-extend )())(defmethod patch-value ((self C-pw-duplo) obj)  (let ((args (ask-all (pw::input-objects self) 'patch-value obj)))    (apply (pw::pw-function self) args)))(defmethod give-new-extended-title ((self C-pw-duplo))   'append-mes)(defun make-pw-duplo-arg-list (count)  (let ((arg-list))    (push  'pw::*nil-numbox-pw-type* arg-list)    (push  "rtm" arg-list)    (push  'pw::*nil-numbox-pw-type* arg-list)    (push  "nth" arg-list)    (for (i 0 1 (1- count))          (push  'pw::*nil-numbox-pw-type* arg-list)         (push  (concatenate  'string  "rtm" (format nil "~D" (1+ i))) arg-list)         (push  'pw::*nil-numbox-pw-type* arg-list)         (push  (concatenate  'string  "nth" (format nil "~D" (1+ i))) arg-list))    (nreverse arg-list)))(defmethod generate-extended-inputs ((self C-pw-duplo))   (make-pw-duplo-arg-list (+ 1 (truncate (- (length (pw::pw-controls self)) 2) 2))))(defmethod correct-extension-box ((self C-pw-duplo) new-box values)  (let ((ctrls (cdr (pw::pw-controls new-box)))        (values  (cdr (append (butlast values) (list* 0 0 (last values))))))    (mapc #'(lambda (ctrl val)               (setf (pw::value ctrl) val)              (set-dialog-item-text ctrl (format () "~D" val))) ctrls values)    (when (not (eq (car (last (pw::input-objects self))) (car (last (pw::pw-controls self)))))      (setf (nth (1- (length values)) (pw::input-objects new-box))            (nth (1- (length values)) (pw::pw-controls new-box)))      (setf (pw::open-state (nth (1- (length values)) (pw::pw-controls new-box))) t)      (setf (car (last (pw::input-objects new-box))) (car (last  (pw::input-objects self))))      (setf (pw::open-state (car (last  (pw::pw-controls new-box)))) nil))));=====================================================================================================;*********************************MENUS***********************************************;=====================================================================================================(in-package "COMMON-LISP-USER")(defparameter *combine-menu*           (pw::new-menu "combine"))(pw::add-menu-items patch-work::*pw-menu-patch* *combine-menu*);:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *basic-menu*           (pw::new-menu "basic"))(add-menu-items *combine-menu* *basic-menu*)(pw::pw-addmenu *basic-menu*  '(ser-op rot90 space));:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *muzak-menu*           (pw::new-menu "muzak"))(pw::pw-addmenu *muzak-menu* '( muzak2  muzak3 muzak4 muzak5 muzak6 muzak7))(add-menu-items *combine-menu* *muzak-menu*);:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *permut-menu*           (pw::new-menu "permut"))(pw::pw-addmenu *permut-menu* '(permutations                                 combinations                                 messiaen                                prolifer                                saw                                rand-saw                                circ-saw                                oscil-permutn                                rev-saw                                spiral                                kreus                                kreus-1))(pw::add-menu-items *permut-menu*                (pw::new-leafmenu "-" ()))(pw::pw-addmenu *permut-menu* '( permut-dyn permut-dyn1                                single-to-1 permut->to-1  single-to-x permut->to-x))(add-menu-items *combine-menu* *permut-menu*);:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *subd/mesures-menu*           (pw::new-menu "subd/mesures"))(pw::pw-addmenu *subd/mesures-menu* '(npulses                                       make-measures                                       puls/mes                                       l-make-mesure-c))(pw::add-menu-items *subd/mesures-menu*                (pw::new-leafmenu "-" ()))(pw::pw-addmenu *subd/mesures-menu* '(permut-mes                                       permut-struct                                      reverse-mes ))(pw::add-menu-items *subd/mesures-menu*                (pw::new-leafmenu "-" ()))(pw::PW-addmenu-fun *subd/mesures-menu* 'pw::append-mes 'pw::C-pw-duplo)(pw::pw-addmenu *subd/mesures-menu* '(subst-puls                                       ;l-subst-pulses                                       ;div-pul-lis                                       subd-puls-mes3 ))(add-menu-items *combine-menu* *subd/mesures-menu*);:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *analys-menu*           (pw::new-menu "analys"))(add-menu-items *combine-menu* *analys-menu* )(pw::pw-addmenu *analys-menu*   '(l-analyse));::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *conv-menu*           (pw::new-menu "conv"))(add-menu-items *combine-menu* *conv-menu*)(pw::pw-addmenu *conv-menu*  '(mc->M M->mc octave));:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::(defparameter *toolsc-menu*           (pw::new-menu "tools"))(pw::pw-addmenu *toolsc-menu* '(  geomt ratio  ratio-freq g-subs gl-subs  segment l-segment ))(add-menu-items *combine-menu* *toolsc-menu*);=====================================================================================================;*********************************MENUS***********************************************;=====================================================================================================