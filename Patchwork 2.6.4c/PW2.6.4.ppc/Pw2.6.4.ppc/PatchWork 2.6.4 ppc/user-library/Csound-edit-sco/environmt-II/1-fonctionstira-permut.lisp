(in-package "CS-E")(ccl::export '(permut-pseudo-rdm pseudo-permut-centre distor-durs))(ccl::export '(gauss tira-probab tira-proba-summax tira-nvals-sumax remove-compar remove-nth remplacer  ext-permut autr-permut repete-n-x));********* création d'un menu dans le menu User ***********************(defparameter *listxplor*  (pw::new-menu "listxplor"))(ccl:add-menu-items *csnd.edit.sco-menu* *listxplor*);*************************************************;********* pseudo-random with integer + log ******(defvar cl-user::*init-alea* (random 100.0));(setf cl-user::*init-alea* (random 100.0))(defun alea-ln (&optional indice)  (if indice  (let ((x (* 10000 (log (+ (mod (+ 2 indice cl-user::*init-alea*) 100/3) 100)))))    (- x (floor x)))  (random 1.0)))(defun rand-ln (min max &optional indice)  (let ((amb (- max min)) x)    (if (and (integerp min)(integerp max))      (setf x (round (+ (* amb (alea-ln indice)) min)))     (setf x  (+ (* amb (alea-ln indice)) min))) x));(rand-ln 1 3.0 1.1);(round .34879);(alea-ln 100);(mapcar #'alea-ln (pw::arithm-ser 0 1 500));************************************************************(defunp gauss ((mu fix/float (:value 0.0))                (sigma fix/float (:value 1.0))               &optional (indice  list )) list"Generates a number with a gaussian distribution of an average <mu> and a bandwidth <sigma>, indice pour un aleatoire déterminé par un indice"(if indice   (if (atom indice)(gauss-ln mu sigma indice)      (let ((L ()))        (dolist (ind indice (reverse L))          (push (gauss-ln mu sigma ind) L))))    (let ((s 0))      (for (n 1 1 12)  (setf s (+ s (random 1.0))))      (+ (* (- s 6) sigma) mu))))(defunp gauss-ln ((mu fix/float (:value 0.0))                   (sigma fix/float (:value 1.0))                 (indice fix/float (:value 1))) float"Generates a number with a gaussian distribution of an average <mu> and a bandwidth <sigma>"(let ((s 0))  (for (n 1 1 12)  (setf s (+ s (alea-ln (+ n indice)))))           (+ (* (- s 6) sigma) mu)))(pw::defunp g-sum ((liste numbers?)) numbers? "somme de liste"  ;défini aussi ! dans utils  : lp-temp  (let ((result 0))    (if (atom liste) liste        (dolist (elt liste result)          (setf result (+ result (g-sum elt))))))); (g-sum '(1 2 (3 4 (5))));******************************* old *************************(pw::defunp remove-compar ((test list) (liste list)) list"fonction qui repère les duplicats dans la liste test et enlève les éléments durang correspondant dans la liste liste"  (let (( L1 ())        (L2 ()))    (do ((n 0 (1+ n)))        ((eq n (length test)) (reverse L2))      (if (member (nth n test) L1)()          (progn (push (nth n test) L1)          (push (nth n liste) L2))))));(remove-compar '(0 0 28 28) '(1200 1201 1202 1203))(pw::defunp remove-nth ((n fix/float) (liste list)) list"enlève le nième élément de la liste 'liste"  (let ((L liste)        (L2 ()))    (do ((i 0 (1+ i)))        ((eq i  (length liste))(reverse L2))      (if (eq i n)(pop L)          (push (pop L)L2)))));(remove-nth 0 '(1 2 3 4 5))(pw::defunp tira-probab ((Lprobs list) (Lvals list) (n fix/float))  list"donne n valeurs tirées dans la liste Lvals selon des proba (non normaliséesdonnées dans vecttprob (avec répétitions)"  (let* ((Lresult ())         (Lvals  (if (> (length Lvals)(length Lprobs))  ;--------> chged lp 10/3/94 --------                   (butlast  Lvals (- (length Lvals)(length Lprobs))) Lvals))         (Lprob  (butlast  Lprobs (- (length Lprobs)(length Lvals))))         (Lprob (if (zerop (g-sum Lprob)) Lprob                     (pw::g* Lprob (/ 1 (g-sum Lprob))))))    (do ((i 0 (1+ i)))        ((eq i n) Lresult)      (let ((u (random 1.0))     ; valeur tirée aléatoirement entre 0 et 1            (sumj 0)                                     ; successivement pa puis pa + pb puis etc...            (j 0))                                       ; successivement 1, 2  etc.. jusqu'à longueur de Lvals        (while (< sumj u) (progn (setf sumj (+ (nth j Lprob) sumj))                                  (setf j (1+ j))))        (setf Lresult (if (atom (nth (- j 1) Lvals))(cons (nth (- j 1) Lvals) Lresult)                          (append (nth (- j 1) Lvals) Lresult))))))); (tira-probab '(0.1 0.9 5 1) '(a b c d e) 5); attention rescal-last  diminue  le nombre d'éléments de liste(defun rescal-last (liste longueur)"modifie la dernière valeur de liste pour que la somme de cette liste soit égale à longueur"  (let ((L (reverse liste )) n)    (cond ((eq (g-sum L) longueur)           liste)          ((= (length liste) 1)          (cons longueur ()))        (t         (progn (pop L)               (setf n (- longueur (g-sum L)))               (push (+ (pop L) n) L)(reverse  L)))))); (rescal-last '(1 2 3 4 5) 20) ->(1 2 3 4 10); ajoute ou enleve à la liste "liste" une valeur entière pour que la somme; de cette liste soit égale à longueur(defun complete (liste longueur)  "modifie la dernière valeur de liste pour que la somme de cette liste soit égale à longueur"  (let ((L (reverse liste)) n)    (cond ((eq (g-sum L) longueur)           liste)          ((= (length liste) 1)          (cons longueur ()))        (t         (progn (setf n (- longueur (g-sum (cdr L))))               (setf L (reverse (cons n (cdr L )))))))));(complete '(7 7 7) 14);(g-sum '(7 7 2 7 7 7 7 2 7));(g-sum (rescal-last '(7 7 7) 14));(2875 1750 667 1750 286 2875 1750 286 62);(rescal-last  '(2875 1750 667 1750 286 2875 1750 286 62) 1024);(g-sum '(2875 62 1750 1750 286 667 1750 286 286 62 226))(pw::defunp tira-proba-summax ((Lprobs list) (Lvals list) (summax fix/float))  list"donne n valeurs (g-sum n vals = summax tirées dans la liste Lvals selon des proba (non normaliséesdonnées dans vecttprob (avec répétitions)"   (let((Lresult ())       (Lprob   (pw::g*  Lprobs (/ 1 (g-sum Lprobs))))       (sum 0))    (do ((i 0 (1+ i)))        ((> sum summax) (rescal-last (reverse Lresult) summax))      (let ((u (random 1.0))     ; valeur tirée aléatoirement entre 0 et 1            (sumj 0)                                     ; successivement pa puis pa + pb puis etc...            (j 0))                                       ; successivement 1, 2  etc.. jusqu'à longueur de Lvals        (while (< sumj u) (progn (setf sumj (+ (nth j Lprob) sumj))                                  (setf j (1+ j))))        (progn (setf Lresult (cons (nth (- j 1) Lvals) Lresult))               (setf sum (+ sum (nth (- j 1) Lvals))))))));(tira-proba-summax '(50 50) '(2 7) 10);***********fonctions permut+ou-random***************(defun remplacer (L n1 n2)  (let* ((m1  (max (min n1 n2) 0))         (m2  (min (max n1 n2) (1- (length L))))         (elt1 (nth m1 L))         (elt2 (nth m2 L))         (copy-L L))    (setf (nth m1 copy-L) elt2          (nth m2 copy-L) elt1)    copy-L));(remplacer '(1 2)  1 2);(remplacer '(1 2) 5 4);******************** only these must be kept ***************************************************(defun pseudo-permut (Liste n)  (let ((L (copy-list Liste)))    (dotimes (alpha n L)      (setf L (remplacer L (round (random (length Liste)))                            (round (random (length Liste))))))))#|(pw::defunp permut-pseudo-rdm ((liste list)(ntirage pfix)(taux fix/float))        list "donne n tirages de la liste initiale avec des permutations plus ou moins nombreusesselon la valeur de 'taux (compris entre 0 et 1: 0 = pas de permutations, 1 = permutation aléatoires"  (let ((L ())        (taux-mod (round (* taux (length liste)))))    (dotimes (alpha ntirage (if (= 1 ntirage)                              (pw::flat (reverse L))                              (reverse L)))      (push (pseudo-permut liste taux-mod) L))));(pseudo-permut '(1 2 3 4 5 6 7 8 9 10 11 12 13 14) 2);(permut-pseudo-rdm '(1 2 3 4 5 6 7 8 9 ) 4 0)|#(pw::defunp permut-pseudo-rdm ((liste list)(ntirage pfix)(taux fix/float))            list "donne n tirages de la liste initiale avec des permutations plus ou moins nombreusesselon la valeur de 'taux (compris entre 0 et 1: 0 = pas de permutations, 1 = permutation aléatoires"  (let ((L ())        (taux-mod (round (* taux (length liste)))))    (repeat ntirage       (push (pseudo-permut liste taux-mod) L))    (if (= 1 ntirage)      (pw::flat (reverse L))      (reverse L))));(cs-e::permut-pseudo-rdm '(1 2 3 4 5 6 7 8 9 ) 4 .5)(pw::defunp pseudo-permut-centre ((Liste list)                              (nbre-permut fix/float (:value 1))                              (centre fix/float (:value 1))                             (ecart fix/float (:value 2))) list"fonction qui permute les valeurs autour d'une valeur centrale (centre) avec une dispersion de taille = ecart avec une intensité = nbre-permut"  (let ((L (copy-list Liste)))    (dotimes (alpha nbre-permut L)      (setf L (remplacer L (+ centre (random ecart))                            (+ centre (- (random ecart) 1)))))));(pseudo-permut-centre '(1 2 3 4 5 6 7 8 9)  3 2  3);************************fonction de distortion des durées**************(defun distor-dur (date datea dateb scaler &optional indice)  (gauss-bi date datea dateb scaler indice));(distor-dur 50 20 70 20 1)(defun gauss-bi (date datea dateb scaler &optional indice)"distribution gaussienne dissymétrique"  (let (x y a b c)    (setf x (min datea dateb)          y (max datea dateb)          a (min (- date x)(abs (gauss 0 (* (- date x) (/ scaler 100)) indice)))          b (min (- y date)(abs (gauss 0 (* (- y date) (/ scaler 100)) indice)))          c (rand-ln 0 1 indice))    (if (zerop c)(- date a)(+ date b))));(rand-ln 0 1 3);(gauss-bi 0 -5 50 100)(defun int-or-float (n)  (if (integerp n) n (float n)));(int-or-float 5);(int-or-float 3/2);(distor-dur 50 20 80 10)(pw::defunp distor-durs ((durs list) (scaler fix/float) &optional (indice list)) list"change les valeurs de durs (dont la somme reste inchangée avec un intensitédépendant de scaler (entre 0 et 100)"  (let (dates (L ()))    (setf dates (pw::dx->x 0 durs))    (dotimes (n (- (length durs) 1) (pw::x->dx (append (cons 0 (reverse L))(list (car (reverse dates))))))      (push (distor-dur (nth (+ n 1) dates)                        (nth n dates)                        (nth (+ n 2) dates)                        scaler (if indice (+ n indice)))            L))));(distor-durs '(5 5 5 4 4 6) 100 1)-->(8 4 3 4 7 3);(g-sum '(5 5 5 4 4 6));****************************************************************************************************;************************************ old ******************************************(pw::defunp repete-n-x ((xini-LdeL list (:value '((a 2))))) list "fournit une liste formée de ni répétition de xi"(let ((result ()))  (dotimes (n (length xini-LdeL)(pw::flat (reverse result)))    (push (make-list (cadr (nth n xini-LdeL)) :initial-element (car (nth n xini-LdeL))) result))));(repete-n-x '((a 2) (b 5)  (d 1)));******************************************************************(pw::defunp test-perso-1 ((listtest list)(listvals list)) list "commentaires o liu se dfn  moh ser m jh"(let ((result ()))  (dolist (elt listvals (reverse (pw::flat result)))    (push (test-perso-aux elt listtest) result))))(defun test-perso-aux (val listtest)  (let ((L ()))    (dolist (elt listtest (reverse (test-si-abst val L listtest)))      (if (= (car elt) val)        (push (cadr elt) L)        ()))))(defun test-si-abst (val L listtest)  (if L L (test-si-abst-aux val listtest)))(defun test-si-abst-aux (val listtest)  (let ((val-proche (caar listtest)))    (dotimes (n (length listtest) (test-perso-aux  val-proche listtest))      (if (< (abs (- val val-proche))(abs (- val (car (nth n listtest)))))        ()(setf val-proche (car (nth n listtest)))))));(test-si-abst-aux 15 '((1 1) (5 2)(11 3)(15 4)));(test-perso-aux 58 '((10 1)(60 2)(70 3)));(test-perso-1  '((10 1)(20 2)(30 3)(40 4)(60 6)) '(16 19 30 294095120 10));******************* FONCTIONS SPECIALES PERMUTATIONS ************************(pw::defunp ext-permut ((liste list))  list  ; permute les valeurs: 1ere derniere, seconde, avant dernière etc... " permute les valeurs: 1ere derniere, seconde, avant dernière etc..."  (let ((L ())        (L1 liste))    (while L1      (and (setf L (cons (pop L1) L))           (setf L1 (reverse L1)))) (reverse L)));(ext-permut '(1 2 3 4 5 6 7)) (defun remove-vals (liste vals)  (let ((L liste))    (dotimes (n (length vals) L)      (setf L (remove (nth n vals) L)))))(defun autres-permut (liste vals)  (let ((L (make-list (length liste) :initial-element 'coin)))    (dotimes (n (length vals) L)      (if (search (list (nth n vals)) liste)        (setf (nth (search (list (nth n vals)) liste) L)              (nth n vals))        ()))))(pw::defunp autr-permut ((liste list) (vals list)) list"permute dans 'liste toutes les valetrs sauf celles de 'vals"  (let* ((L liste)         (Lmoins (pw::permut-random (remove-vals L vals)))         (Lcoin (autres-permut liste vals)))    (dotimes (n (length Lcoin) Lcoin)      (if (eq 'coin (nth n Lcoin))        (setf (nth n Lcoin) (pop Lmoins))              ()))));(autr-permut '(1 2 3 4 5 6) '(1 2 3));fonction multiplicatrice(defun rescal-last2 (liste longueur)"écrire ici les commentaires<---"  (let ((L (reverse liste )) n)    (cond  ((= (length liste) 1)          (cons longueur ()))        (t         (progn (pop L)               (setf n (- longueur (g-sum L)))               (push (+ (pop L) n) L)(reverse  L))))));(rescal-last2 '(1 2 3 4 5 6 ) 0) -> (1 2 3 4 -10)(defun rescal-lasts (liste sum)(let ((liste2 (rescal-last2 liste sum)))  (if (> 0 (car (last liste2))) (append (rescal-lasts (butlast liste) sum) '(0))      liste2)));(rescal-lasts '(5 2 3 4 5 6 ) 1)(defun find-dist-min (val Lvals)"donne la valeur de la liste la plus proche de val"  (let ((valx (first Lvals))(d (abs (- val (first Lvals)))))    (dotimes (n (length Lvals) valx)      (if (<= (abs (- (nth n Lvals) val)) d)        (setf d (abs (- (nth n Lvals) val))              valx (nth n Lvals))        ()))));(find-dist-min 10000 '(50 100 200))    (pw::defunp tira-nvals-sumax ((Lprobs list) (Lvals list) (summax fix/float)(n fix/float)) list"donne nvals valeurs tirées dans la liste Lvals selon des proba (non normalisées)données dans Lprobs (avec répétitions) avec un rescaling pour que la somme vale dur"  (let ((L1 ())        (L2 ()))       (setf L1 (tira-probab Lprobs Lvals n))        (rescal-lasts (append                       (tira-nvals-sumax-aux Lprobs Lvals summax L1 L2)                      '(0)) summax)))    (defun tira-nvals-sumax-aux (Lprobs Lvals dur L1 L2)(let (a1)  (if (endp L1) (reverse L2)(progn (setf L1 (if (zerop (g-sum L1))                '(0)                  (pw::g* L1 (/ dur (g-sum L1)))))       (setf a1 (find-dist-min (pop L1) Lvals))       (push a1 L2)     (tira-nvals-sumax-aux Lprobs Lvals (- dur a1) L1 L2)))));  test : (tira-nvals-sumax '(1/3 1/3 1/3) '(10 100 200) 500 4);*******************  M   E   N   U   S  ************************;(PW::PW-addmenu-fun  *listxplor* 'tira-probab);(PW::PW-addmenu-fun  *listxplor* 'tira-proba-summax);(PW::PW-addmenu-fun  *listxplor* 'tira-nvals-sumax);(add-menu-items *listxplor* (new-leafmenu "-" ()));(pw::pw-addmenu-fun *listxplor* 'remove-compar);(pw::pw-addmenu-fun *listxplor* 'remove-nth);(pw::pw-addmenu-fun *listxplor* 'remplacer)(pw::pw-addmenu-fun *listxplor* 'permut-pseudo-rdm)(pw::pw-addmenu-fun *listxplor* 'pseudo-permut-centre);(pw::pw-addmenu-fun *listxplor* 'ext-permut);(pw::pw-addmenu-fun *listxplor* 'autr-permut);(pw::pw-addmenu-fun *listxplor* 'repete-n-x)(pw::pw-addmenu-fun *listxplor* 'distor-durs)