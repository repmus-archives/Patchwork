(in-package "CS-E")(ccl::export '(make-obj-snd               Edit-sco-obj               compar-create))(defclass son-obj ()  ((ins :initform () :initarg :ins :accessor ins)   (dates :initform () :initarg :dates :accessor dates)   (durs :initform () :initarg :durs :accessor durs)   (amps :initform () :initarg :amps :accessor amps)   (freqs :initform () :initarg :freqs :accessor freqs)   (tables :initform () :initarg :tables :accessor tables)   (durée :initform () :initarg :durée :accessor durée)   (partiels :initform () :initarg :partiels :accessor partiels)));******************************** OLD ***********************************(defun make-obj-son-aux (L-durs &rest tinit)  (let ((t0 (car (if tinit tinit '(0)))))    (make-instance 'son-obj       :dates (mapcar #'(lambda(elt) (pw::dx->x t0 (butlast elt)))  L-durs)      :durs L-durs      :durée (g-sum (car L-durs))      :partiels (pw::arithm-ser 1 1 (length L-durs)))));(pw::dx->x 0 (butlast '(1 2)))(pw::defunp make-obj-son ((Lins list (:value '(1)))                      (Ldurs list (:value '((1 2))))                      (Lamps list (:value '(100)))                      (Lfreqs list (:value '(440)))                      &rest (Ltn list (:value '(99)))) list        "fabrique un objet prêt à être utilisé par edit-sco pour donner le score(liste des lignes <instrument>)"  (let* ((self (make-obj-son-aux Ldurs))         (Np (length (dates self))))    (setf (ins self) (compar-create (dates self) Lins))    (setf (amps self) (compar-create-amps (dates self) Lamps Np))    (setf (freqs self) (compar-create (dates self) Lfreqs))    (dotimes (n (length Ltn))      (push (compar-create (dates self) (nth n Ltn)) (tables self)))    (setf (tables self)(reverse (tables self)))    self));(g-sum 1)(pw::defunp make-obj-snd2 ((Lins list (:value '(1)))                      (Ldats list (:value '(1)))                      (Ldurs list (:value '(1)))                      (Lamps list (:value '(1)))                      (Lfreqs list (:value '(440)))                      &rest (Ltn list (:value '(99)))) list        "fabrique un objet prêt à être utilisé par edit-sco pour donner le score         (liste des lignes <instrument>)"  (let ((self (make-instance 'son-obj                 :freqs Lfreqs)))    (setf (dates self) (compar-create Lfreqs Ldats))    (setf (durs self) (compar-create Lfreqs Ldurs))    (setf (partiels self) (if (atom (car Lfreqs)) '(1)                              (pw::arithm-ser 1 1 (length Lfreqs))))    (setf (ins self) (compar-create Lfreqs Lins))    (setf (amps self) (compar-create Lfreqs Lamps))     (setf (freqs self) (compar-create Lfreqs Lfreqs))    (dotimes (n (length Ltn))      (push (compar-create Lfreqs (nth n Ltn)) (tables self)))    (setf (tables self)(reverse (tables self)))    self));(defun compar-create (Model Data)"reproduit la structure de Model avec les donnees Datala liste modele doit etre tres ordonnee, fonction  applicableseulement a des structures de scores csound"  (if (atom Data)(setf Data (list Data)))  (let ((l ()))    (if (atom (car Model))              ; Model = liste (notes separees)      (cond ((endp (cdr Data))             (push (pw::create-list (length Model) (car Data)) L))            (t             (setf L Data)))      (if (= 1 (length Model))          ; Model = liste dans une liste (1 accord)        (cond ((listp (car Data))               (setf L Data))              ((= 1 (length Data))               (push (pw::create-list (length (car Model)) (car Data)) L))              (t               (push Data L)))        (do ((n 0 (1+ n)))             ; Model = listes dans une liste (plusieurs accords)             ((eq n (length Model)) (reverse L))          (cond ((endp (cdr Data))                 (push (pw::create-list (length (nth n Model)) (car Data)) L))                ((atom (nth n Data))                 (push (pw::create-list (length (nth n Model)) (nth n Data)) L))                (t                 (push (nth n Data) L))))))));(compar-create '(1 2) 4);(compar-create '(1 2) '(4));(compar-create '(1 2) '(4 5));(compar-create '(1 2) '(4 5 6));(compar-create '((1 2)(2 3)(4 5)) 1);(compar-create '((1 2)(2 3)(4 5)) '((5 6)));(compar-create '((1 2)(2 3)(4 5)) '((5 6 7)));(compar-create '((1 2)(2 3)(4 5)) '(5 6 7));(compar-create '((1 2 3 4)) '((5 6 7 8)));******************************** NEW ***********************************(pw::defunp make-obj-snd ((Lins list (:value '(1)))                      (Ldats list (:value '(1)))                      (Ldurs list (:value '(1)))                      (Lp4 list (:value '(1)))                      (Lp5 list (:value '(440)))                      &rest (Ltn list (:value '(99)))) list        "fabrique un objet prêt à être utilisé par edit-sco pour donner le score         (liste des lignes <instrument>)"(if (atom (car Lp5))  (setf Lp5 (mapcar #'list Lp5)))  (let ((self (make-instance 'son-obj                 :freqs Lp5)))    (setf (dates self) (c-c Lp5 Ldats))    (setf (durs self) (c-c Lp5 Ldurs))    (setf (partiels self) (if (atom (car Lp5)) '(1)                              (pw::arithm-ser 1 1 (length Lp5))))    (setf (ins self) (c-c Lp5 Lins))    (setf (amps self) (c-c Lp5 Lp4))     (setf (freqs self) (c-c Lp5 Lp5))    (dotimes (n (length Ltn))      (push (c-c Lp5 (nth n Ltn)) (tables self)))    (setf (tables self)(reverse (tables self)))    self));permet de rentrer dans un slot soit une liste de liste (ex. : tables); soit une liste de valeur (ex. : freqs) soit une valeur (ex. : ins)(defun c-c (Model Data)"reproduit la structure de Model avec les donnees Datala liste modele doit etre tres ordonnee, fonction  applicableseulement a des structures de scores csound"  (if (atom Data)(setf Data (list Data)))  (if (null Model)()      (if (atom  Model)         (car (pw::flat Data))        (cons (c-c (car Model)(car Data))              (c-c (cdr Model)(if (cdr Data)(cdr Data)                                  (list (car Data))))))));(c-c '(1 2) 4)     ->(4 4);(c-c '(1 2) '(4))  ->(4 4);(c-c '() '(4))     ->nil;(c-c '((1 2)) '(4 5))   ->((4 4));(c-c '((1 2)) '((4 5))) ->((4 5));(c-c '(1 2) '(4 5))->(4 5);(c-c '(1 2) '(4 5 6));(c-c '((1 2)(2 3)(4 5)) 1);(c-c '((1 2)(2 3)(4 5)) '((5 6)));(c-c '((1 2)(2 3)(4 5)) '((5 6)(7 8)(9 10)));(c-c '((1 2)(2 3)(4 5)) '((5 6 7)));(c-c '((1 2)(2 3)(4 5)) '(5 6 7))(defun decibels->lin (x)  (expt 10 (/ x 20)))(defun lin->decibels (x)  (* 20 (log x 10)));(lin->decibels 32000);(decibels->lin 90);****************** OLD **************************(defun compar-create-amps (Ldates Lamps npart)"Lamps = amplitudes entre 0 et 100"(let ((l ()))  (do ((n 0 (1+ n)))      ((eq n (length Ldates)) (reverse L))    (cond ((endp (cdr Lamps))           (push (pw::create-list (length (nth n Ldates))                               (* 250 (/ (car Lamps) (float npart)))) L))          ((atom (nth n Lamps))           (push (pw::create-list (length (nth n Ldates))                              (* 250 (/ (nth n Lamps) (float npart)))) L))          (t           (push (reverse (butlast (reverse                                     (mapcar #'(lambda (elt) (* 250 (/ elt (float npart)))) (nth n Lamps)))                                   (- (length (nth n Lamps))(length (nth n Ldates)))))                 L))))));(compar-create-amps '((1 2 )(4 5 6)(7 8 9 10)) '(20) 48);(decibels->lin -10);(/ 31622 48.0);(lin->decibels 658);************** conversion ************(defmethod partiel->sco ((self son-obj) no)  (let ((L ())        (Lins (nth no (ins self)))        (Ldates (mapcar #'(lambda(elt) elt) (nth no (dates  self))))        (Ldurs (mapcar #'(lambda(elt) elt) (nth no (durs self))))        (Lamps (nth no (amps self)))        (Lfreqs (nth no (freqs self)))        (Lt (mapcar #'(lambda(elt) (nth no elt)) (tables self)))) (dotimes (n (length Ldates)  (remove nil (reverse L)))   (push (if  Lt           (pw::flat (list 'i (nth n Lins)                           (nth n Ldates)                           (nth n Ldurs)                           (nth n Lamps)                           (nth n Lfreqs)                           (mapcar  #'(lambda(elt) (nth n elt)) Lt)))           (pw::flat (list 'i (nth n Lins)                           (nth n Ldates)                           (nth n Ldurs)                           (nth n Lamps)                           (nth n Lfreqs)                           )))               L))));(partiel->sco glou 1)(defmethod ins->sco ((self son-obj))  (let ((L ()))    (dolist (n (partiels self) (reverse L))      (push (partiel->sco self (- n 1)) L))))(defun insts->sco (sons)  (if (null sons)()  (if (atom sons) (ins->sco sons)      (append (ins->sco (car sons))(insts->sco (cdr sons))))));(ins->sco pouet);************** ecriture ************************(defun printscoseq (seq dest)    (if (atom seq)(print-seq-aux seq dest)    (while seq      (print-seq-aux (pop seq) dest))))(defun print-comment (seq dest coin)"imprime un commentaire sur la liste seq, vers dest, si coinest nil. Rend t"  (cond ((not (listp  seq)) nil)        ((endp seq) nil)        ((and (equal 'i (car seq))(null coin))         (progn (format dest "\;")                (dotimes (n (1- (length seq)) t)                  (format dest "p~D~a" (1+ n) #\tab))                (format dest "~%")                t))        ((equal 'i (car seq))         t)        (t nil)));(print-comment '(i 1 0 1 2 45687 4 5) t nil);(print-comment "" t nil)(defun print-seq-aux (seq dest)  (cond ((equal 'i seq)         (format dest "~D" seq))        ((integerp seq)         (format dest "~D~a" seq #\tab))        ((numberp seq)         (format dest "~4,4f~a"(float seq) #\tab))        (t          (format dest "~D"seq))));;;(format t "~a~4,4f" #\tab 1)(pw::defunp Edit-sco-obj  ((filename list ( :value  '() :type-list '(string)))                      (son list)  &rest (donnees numbers?)) nil"Cette boite rassemble les tables et notes pour les imprimer dans un fichier <file.sco>"  (when son    (setf donnees             (append (pw::flat-once donnees)(pw::flat-once (insts->sco son))))    (unless filename      (setf filename (CCL:choose-new-file-dialog :directory (directoryp *lastcsdfile*)                                                 :button-string "file"                                                  :prompt "Save csound")))    (when  filename      (setf *lastcsdfile* filename)      (format t "écriture du fichier ~a en cours" *lastcsdfile*)      (with-open-file  (fd filename                           :direction :output :if-exists :rename-and-delete                            :if-does-not-exist :create)        (let ((glou nil))        (dotimes (n (length donnees))          (setf glou (print-comment (nth n donnees) fd glou))          (printscoseq  (nth n donnees) fd)          (format fd "~%"))        (format fd "e")" - - - - > mission accomplie chef !"))      )));pour compatibilité - old version -, doit disparaitre prochainement(pw::defunp Edit-sco-lp ((filename list ( :value  '() :type-list '(string)))                      (son list)  &rest (donnees numbers?)) nil " "(Edit-sco-obj filename son donnees))(pw::pw-addmenu *utilcsnd* '(make-obj-snd                         Edit-sco-obj))