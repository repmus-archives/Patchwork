(in-package "PW");************ A T T E N T I O N ****************;    LES TEMPS SONT EXPRIMÉS EN SECONDES;    LES DISTANCES SONT EXPRIMÉES EN METRES;    LA VITESSE DU SON EST *Vson*;    LA SALLE FAIT 200m SUR 200m;    LES HP SONT AU QUATRE COINS (OU AUX DEUX COINS DEVANT;    L'OBSERVATEUR EST AU CENTRE;tester encore la répartition des hp, pbs notamment quand source en (0 0) !(defvar *Vson* ())(setf *Vson* 300) ;m/s(defun distance->0 (x y)"distance entre un point et l'origine"  (expt  (+ (expt x 2)(expt y 2)) (/ 1 2)))(defun Ldist->0 (Lx Ly)"distance entre une liste de points et l'origine "(let ((L ()))  (dotimes (n (length Lx) (reverse L))    (push (pas-trop-pres (distance->0 (nth n Lx)(nth n Ly))) L))))(defun distance (x-y a-b)"'distance entre deux points"(expt  (+ (expt (- (car x-y)(car a-b)) 2)          (expt (- (second x-y)(second a-b))                 2)) (/ 1 2)));(distance '(0 0)'(1 1))(defun Ldistances (Lxs-ys Lx-y)"permet de calculer la distance d'une liste de points Lxs-ys à un point Lx-y"(let ((L ()))  (dolist (x-y Lxs-ys (reverse L))    (push (pas-trop-pres (distance x-y Lx-y))          L))));(Ldistances '((0 0)(10 10)(10 20)) '(10 10))(defun pas-trop-pres (LorA)"donne la liste LorA en remplaçant les valeurs <1 par des 1"  (if (atom LorA)    (non-si<1 LorA)    (let ((L ()))      (dolist (x LorA (reverse L))        ( push (non-si<1 x) L)))))(defun non-si<1 (x)  (if (< x 1) 1 x));amplitude dans H2 par rapport à angle avec O H1            (defun f-de-teta (teta tetamax coefft)  "amplitude dans HP2 par rapport à angle avec O HP1 avec recouvrement ou non  si coefft = 1 pas de recouvrement si coefft = 0 alors f-de-teta = 0.5  si coefft entre 0 et 1 élargissement  tetamax indique l'angle entre H1 0 H2 "  (let ((teta-radians (* (/ teta 180) pi))        (tetamax-radians (* (/ tetamax 180) pi)))    (+ (/ (- 1 coefft) 2)(* coefft                            (/ (1+ (tan (- teta-radians (/ tetamax-radians 2)))) 2)))));(f-de-teta -10 90 1);calcul de l'angle en degré(defun x-y->teta (x y)"coordonnées cartésiennes -> coordonnées polaires"  (if (zerop x)     (if (< y 0) 225 45)      (mod        (- (if (< x 0)         (+ 180 (* (/ (atan (/ y x))(* 2 pi)) 360))         (* (/ (atan (/ y x))(* 2 pi)) 360)) 45)       360)      )); (x-y->teta 0 -90)(defun amps-4hp (teta coefft)"donner teta en degrés, coefft entre 0 et 1"  (let* ((teta2 (mod teta 90))         (H1 (- 1 (f-de-teta teta2 90 coefft)))         (H2 (f-de-teta teta2 90 coefft))         (H0 (f-de-teta 0 90 coefft))          L)    (cond      ((< teta 90)      (setf L (list (- h1 (* h1 h0))(- h2 (* h2 h0)) (* h2 h0)(* h1 h0))))     ((< teta 180)      (setf L (list (* h1 h0)(- h1 (* h1 h0))(- h2 (* h2 h0)) (* h2 h0))))     ((< teta 270)       (setf L (list  (* h2 h0)(* h1 h0)(- h1 (* h1 h0))(- h2 (* h2 h0)))))     (t      (setf L (list (- h2 (* h2 h0)) (* h2 h0)(* h1 h0)(- h1 (* h1 h0))))))     L))  ;(amps-4hp 5 0.5)-->(somme '(0.5323311808457399 0.21766881915426003 0.07255627305142001 0.17744372694858));(amps-4hp 90 1)(defun Lx-ys->LHis (Lx-y coefft)  "donne les amplitudes dans les HP d'un point selon ses coordonnées xyLx-y est une liste double : liste de x et liste de y, resultat entre 0 et 1"  (let ((Lxs (car Lx-y))(Lys (cadr Lx-y))(Lamps ()) x y)    (dotimes (n (length Lxs)(reverse Lamps))      (progn        (setf x (pop Lxs) y (pop Lys))        (push (amps-4hp (x-y->teta x y) coefft) Lamps)))));(pw::g-round (lx-ys->lhis '((-1 0 1)(1 1 1)) 1) 2);(pw::g-round (lx-ys->lhis '((-1 0 1)(1 1 1)) 0.5) 2)(defun x-y->ampH (Lx-y coefft)"donne les amplitudes dans les HP d'un point selon ses coordonnées xyLx-y est une liste double : liste de x et liste de y, resultat entre 0 et 100"  (let ((L (Lx-ys->LHis Lx-y coefft)) (L2 ()))    (dotimes (n (length L) (reverse L2))      (push (mapcar #'(lambda(elt) (round (* 100 elt)))(nth n L)) L2))));(pw::g-round (x-y->ampH '((-1 0 1)(1 1 1)) 1) 2);(pw::g-round (x-y->ampH '((-1 0 1)(1 1 1)) 0.5) 2);(x-y->amph '((0 20 35 0 -30 10 20 -5 -60 -90 100) (0 30 -5 -90 -80 5 60 90 100 30 -80)) 1);(x-y->amph '((-1)(1)) 1);(x-y->amph '((0)(-90)) 1);--------------------------------------------------------------------(defun sym (x1 x2)"donne x3, symetrique de x1 par rapport à x2"  (- (* 2 x2) x1));(sym 2 0);(sym 1 3);--------------------------------------******************************(defun doppler-discret (x1 y1 x2 y2 x3 y3)  "donne la vitesse relative au sujet (<0 si éloignement)   en supposant que les points M1 M2 et M3 sont séparés chacun d'une seconde"  (let ((ro (/ (+ (* x2 (- x2 (/ (- x1 x3) 2)))                  (* y2 (- y2 (/ (- y1 y3) 2)))) (+ (expt x2 2)(expt y2 2)))))    (* (- 1 ro) (expt (+ (expt x2 2)(expt y2 2)) 0.5))))(defun doppler-dsc-gal (x1 y1 t1 x2 y2 t2 x3 y3 t3)  "donne la vitesse relative au sujet (<0 si éloignement)   en supposant que les points M1 M2 et M3 sont joués aux temps t1, t2, t3"  (if (= t2 t1)(setf t1 (sym t3 t2) x1 (sym x3 x2) y1 (sym y3 y2))())  (if (= t2 t3)(setf t3 (sym t1 t2) x3 (sym x1 x2) y3 (sym y1 y2))())  (if (< (abs x1) 1)(setf x1 1)())(if (< (abs x2) 1)(setf x2 1)())(if (< (abs x3) 1)(setf x3 1)())  (if (< (abs y1) 1)(setf y1 1)())(if (< (abs y2) 1)(setf y2 1)())(if (< (abs y3) 1)(setf y3 1)())   (let ((ro (/ (+ (* x2 (- x2 (/ (- (/ x1 (- t2 t1)) (/ x3 (- t3 t2))) 2)))                  (* y2 (- y2 (/ (- (/ y1 (- t2 t1)) (/ y3 (- t3 t2))) 2))))  (+ (expt x2 2)(expt y2 2)))))  (* (- 1 ro) (expt  (+ (expt  x2 2) (expt y2 2)) 0.5))));(doppler-discret 1 1 0 1 -1 1) ->0;(doppler-discret 1 0 2 0 3 0) ->-1;(doppler-discret 3 0 2 0 1 0) ->1;(doppler-discret 0 -90 -30 -80 10 5);(doppler-dsc-gal 1 1 0 0 1 1 -1 1 2) ->0;(doppler-dsc-gal 1 0 0 2 0 10 3 0 20) ->-1;(doppler-dsc-gal 3 0 0 2 0 1 1 0 2) ->1;(doppler-dsc-gal 0 -90 0 -30 -80 1 10 5 2);(doppler-dsc-gal 0 -90 0 -30 -80 1 10 5 2)(defun dopl-disct (L)  (let* ((Lx (car L))         (Ly (cadr L))         (L1x (butlast (cons (car Lx) Lx)))         (L3x (reverse (butlast (cons (car (last Lx)) (reverse Lx)))))         (L1y (butlast (cons (car Ly) Ly)))         (L3y (reverse (butlast (cons (car (last Ly)) (reverse Ly)))))         (Lresult ()))    (dotimes (n (length Lx) (reverse Lresult))      (push (doppler-discret (pop L1x)(pop L1y)(pop Lx)(pop Ly)(pop L3x)(pop L3y)) Lresult))))(defun dopl-dsc-gal (L)  (let* ((Lx (first L))         (Ly (second L))         (Lt (third L))         (L1x (butlast (cons (car Lx) Lx)))         (L3x (reverse (butlast (cons (car (last Lx)) (reverse Lx)))))         (L1y (butlast (cons (car Ly) Ly)))         (L3y (reverse (butlast (cons (car (last Ly)) (reverse Ly)))))         (L1t (butlast (cons (car Lt) Lt)))         (L3t (reverse (butlast (cons (car (last Lt)) (reverse Lt)))))         (Lresult ()))    (dotimes (n (length Lx) (reverse Lresult))       (push (doppler-dsc-gal (pop L1x)(pop L1y)(pop L1t)                             (pop Lx)(pop Ly)(pop Lt)                             (pop L3x)(pop L3y)(pop L3t)) Lresult))));(dopl-disct '((0 -30 10) (-90 -80 5)));(dopl-dsc-gal '((0 -30 10) (-90 -80 5)(0 1 2)))(defun coef-dopp-gal (L)"facteur multiplicatif à appliquer aux fréquences"  (let ((Lv (dopl-dsc-gal L)))    (mapcar #'(lambda(elt) (/ *Vson* (- *Vson* elt))) Lv)));(coef-dopp-gal '((0 -30 10) (-90 -80 5)(0 1 2)));------------------- filtrage par rapport à éloignement ******************************(defun fil-dist (freq dist)  "fonction tres provisoire, donne un coefficientmultiplicateur à appliquer à l'amplitude de chaque formant en fonction (ou partiel) de sa fréquence"  (fde-f-x freq dist));(f(f,x) = 1 si x = 0) pour tout f ;(f(f,x) = 1 si f = 0) pour tout x;(f(f,x) = (expt x y) si f fixé (y négatif));(f(f,x) = (expt f z) si x fixé (z négatif))(defun fde-f-x (f x)  (expt (1+ (* (abs (- f 200)) x)) -.1));(fde-f-x 2000 10);(expt 0 -1)