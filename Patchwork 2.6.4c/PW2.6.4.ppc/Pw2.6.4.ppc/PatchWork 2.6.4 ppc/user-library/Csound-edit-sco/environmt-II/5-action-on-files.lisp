(in-package "CS-E")(ccl::export '());lp 8/9/93;fonctions pour accéder à un fichier (score csound par exemple);et y effectuer des modifications ponctuelles ou répétées(defun string-to-number (string)"transforme un string de chiffres en un nombre correspondant"(let ((result ()))  (dolist (char (coerce string 'list) (base10 (reverse result)))  (push  (- (char-code   char) 48) result))));(string-to-number "1234.789")-->1234.789(defun base10 (liste)"transforme une liste de codes de char en un nombre; att:à une soustraction -48 près  "  (let ((number 0)(signe 1)(exptmx (expt-max  liste)))    (if (= -3 (car liste))      (setf signe -1)())    (setf liste (remove -3 (remove -2 liste)))    (dotimes (n (length liste) (if (ratiop (* signe number))                                 (float (* signe number))                                 (* signe number)))      (setf number (+ number (* (expt 10 (- exptmx n)) (nth n liste)))))));(base10 '(1 2 3 4 -2 7 8 9))-->1234.789;(base10 '(1))--> 1.0(defun expt-max (liste)  (let (n1 n2 n3)    (dotimes (x (length liste)(- n2 n1))      (cond       ((and (not n1)(< -1 (nth x liste) 10))        (setf n1 x n2 x))       ((= -2 (nth x liste))        (setf n3 0))       ((and n1 (not n3) (< -1 (nth x liste) 10))        (setf n2 x))       (t         ())))));(float (base10 '(-3 1 0 3 -2 0 5 0 9)));(expt-max '(-5 1 0 3 -2 0 5 0 9))  ;*********************************************************     (defun codes->strg (liste-de-codes)  (coerce    (let ((Lint()))     (dolist (n liste-de-codes (reverse Lint))       (push (character (+ n 48)) Lint)))   'string));(codes->strg '(57 40 50))               --->"iab";(char-code   (car (coerce "(" 'list)))  --->105;(character (+ -8 48))                  --->#\i(defun regroupe-elts (result)  (let ((L ()) (Ltemp ()))    (dotimes (x (length result) (remove nil (reverse L)))      (cond       ((= (nth x result) -16)        (push (reverse Ltemp) L)        (setf Ltemp ()))       ((= (nth x result) -39)        (push (reverse Ltemp) L)        (setf Ltemp ()))       ((= (nth x result) -8)        ())       ((= (nth x result) -7)        (push (reverse Ltemp) L)        (setf Ltemp ()))       ((= x (1- (length result)))        (push (nth x result) Ltemp)        (push (reverse Ltemp) L))       ((< (nth x result) 10)        (push (nth x result) Ltemp))       (t        (push (nth x result) Ltemp))))));(regroupe-elts '(57 49 50 -16 -16 1 -16 -3 0 -2 0 0 0 0 -16 1 0 0 -16));   --->((57 49 50) (1) (-3 0 -2 0 0 0 0) (1 0 0))(defun numberp-liste (liste)"donne t si la liste ne comporte que des valeurs entre -3 et 9, nil sinon"  (eval  (cons 'and (mapcar #'(lambda(elt) (and (not (= -1 elt))(< -4 elt 10))) liste))));(numberp-liste '(-3 0 -2 0 0 0 0)) --->t;*********************************************************(defun base10andtext (result)  (let ((Li (regroupe-elts  result))(Lf ()))    (dolist (x Li (reverse Lf))      (push (if (numberp-liste x)(base10 x)                (codes->strg x)) Lf))));(base10andtext '(57 49 50 -16 -16 1 -16 0 -16)) --->("iab" 1 0);(base10andtext '(-8 1 -16 2 -2 1 2 4 -16 3 -16 4 -7)) --->("(1" 2.124 3.0 "4)");*********************************************************(defun string-to-liste (string)  "transforme un string de chiffres en un nombre correspondant"  (let ((result ()))    (dolist (char (coerce string 'list)(base10andtext (reverse result)))      (push  (- (char-code char) 48) result))));(string-to-liste "iab (1 -0.0000 1.0000    0.0000 70.3000   0 ");(string-to-liste "iab 1 -0.0000 1.0000    0.0000 70.3000 0");(format t "~a "(string-to-liste "iabz e e 1 -0.01 1.0 0.0 70.3000 0 -5 -7.02"));   --->(iab 1.0 -0.01 1.0 0.0 70.3 0.0 -5.0 -7.02);*********************************************************(defun lire-line-n (nom-fichier n)  (with-open-file (test nom-fichier                        :direction :input                        :if-does-not-exist nil)    (let (ligne)      (if (zerop n)        ()        (repeat (1- n)           (read-line test nil nil)))        (setf ligne (read-line test nil nil)) ligne)));(string-to-liste (lire-line-n "lugus-languages:Desktop Folder:Temp.lisp" 0 ));(string-to-liste (lire-line-n (choose-file-dialog) 1 ));(string-to-liste (lire-line-n "taranis-1Giga:Desktop Folder:a" 1 ));(lire-line-n "taranis-1Giga:Desktop Folder:a" 1);(lire-line-n "granul.orc" 1);(coerce   (lire-line-n "essai.sco" 2) 'list);(load (concatenate 'string *dir* (string "granul.orc")))(defun write-ds-file (LdeL-de-texte nom-fichier)  (with-open-file (stream nom-fichier                          :direction :output                          :if-exists :append                          :if-does-not-exist :create)        (cond ((endp LdeL-de-texte)           ())          ((atom LdeL-de-texte)           (format stream "~a" LdeL-de-texte))          (t           (dolist (mot LdeL-de-texte)             (format stream "~A~A" mot #\tab))))          (format stream "~%")) LdeL-de-texte)(defun write-ds-file2 (LdeL-de-texte nom-fichier)  (with-open-file (stream nom-fichier                          :direction :output                          :if-exists :append                          :if-does-not-exist :create)        (format stream "~a~%" LdeL-de-texte)));(write-ds-file '(1 iyt (1 4 2 4 5 1)(a z e r) 1 2)(choose-new-file-dialog));(write-ds-file '(1 iyt (1 4 2 4 5 1)(a z e r) 1 2)(choose-new-file-dialog));*************************************************************************(defun scal-spec (occurences liste scaler)"multiplie les elts de liste - indiquées par les indices donnés par la liste occurence - par scaler"  (dolist (n occurences liste)    (setf (nth n liste)(* scaler (nth n liste)))));(scal-spec '(1 2) '(10 20 30 40 50) 0.5);*************************************************************************(defun rescal (nom-fich1 nom-fich2 ligne1 ligneend scaler occurences)  "multiplie les elts de nom-fich1 - dont les indices de colonnes sont indiqués par la liste occurence - par scaler"  (if (zerop ligne1) () (resum-file nom-fich1 nom-fich2 0 (1- ligne1)))  (setf ligne1 (1+ ligne1) ligneend (1+ ligneend))  (dotimes (x (- (1+ ligneend) ligne1) )    (write-ds-file      (scal-spec scaler occurences                (string-to-liste                  (lire-line-n nom-fich1 (+ x ligne1))) )     nom-fich2))  (if (equal ligneend 'EOF)() (resum-file nom-fich1 nom-fich2 (1+ ligneend) 'EOF)));*************************************************************************(defun resum-file (nom-fich1 nom-fich2 ligne1 ligneend)"pour la réécriture d'une partie d'un fichier,de la ligne ligne1 à la ligne ligneend"  (let ((ligne t))    (setf ligne1 (1+ ligne1) ligneend (1+ ligneend))    (dotimes (x   (- (1+ ligneend) ligne1))      (write-ds-file         (if ligne          (string-to-liste           (setf ligne (lire-line-n nom-fich1 (+ x ligne1))                )))       nom-fich2)) ligne));(resum-file (choose-file-dialog) "ahahah" 0 0 );(resum-file "taranis-1Giga:Desktop Folder:ahah" "taranis-1Giga:Desktop Folder:ahbh" 0 2 );************************ chge colonne ****************************(defunp chge-col ((nf list ( :value  '() :type-list '(string)))                   (nf-new list ( :value  '() :type-list '(string)))                   (op list ( :value  '*))                  (scal fix/float)(col numbers?)(lig-i numbers?)(lig-f numbers?))        list        "apply op with scal on every number of the colonne col between lig-i and lig-f"  (unless nf (setf nf (CCL:choose-file-dialog :button-string "score file")))  (unless nf-new (setf nf-new (CCL:choose-new-file-dialog  :button-string "new file")))  (let ((wnf (concatenate 'string (mac-namestring nf) "temp"))(c 0))    (copy-file nf wnf :if-exists :rename-and-delete)    (resum-file wnf nf-new 0 (1- lig-i))    (while (and (<= c (- lig-f lig-i))                (write-ds-file (chge-val op scal col (string-to-liste (lire-line-n wnf (+ 1 c lig-i)))) nf-new))      (incf c))    (while (resum-file wnf nf-new (+ c lig-i)(+ c lig-i))      (incf c)) (delete-file wnf)));(chge-col "taranis-1Giga:Desktop Folder:a" "taranis-1Giga:Desktop Folder:ab" '* 3 3 2 15)(defun chge-val (op scal col L)(if (and L (numberp (nth col L)))    (setf (nth col L)(funcall op scal (nth col L)))) L);(chge-val '+ 2 3 '(1 2 3 4 5 ));***********************************************************************(ccl::export '(chge-col))(pw::pw-addmenu *utilcsnd* '(chge-col))