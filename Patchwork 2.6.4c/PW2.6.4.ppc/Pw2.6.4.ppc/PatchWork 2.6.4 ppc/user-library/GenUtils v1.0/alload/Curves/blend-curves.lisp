;==================================; NEW FILE : POLYNOMIAL FUNCTIONS;==================================;===================== ; DEFINE ENVIRONMENT                    ;=====================   (in-package :genutils);===================== ; 2 POINT FUNCTION                    ;===================== #| BEZIER SEGMENT FUNCTION ( HPST 7/2/95 IRCAM )   reference: John Vince '3D Computer Animation' ( Addison-Wesley 19?).   This is a 2 point interpolation function, with 1 or 2 control points,   so as to pull or push interpolation curve to/from source/target:      f(t,N) = (1-t)^N*x[0] + t^N*x[1] + Nt(1-t)^N-1*p[0] + Nt^N-1(1-t)*p[1]   where t       =   0 <= time <= 1   (normalized time)         N       =   degree related to number of control points                     1 cp equals N = 2, 2 cp equals N = 3         x[0]    =   returns source value         x[1]    =   returns target value         p[0]    =   returns first control value         p[1]    =   returns second control value      The function is implemented so that it takes both x,y coordinates into account,   where the nature of the 2 polynomial degrees can be described as follows:   Quadratic : with 1 control point as a pull/push interpolation or envelope.   Cubic     : with 2 control points to determine the slope at segment start/end.   the idea of usage:   should be relativly easy to use for making 'bended' trajectories,    between 2 data-points only (called a segment). It does not work well   for splicing more segments because it cannot trace abrubt changes smoothly.   Because control points can be given as x,y coordinates directly,    the calculation of controls as binding points should be straigthforward (as offsets).   Also note that control points are not restricted to the x,y range of the origines.   The formula exist in an elaborate and general version called: BLEND-CURVE (see later)|#;========================; EVALUATE BEZIER DATA;========================(DEFUN EVAL-BEZIER (time xlist ylist plist) (let* (  (x1   (first xlist))           ;no safety check employed          (x2   (second xlist))          ;since its a 2 point interpolation                        (y1   (first ylist))                    (y2   (second ylist))                               (hi (unit time x1 x2 0 1))     ;normalized time                     (lo (- 1 hi))                  ;and reversed          (px1  (first plist))           ;first control point          (py1  (second plist))          (px2  (third plist))           ;second control point          (py2  (fourth plist))          (off  (fifth plist))           ;exponetial offset           (elo1 (expt lo (+ off 1)))          (ehi1 (expt hi (+ off 1)))          (elo2 (expt lo (+ off 2)))          (ehi2 (expt hi (+ off 2))) )            (list       (+ (* elo2 x1)                    ;evalute X in canonical form          (* ehi2 x2)          (* (+ off 2) hi elo1 px1)           (* (+ off 2) lo ehi1 px2))       (+ (* elo2 y1)                    ;evalute Y in canonical form          (* ehi2 y2)          (* (+ off 2) hi elo1 py1)           (* (+ off 2) lo ehi1 py2)) )));(eval-bezier 1 '(1 3 1000000) '(1 1 1) '(2 1 0 0 0));===========================; GENERAL SEGMENT FUNCTION;===========================#| POLYNOMIAL SEGMENT FUNCTIONS	( written by HPST 30/5/94 Montmartre )   reference: John Vince '3D Computer Animation' ( Addison-Wesley 19?).   This is a  method to interpolate adjacent points by a 'hill/valley' curve.    The model is based on a fouth-degree (quartic) polynomial defined as:   f(t,d,N) = (1-t)^d*x[i] + t^d*x[i+1] + ·[0,N]t(1-t)^N*A + (N+N/2)t^N(1-t)*B      where t       =   0 <= time <= 1  (normalized time)         d       =   polynomial degree (can be any float >= 0)         N       =   polynomial degree - 1 (must be abs int [0,3])         x[i]    =   return y source value at x[lo]         x[i+1]  =   return y target value at x[hi]         A       =   source slope control value         B       =   target slope control value         ·[0,N]  =   sum integers from 0 to N        (N+N/2)  =   shift degrees in pairs   As a function it can smoothly change from one polynomial degree to another,   by correctly adjusting d & N, while A & B tells the slope at segment start/end.   the nature of the different polynomial degrees can be described as follows:   Unique    : usually a lin|exp interpolation disregarding A & B,   Quadratic : a 'squared' interpolation using A only to tell accelration,   Cubic     : a 'cubed' interpolation using both A & B to peak|flatten curve,   Quartic   : a curve using both A & B to jag extremes in quasi-periods.   the idea of usage:   to make 'bended' trajectories between abitrary data-points, note necessarily   aiming at being 'smooth' throughout the segments. Though d,N,A,B migth be   difficult to estimate, N,A,B can optionally be left to default calculation:          N = abs-integer(log10(1/d)), A = y1, B = y2.     Also note the mirroring-effect, when A & B are specified to be negative.   It is not known wether there exists a straigth forward normalisation, so   meanwhile use the SHIFT-ALL just to 'transpose' curve to positive domain.   Could one finally imagine using it for envelopes,rhythms,impulses,filters...?|#;======================; SPECIAL FUNCTIONS;======================(DEFUN SAFE-ID (if-id list else-val)  "returns item if id is inside list-range, otherwise else-val."  (if (<= 0 if-id (1- (length list)))      (nth if-id list) else-val))(DEFUN SUMMA (n)  "returns sum of all integers from 0 to n (inclusive)."  (if (= 0 n)    0 (+ n (summa (1- n)))))(DEFUN SUMUP (n)  "returns n shifted by divisor2 : 0,1,2,3 = 0,1,3,4 etc."  (+ n (truncate (/ n 2))))(DEFUN NONZERO (n)  "return 1.0E-100 if zero else n"  (if (= 0 n) 1.0E-100 (abs n)));==============================; GENERAL EVAL OF ALL DEGREES;==============================(DEFUN EVAL-BLEND (time xlist ylist plist)  (let* ( (time (search-high-list time xlist))  ;make time be in range          (id   (search-low-list time xlist))   ;find id of closest x                (lo   (safe-id     id  xlist 0))      ;find id of lower x          (hi   (safe-id (1+ id) xlist 1))      ;and of higher x          (x2   (unit time lo hi 0 1))          ;normalize x          (x1   (- 1 x2))                       ;and invert it          (y1   (safe-id     id  ylist 0))      ;find corresponding lower y          (y2   (safe-id (1+ id) ylist 1))      ;and higher y          (s1   (safe-id 2 plist y1))           ;find slope or use default          (s2   (safe-id 3 plist y2))           ;ditto          (deg0 (/ 1 (nonzero (nth 0 plist))))  ;find d,N and range check them          (degr (1+ (abs (round (log deg0 10)))))          (deg1 (clipto (1- (safe-id 1 plist degr)) 0 1.0E+100))          (sum1 (summa deg1))                   ;find sum-factor of slope1          (sum2 (sumup deg1)) )                 ;and of slope2       (+ (* (expt x1 deg0) y1)                 ;evalute in canonical form          (* (expt x2 deg0) y2)          (* (expt x1 deg1) s1 sum1)          (* (expt x2 deg1) s2 sum2)) ));===================; MATRIX FUNCTIONS;===================#| PARAMETRIC POLYNOMIAL SEGMENT FUNCTIONS ( hpst Montmatre 30/5/94 )   This method interpolate adjacent points by a 'smooth' curve.    The model uses parameter matrices of third-degree (cubic) polynomial:   f(t) = [t^3 t^2 t 1] [-T 2-T T-2   T] [y0]                          [2T 3-T 3-2T -T] [y1]                          [-T   0   T   0] [y2]                          [ 0   T   0   0] [y3]      where t       =   0 <= time <= 1  (normalized time)         T       =   tension parameter (eg. catmull = 0.5)         x[i]    =   succesive y's indexed by x[i,N-1]    Setting up the middle matrix means to parametresize the polynomial,    so as to facilitate the estimation of correct/good slope-parameters.   the nature of the different matrices can be described as follows:   hermite : different kind of 'bended' slopes between two values,   parabol : more lively version that has a 'peak/valley' tendency,   bspline : an 'approximating' spline tracing a path towards the points,   catmull : an 'interpolating' spline tracing a smooth curve through the points.   the idea of usage:   to easily make a certain 'profile' specified with a minimum of data,   aiming at different degrees of 'smoothness' / 'jaggedness'. Through   putting in identical x-values, one can obtain abrupt changes. Also   if y-list is 2 points longer than x-list, these will be taken as constant   slopes, used for every segment, whereas equal-length xy-lists, will use    a succesive sliding set of 4 y-values to determine slope-character.   In general hermite is best with constant slopes, while the others are free.   It seems entirely well fitted for making envelopes...?|#;=================; SETUP MATRICES;=================(defvar test    '( ( 1 -1  0  0)                    (-2  2 -1  0)                    (-1 -1  0 -1)                    ( 0 -1 -1 -1) ) )(defvar hermite '( ( 2 -2  1  1)                    (-3  3 -2 -1)                    ( 0  0  1  0)                    ( 1  0  0  0) ) )(defvar parabol '( (-1  1 -1  1)                    ( 2 -2  1 -1)                    (-1  0  1  0)                    ( 0  1  0  0) ) )(defvar catmull '( (-0.5  1.5 -1.5  0.5)                    ( 1.0 -2.5  2.0 -0.5)                    (-0.5  0.0  0.5  0.0)                    ( 0.0  1.0  0.0  0.0) ) )(defvar bspline '( (-1/6  3/6 -3/6  1/6)                    ( 3/6 -6/6  3/6  0/6)                    (-3/6  0/6  3/6  0/6)                    ( 1/6  4/6  1/6  0/6) ) )(DEFUN SETUP-MATRIX (matrix &optional (factor 1))  "small catalog of matrices index by matrix"     (case matrix           (hermite (g* gu::hermite factor))           (parabol (g* gu::parabol factor))            (bspline (g* gu::bspline factor))            (catmull (g* gu::catmull factor))            (tension (tensions factor))) );===================; MATRIX FUNCTIONS;===================;COULD TENSION BE GENERALIZED?????(DEFUN TENSIONS (ten)   "little functions to play with tension parameter (catmull)"  (list   (list (- ten) (- 2 ten) (- ten 2) ten)   (list (* 2 ten) (- ten 3) (- 3 (* 2 ten)) (- ten))   (list (- ten) 0 ten 0)   (list  0 1 0 0)))(DEFUN DEGREE (x deg)  "make x-matrix, where rank = ^factor"  (loop for i from deg downto 0 by 1        collect (expt x i) into it        finally (return it)))(DEFUN MAT* (l1 l2)  "matrix multiplication, returns the sum-of-the-products"  (apply '+ (mapcar '* l1 l2)))(DEFUN MAT3 (xmat ymat pmat)  "multipliply 3 matrices, returns the sum-of-the-products"  (mat* (mapcar 'mat* (pw::cirlist xmat) pmat) ymat));===================; EVALUATE HERMITE ;===================(DEFUN EVAL-HERMITE (time xlist ylist pmat)    (let ( (lo (first xlist))         (hi (second xlist)) )  (mat3 ylist (degree (unit time lo hi 0 1) 3) pmat) ));===================; EVALUATE MATRIX  ;===================#| OLD VERSION(DEFUN EVAL-MATRIX (time xlist ylist pmat)  (let* ( (time (search-high-list time xlist))    ;make time be in range          (id   (search-low-list  time xlist))    ;find id of closest x                (lo   (safe-id     id  xlist 0))        ;find id of lower x          (hi   (safe-id (1+ id) xlist 1))        ;and of higher x           (xmat (degree (unit time lo hi 0 1) 3)) ;make deg-matrix of norm-x                    (ymat (if (= 2 (- (length ylist) (length xlist))) ;setup apropriate matrix                 (list                                      ;for constant slopes :                 (safe-id      id  ylist 0)                 ;take 2 first & 2 last                 (safe-id (+ 1 id) ylist 1)                 (safe-id (- (length ylist) 3) ylist 0)                       (safe-id (- (length ylist) 2) ylist 1))                      (list                                      ;for variable slopes :                 (safe-id      id  ylist 0)                 ;take 4 succesive                 (safe-id (+ 1 id) ylist 1)                 (safe-id (+ 2 id) ylist 0)                 (safe-id (+ 3 id) ylist 1))  )))                  (if (= 2 (- (length ylist) (length xlist))) ;choose calc-ordeer                 (mat3 xmat ymat pmat)                       ;constant slope                    (mat3 ymat xmat pmat)))                     ;variable matrices)|#(DEFUN EVAL-MATRIX (time xlist ylist pmat)  (let* ( (time (search-high-list time xlist))    ;make time be in range          (id   (search-low-list  time xlist))    ;find id of closest x                (lo   (safe-id     id  xlist 0))        ;find id of lower x          (hi   (safe-id (1+ id) xlist 1))        ;and of higher x           (xmat (degree (unit time lo hi 0 1) 3)) ;make deg-matrix of norm-x                    (ymat (list                                      ;for variable slopes :                 (safe-id      id  ylist 0)                 ;take 4 succesive                 (safe-id (+ 1 id) ylist 1)                 (safe-id (+ 2 id) ylist 0)                 (safe-id (+ 3 id) ylist 1)) ))                  (mat3 ymat xmat pmat))                     ;variable matrices);======================; END FILE ;======================