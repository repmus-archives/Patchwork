;========================; NEW FILE : CURVE CLASS              (HPST 16/6/94 Montmatre);======================== #| This file takes the basic LISP-definitions of the formulars   for "CUBIC" spline, the "BLEND" functions & the "MATRIX" polynomials   and turn them into a single class. It serves as a common base for   making "modules" in PW, as well as "rules" in CHANT, the idea sligthly   being that "functions" (something that can be call bu FUNCALL)   fits well with PW (here the class is hidden in the function), and   "classes" well with CHANT (something that can be scheduled & invocated).   The class is meant to be a hidden intermediate step meant in the   further application process. The three formulars are globally unified   in two aspects, namely their initilisation and evaluation. It seems, for the    sake of clarity in use,conception,code-reading,etc. that only the evalution   aspect really ask for melting, while inits proberbly are better left open.   Though a global init-curve method exist, it is recommended to call make-   words separately, leaving the "unfiltering" to the eval-curve method. |#;========================; DEFINE ENVIRONMENT;========================  (in-package :genutils);========================; DEFINE CURVE CLASS;========================(DEFCLASS C-CURVE-FUNCTION (c-gen) ; use C-GEN as inheritage class  ((eval-type :initform nil :initarg :eval-type :accessor eval-type)   (x-points  :initform nil :initarg :x-points  :accessor x-points)   (y-points  :initform nil :initarg :y-points  :accessor y-points)   (p-points  :initform nil :initarg :p-points  :accessor p-points)) );========================; CURVE METHODS;========================(DEFMETHOD GIVE-X-POINTS ((self c-curve-function))  "give back x-points without extended guard-points"  (let ((xlist (butlast (x-points self))))    (if (equal (eval-type self) 'eval-blend)      (rest xlist) xlist)))(DEFMETHOD GIVE-Y-POINTS ((self c-curve-function))  "give back y-points without extended guard-points"  (let ((ylist (butlast (y-points self))))    (if (not (equal (eval-type self) 'eval-spline))      (rest ylist) ylist)))(DEFMETHOD GIVE-P-POINTS ((self c-curve-function))  "give back p-points as is"  (if (not (equal (eval-type self) 'eval-spline))      (p-points self)))(DEFMETHOD EVAL-CURVE ((self c-curve-function) time)   "evaluate data-points accoding to <eval-type> of instance"  (funcall (eval-type self) time (x-points self) (y-points self) (p-points self))) (DEFMETHOD TRANS-CURVE ((self c-curve-function) times) ;OUT?  "sample curve as given by vals in <times>"  (mapcar #'eval-curve (cirlist self) times)) (DEFMETHOD SAMPLE-CURVE ((self c-curve-function) grid) ;OUT?  "sample whole curve from min(x) to max(x) evenly by <grid>"  (let* ( (xlist (give-x-points self))          (beg   (apply 'min xlist))          (end   (apply 'max xlist))          (step  (/ (- end beg) (abs grid))) )  (loop  for i from beg to end by step         collect (eval-curve self i))) )(DEFMETHOD INIT-CURVE  (c-key xlist ylist &optional plist)  "global init according to symbol <c-key>"  (let ((c-key (princ-to-string c-key)))        (cond          ((string= c-key "bezier")  (make-bezier-class  xlist ylist plist))          ((string= c-key "hermite") (make-hermite-class xlist ylist plist))          ((string= c-key "spline")  (make-spline-class  xlist ylist))          ((string= c-key "blend")   (make-blend-class   xlist ylist plist))          ((string= c-key "matrix")  (make-matrix-class  xlist ylist plist)))));=================; SAMPLE CURVES;=================(DEFMETHOD SAMPLE-TIME ((self c-curve-function) times)   "sample CURVE at points specified by a list (any depth) of <times>"  (epw::deep-mapcar/1 #'(lambda(time) (eval-curve self time)) times))(DEFMETHOD SAMPLE-GRID ((self c-curve-function) grids)  "sample whole BPF from x-min to x-max evenly by <grid>,   if <grid> is zero then sample at gcd-interval of x-points."  (sample-time self              (epw::deep-mapcar/1 #'(lambda(grid)                     (let* ( (xpts  (give-x-points self))                             (end   (apply 'max xpts))                             (begin (apply 'min xpts))                             (step  (if (= 0 grid)                                      (apply 'gcd (g-round xpts))                                      (/ (- end begin) (abs grid)))) )                       (arithm-ser begin step end))) grids)) );========================; HELP FUNCTIONS;========================#| COMMENATRY:   since each of the formulars ask for slighly different treatment,   esp. concening safe evaluation outside xy-limits (for which is   used an "EXTENDED GUARD POINT"), each one got their own make-word.|#(DEFUN MAKE-BEZIER-CLASS (xlist ylist plist)    "macro to setup bezier-instance with extended guard-points"  (if   (noteq ylist xlist);IF-UNEQUAL-ERROR        (error "matrix xy-lists of uneven length or contend!")  (let* ( (func  'eval-bezier) ;ELSE-INIT-FUNCTION          (xlist (list (first xlist)                        (second xlist)                        1.0E+100))          (ylist (list (first ylist)                        (second ylist)                        (second ylist)))          (poffs (if (= 4 (length plist)) 1 0)) ;record of number of control points          (plist (list (if (= 4 (length plist))               ;cpx1 < cpx2 check                           (min (first plist) (third plist))                             (first plist))                       (second plist)                         ;cpy1                       (if (= 4 (length plist))                           (max (first plist) (third plist))  ;cpx2 < cpx1 check                           0)                       (if (fourth plist) (fourth plist) 0)   ;cpy2                       poffs)))           (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))));(make-bezier-class '(1 3) '(1 1) '(2 2))(DEFUN MAKE-HERMITE-CLASS (xlist ylist plist)    "macro to setup matrix-instance with extended guard-points"  (if   (noteq ylist xlist);IF-UNEQUAL-ERROR        (error "matrix xy-lists of uneven length or contend!")  (let* ( (func  'eval-hermite) ;ELSE-INIT-FUNCTION          (ylist (list (first ylist)                        (second ylist)                        (first plist)                        (second plist)                        (second plist)))          (xlist (list (first xlist)                        (second xlist)                        1.0E+100))          (plist (list? gu::hermite)) ) ; OPEN FOR EXTERNAL MATRIX INPUT ????          (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))));(make-hermite-class '(0 1) '(1 2) '(1 1))(DEFUN MAKE-SPLINE-CLASS (xlist ylist)  "macro to setup spline-instance with extended guard-points"  (if   (noteq xlist ylist)    ;IF-UNEQUAL-ERROR        (error "spline xy-lists of uneven length or contend!")  (let* ( (func  'eval-spline) ;ELSE-INIT-FUNCTION          (xlist (append xlist '(1.0E+100)))          (ylist (append ylist '(0)))           (plist (append (solve-spline xlist ylist) '(0))) )          (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))));(make-spline-class '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1))(DEFUN MAKE-BLEND-CLASS (xlist ylist plist)  "macro to setup blend-instance with extended guard-points"  (if   (or (noteq xlist ylist) (= (length (list? plist)) 0)) ;IF-UNEQUAL-ERROR        (error "blend xy-lists of uneven length or contend!")  (let* ( (func  'eval-blend) ;ELSE-INIT-FUNCTION          (xlist (append '(-1) xlist '(1.0E+100)))          (ylist (append (list (first ylist)) ylist (last ylist)))          (plist (list? plist)) )          (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))));(make-blend-class '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1) '(0 2))#| OLD VERSION(DEFUN MAKE-MATRIX-CLASS (xlist ylist matrix)    "macro to setup matrix-instance with extended guard-points"  (if   (noteq xlist ylist)    ;IF-UNEQUAL-ERROR        (error "matrix xy-lists of uneven length or contend!")  (let* ( (func  'eval-matrix) ;ELSE-INIT-FUNCTION          (ylist (if (= 2 (- (length ylist) (length xlist)))                 (append ylist (last ylist))                 (append (list (first ylist)) ylist (last ylist))))          (xlist (append xlist '(1.0E+100)))           (plist (get-matrix matrix)) ) ; OPEN FOR EXTERNAL MATRIX INPUT          (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))))|#(DEFUN MAKE-MATRIX-CLASS (xlist ylist matrix)    "macro to setup matrix-instance with extended guard-points"  (if   (noteq ylist xlist);IF-UNEQUAL-ERROR        (error "matrix xy-lists of uneven length or contend!")  (let* ( (func  'eval-matrix) ;ELSE-INIT-FUNCTION          (ylist (append (list (first ylist)) ylist (last ylist)))          (xlist (append xlist '(1.0E+100)))           (plist (list? matrix)) ) ; OPEN FOR EXTERNAL MATRIX INPUT          (make-instance 'C-CURVE-FUNCTION :eval-type func :x-points xlist :y-points ylist :p-points plist))));(make-matrix-class '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1) 'hermite);=======================; EXAMPLES of MAIN USE;=======================;(setf cube1 (init-curve 'spline '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1)));(setf cube2 (init-curve 'blend  '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1) '(1 1)));(setf cube3 (init-curve 'matrix '(0 1 3 4 7 10) '(2 1.5 1.25 1.2 1.125 1.1) 4));(sample-curve cube3 60);=================; TOOLS FOR CHANT;=================#| just sketches(DEFUN COPY-CURVE  (curve dur)  "return a copy of <curve> with x-points scaled to <dur>"  (init-curve (case (eval-type curve)                    (eval-spline 'spline)                    (eval-blend  'blend)                    (eval-matrix 'matrix))              (zoom (x-points curve) 0 dur)              (y-points curve)              (p-points curve)))(DEFUN BPF->SPLINE  (bpf dur)  "return a spline of <bpf> with x-points scaled to <dur>"  (init-curve 'spline (zoom (x-points bpf) 0 dur) (y-points bpf)))(DEFUN BPF->CURVE  (bpf dur)  "return a spline of <bpf(s)> with x-points scaled to <dur>"  (if (listp bpf)    (mapcar #'bpf->spline bpf (cirlist dur))    (bpf->spline bpf dur)))|#;===============; END FILE;===============