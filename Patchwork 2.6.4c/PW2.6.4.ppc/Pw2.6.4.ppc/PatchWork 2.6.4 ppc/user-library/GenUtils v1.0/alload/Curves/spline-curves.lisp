;===========================================; NEW FILE : A CUBIC SPLINER (FUNC-FILE)                  ;===========================================#| CUBIC SPLINE INTERPOLATION	( rewritten by HPST 21/5/94 Montmartre )   reference: Robert Sedgewick 'Algorithms' ( Addison-Wesley 1988 ).   This is a  method to connect adjacent points by a 'pleasing' smooth curve.    The model is based on a third-degree (cubic) polynomial defined as:	S[i](X) = a[i]x**3 + b[i]x**2 + c[i]x + d[i], 	with i = 1 to N-1,in the interval x[i] to x[i+1]   The spline is represented as a system of simultanous equations in    a matrice with N-2 unknowns to be solved by Gaussian elimination.   For reasons of saving data memory a 'tridiagonal' matrice is used.   the program flows as follows:   first  : the x,y data-points are split into a matrice representation,   second : a forward elemination phase removes variables under the diagonal,   third  : a backward substitution phase replace the unknowns by their answer,   fourth : the evaluation of the spline curve with the found coefficients.   the idea of usage:   to make a seemingly knotless trajectory between abitrary data-points,   eg. the interconnection of two MIDI-controllers like PAN/VOLUME or...?   also usefull for splicing not-so-well-fitting data-blocks together,    or the frequency/amplitude variation of a slowly transforming sound,    and not the least smooth functional fluctuation of a tempo/rhythm ...?   LISP implementation note:   for the most part of this code it is based on a FORTH version, already   existing in HPST-environment. Both for similarity of thinking, for clarity   of code, and for security in indexing the LOOP FOR... statement is here   extensivly used, though it migth hurt the eye of some LISP  puritans.   At present it is not known wether RECURSION or MAPCAR could speed it up.   Please check that you have #P"root:Languages:MCL 2.0:library:LOOP.fasl"...|#;===================== ; DEFINE ENVIRONMENT                    ;=====================   (in-package :genutils);include the file LisHP:Expression.lisp;include the file LisHP:Workbench.lisp;===================== ; SETUP MATRIX                ;=====================; TERMINOLOGY and ABVIABRATIONS; O[i] = over the Diagonal at index i; D[i] = at the Diagonal at index i; U[i] = under the Diagonal at index i; W[i] = matrix scalers at index i; P[i] = unknowns at index i;setting up a tridiaginal matrix in the range of i=[1,N-1];means deriving 4 extra equal-sized vectors from the xy-list,;arranged accordingly for eg. a xy-list of 6 items with index starting at 0;;note that first and last items i=[0,5] are also used in solving the matrix:  ;  ( d1 o1 -- -- ) (p1) (w1);  ( u1 d2 o2 -- ) (p2) (w2);  ( -- u2 d3 o3 ) (p3) (w3);  ( -- -- u3 d4 ) (p4) (w4)(DEFUN MAKE-Ui (xlist)  "make a vector under the diagonal, such that    U[i] = x[i+1]-x[i]"    (loop for i from 0 to (- (length xlist) 2)    collect          (- (nth (1+ i) xlist) (nth i xlist))    into it    finally (return (append it '(0)))));(make-ui '(1 2 4 5 8 10))(DEFUN MAKE-Di (xlist)  "make a vector at the diagonal, such that    D[i] = 2(x[i+1]-x[i-1])"    (loop for i from 1 to (- (length xlist) 2)    collect          (* 2 (- (nth (1+ i) xlist) (nth (1- i) xlist)))    into it    finally (return (append '(0) it '(0)))));(make-di '(1 2 4 5 8 10))(DEFUN MAKE-Wi (xlist ylist)  "make a vector of matrix scalers, such that    W[i] = 6((y[i+1]-y[i])/(x[i+1]-x[i]) - (y[i]-y[i-1])/(x[i]-x[i-1]))"    (loop for i from 1 to (- (length xlist) 2)    collect          (* 6 (- (/ (- (nth (1+ i) ylist) (nth  i     ylist))                     (- (nth (1+ i) xlist) (nth  i     xlist)))                  (/ (- (nth  i     ylist) (nth (1- i) ylist))                     (- (nth  i     xlist) (nth (1- i) xlist)))))    into it    finally (return (append '(0) it '(0)))));(make-wi '(1 2 4 5 8 10) '(2 1.5 1.25 1.2 1.125 1.1));=====================; SOLVING UNKNOWNS;=====================;solving the unknowns P[i] by gaussian elimination ;destructivly zig-zags through and changes W,D,O ;while U is used but left unchanged. (DEFUN FORWARD-ELIMINATION (Ulist Olist Dlist Wlist)  "first step (forwards) of gaussian elimination,    such that i in the range [1,N-2] yields:   W[i+1] = W[i] - W[i+1] * (D[i]/U[i+1])    D[i+1] = O[i] - D[i+1] * (D[i]/U[i+1])    W[i+1] = zero - O[i+1] * (D[i]/U[i+1])   note how previous D[i] are use in next pass"    (loop for i from 1 to (- (length Wlist) 3)        do (setf                 (nth (1+ i) Wlist)                (- (nth i Wlist)                 (* (nth (1+ i) Wlist)                (/ (nth i Dlist) (nth i Ulist))))                              (nth (1+ i) Dlist)                (- (nth i Olist)                 (* (nth (1+ i) Dlist)                (/ (nth i Dlist) (nth i Ulist))))                              (nth (1+ i) Olist)                (- 0                 (* (nth (1+ i) Olist)                (/ (nth i Dlist) (nth i Ulist)))) )))(DEFUN BACKWARD-SUBSTITUTION (Plist Olist Dlist Wlist)  "second step (backwards) of gaussian elimination,    such that i in the range [N-1,1] yields:   P[i] = (W[i] - P[i+1]*O[i]) / D[i]    note how P[i] uses its previous value"    (loop for i from (- (length Wlist) 2) downto 1        do (setf                 (nth i Plist)                (/ (- (nth     i  Wlist)                    (* (nth     i  Olist)                      (nth (1+ i) Plist)))                      (nth     i  Dlist)) )))(DEFUN SOLVE-SPLINE (xlist ylist)  "macro that from xy-lists sets up the matrix,    solves and return the unknowns P[0,N-1]."  (progn    (let ( (Ulist  (make-Ui xlist))           (Olist  (make-Ui xlist))           (Dlist  (make-Di xlist))           (Wlist  (make-Wi xlist ylist))           (Plist  (make-list (length xlist) :initial-element 0)) )    (forward-elimination   Ulist Olist Dlist Wlist)    (Backward-substitution Plist Olist Dlist Wlist)     plist)));(solve-spline '(1 2 4 5 8 10) '(2 1.5 1.25 1.2 1.125 1.1))#| ;TEST SOLVE FORM (PROGN    (setf ;INPUT LISTs      x-list   '(1 2 4 5 8 10)      y-list   '(2 1.5 1.25 1.2 1.125 1.1);ARRAY LISTs      U-list  (make-Ui x-list)      O-list  (make-Ui x-list)      D-list  (make-Di x-list)      W-list  (make-Wi x-list y-list)      P-list  (make-list (length x-list) :initial-element 0))    (forward-elimination U-list O-list D-list W-list)    (Backward-substitution P-list O-list D-list W-list)    P-list)    U-list O-list D-list W-list P-list X-list|#;========================; EVALUATE SPLINE DATA;========================(DEFUN EVAL-SPLINE (x xlist ylist plist)  "main evaluation in canonical form, such that   S[i](t) = ty[i+1] + hy[i] + ((Tp[i+1] - Hp[i]) * q**2 / 6 ),   note that it is  a rather curved polynomial formular."  (let* (  (time  (search-high-list x xlist))          (low   (search-low-list time xlist))          (high  (1+ low))          (eval1 (- time (nth low xlist)))          (eval2 (- (nth high xlist) (nth low xlist)))          (eval3 (/ eval1 eval2))          (eval4 (- 1 eval3))          (eval5 (- (expt eval3 3) eval3))          (eval6 (- (expt eval4 3) eval4)) )        (+  (* eval3 (nth high ylist))        (* eval4 (nth low  ylist))        (/ (* (-        (* eval5 (nth high plist))        (* eval6 (nth low  plist)))                 (expt eval2 2)) 6)) ))                ;====================; END FILE;====================