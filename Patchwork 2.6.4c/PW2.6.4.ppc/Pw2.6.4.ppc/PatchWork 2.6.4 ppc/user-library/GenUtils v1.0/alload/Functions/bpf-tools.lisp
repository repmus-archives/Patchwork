;================; GENERIC METHODS;================  (in-package :PW);========================================; REDEFINE BPF TO BE A SUBCLASS OF C-GEN;========================================(DEFCLASS C-BREAK-POINT-FUNCTION (gu::c-gen)  ((break-point-list :initform nil                      :initarg :break-point-list                      :accessor break-point-list)   (x-points  :initform nil :accessor x-points)   (y-points  :initform nil :accessor y-points)));=================; GENERIC METHODS;=================(DEFMETHOD X-POINTS ((self t)) 1)    (DEFMETHOD Y-POINTS ((self t)) self) (DEFMETHOD X-POINTS ((self cons)) (arithm-ser 1 1 (length self)))(DEFMETHOD Y-POINTS ((self cons)) self);================; GET METHODS;================(DEFUN BPFP (anything) ;; definition for genutils  (and t (subtypep (type-of anything) 'gu::c-gen)))(DEFUN NLISTP (anything &optional (pred #'numberp))  (if (listp anything) (every pred anything)))(DEFMETHOD PATCH-VALUE ((self C-patch-multi-function) obj)  (let (bpfs)        (if (and (not (value self))              (or (nth-connected-p self 0)                  (nth-connected-p self 1)));IF ENTRIES ARE CONNECTED      (let* ((ts (patch-value (first (input-objects self)) obj))             (vs (patch-value (second (input-objects self)) obj)) ;here's where the hokus pokus takes place            (tlist (epw::g-round (if (nlistp (list! vs) #'bpfp)                                    (gu::get-x-points vs)                                   (gu::get-y-points ts) )))            (vlist (epw::g-round (gu::get-y-points vs))) )        (setq bpfs (construct-bpfs-objects vlist tlist))        (setf (break-point-function (give-mini-bpf self)) (first bpfs))        (update-mini-view (give-mini-bpf self))        (add-bpf-to-bpf-editor-from-PW (application-object self) (first bpfs))        (setf (break-point-functions (editor-view-object (application-object self))) (rest bpfs)));ELSE IF ENTRIES ARE FREE       (setq bpfs (cons (break-point-function (give-mini-bpf self))                         (break-point-functions (editor-view-object (application-object self))))) );OUTTYPE SELCT    (case (out-type self)                   (:bpf (if (second bpfs) bpfs (first bpfs)))    (:x-points (mapcar #'(lambda (bpf) (slot-value bpf 'X-points)) bpfs))    (:y-points (mapcar #'(lambda (bpf) (slot-value bpf 'Y-points)) bpfs)))));=====================; ACCEPT FLOAT BPFS      ;=====================   (in-package :genutils)#|  Is it fullproof? should fx. <digits> be stored internally?    what if Y-POINTS are selected at output?    HOW TO MANIPULATE <X-OFF> AND <Y-OFF>, THEY DISTURB EASELY THE VIEW?    when x-off,y-off works, then replace the <if> expression to : (/ 30 domain)|#(DEFUN MAKE-PLIST (&rest args) ;for splines  (flat (mat-trans (mapcar #'list! args))))(DEFUN MAKE-VLIST (vlist)   (y-points vlist))(DEFUN MAKE-TLIST (tlist vlist)   "if <tlist> is a number or they of unequal length,    then make from <vlist> a linear <tlist> to fit with <vlist>"  (let* ((xlist (y-points tlist))            (ylist (y-points vlist))         (xlength (length (list! xlist)))         (ylength (length (list! ylist))))   (if (numberp xlist)     (arithm-ser xlist xlist (* xlist ylength))    (if (not (eq xlength ylength))      (arithm-ser 1 1 ylength) xlist))))(DEFUN LOG-CASE (domain)  (case domain (1 0) (2 14) (10 3) (domain)));(log-case 1)(DEFUN LOG-DOMAIN (list &optional (domain 2))  (expt domain (- (log-case domain)                   (ilog (apply 'm-abs-max list) domain)))) ;; ilog & zero! : see workbench;(pw::g-round (gu::log-domain '(-1 1) 1))(DEFUN MAKE-BPF-CLASS (tlist vlist &optional (logs 1))  ; for GenUtils     "make a floating break point function instance from <tlist> and <vlist>"   (let* ((tlist (make-tlist tlist vlist))          (vlist (make-vlist vlist))         (xlength (length (list! tlist)))         (ylength (length (list! vlist))))    (if   (not (eq xlength ylength))    ;IF-UNEQUAL-ERROR      (error "<tv-lists> of uneven length or contend!")    (let* ((xscale (log-domain tlist logs))           (yscale (log-domain vlist logs))           (tscale (g-round (g* xscale tlist)))           (vscale (g-round (g* yscale vlist)))           (fl-bpf (make-break-point-function tscale vscale)) )    (set-slot fl-bpf 'x-points tlist)    (set-slot fl-bpf 'y-points vlist)    fl-bpf))) )(DEFUN FAKE-BPF-CLASS (tlist vlist)  ; For SVProjet      "fake a floating break point function instance from <tlist> and <vlist>"    (let* ((fl-bpf (make-instance 'pw::c-break-point-function :break-point-list nil)) )    (set-slot fl-bpf 'x-points (make-tlist tlist vlist))    (set-slot fl-bpf 'y-points (make-vlist vlist))    fl-bpf) )(DEFUN MAKE-DUMMY-BPF (thing)  (make-bpf-class    (list! (x-points thing))   (list! (y-points thing))));============; END FILE;============