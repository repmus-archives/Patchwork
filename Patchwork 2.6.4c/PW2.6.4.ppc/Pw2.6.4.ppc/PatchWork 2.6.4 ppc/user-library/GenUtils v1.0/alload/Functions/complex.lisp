;===========================================; NEW FILE : COMPLEX ARITHMETICS                    HPST 8/5/94 Montmartre;===========================================   (in-package :GU);===================== ; BASIC ARITHMETICS                     ;===================== ;SHOULD INPUT (a b c d) BE TWO LIST (a b) (c d) ?(DEFUN C+ (a b c d)   "list:complex addition"  (list (+ a c) (+ b d)))(DEFUN C- (a b c d)                            "list:complex subtraction"  (list (- a c) (- b d)))(DEFUN C* (a b c d)                              "list:complex multiplication"    (list (- (* a c) (* b d)) (+ (* a d) (* b c))))(DEFUN C/ (a b c d)       "list:complex division"    (list (/ (+ (* a c) (* b d)) (+ (* c c) (* d d)))          (/ (- (* b c) (* a d)) (+ (* c c) (* d d)))))(DEFUN CONJ (a b)       "list:complex conjugate"    (list a (- b)))(DEFUN XFUN (ab &optional (cfun 'conj))  "apply complex function to two lists"  (funcall cfun (first ab) (second ab)))(DEFUN CFUN (ab cd &optional (cfun 'c+))  "apply complex function to two lists"  (funcall cfun (first ab) (second ab) (first cd) (second cd)));(pw::cfun '(1 0) '(1 1) 'c-);===================== ; SIGNAL ARITHMETICS                     ;===================== (DEFUN FULL-SHIFT (x y)   "COULD SOMETHING LIKE THIS BE INCLUDED?"   (sin (+ (asin y) (atan (if (>= x 0) 1 -1)))))(DEFUN PHASE-SHIFT (sig phase)                     "shift any oscilation with any phase (-1,+1)"  (realpart   (sin (+ (asin sig) (* phase pi)))))(DEFUN FRQ-SHIFT (sig1 sig2)                            "convolve two simple signals (-1,+1)"  (realpart  (* (complex (phase-shift sig1 0.5) sig1)     (complex (phase-shift sig2 0.5) sig2))));(frq-shift -1.00001 1.000001);(frq-shift 0.643722711128992 1.1660677065108342);(sin (+ (asin 1.00) (* -0.5 pi)));(imagpart (+ (complex -1.00001) (complex -1.00001)));===========================; SOME SIGNAL TRICKS;===========================;little conversion thing meant to find duration from bw(DEFVAR *LOG-BW* (/ (log 10) (* 20 pi)));Should /1 term be left out?(DEFUN BW->DUR (amp bw)  (/ 1 (/ bw (/ amp *log-bw*))));(mapcar 'bw->dur amp-list bws-list);==============================; LIST-TO-COMPLEX CONVERSIONS;==============================(DEFUN SET-REAL (float complex)    (complex float (imagpart complex)))(DEFUN SET-IMAG (float complex)    (complex (realpart complex) float))(DEFUN L2C (list)  (complex (first list) (second list)))(DEFUN C2L (complex)  (list (realpart complex) (imagpart complex)));(pw::l2c '(2 3));(pw::c2l #c(2 3));==============================; CARTESIAN/POLAR CONVERSIONS;==============================(DEFUN Z2M (float &optional (clip 1.0E-16))  "clip zeros to default 0.000000000000000001,    to avoid zero-divsion errors"  (if (/= float 0.0) float clip));(pw::z2m 0.0)(DEFUN M2Z (float &optional (clip 1.0E-16))  "clip vals less than default 0.000000000000000001 to zero,    to avoid too tiny numbers"  (if (>= (abs float) clip) float 0.0));(pw::m2z 6.123031769111886E-17)(DEFUN DEG2RAD (degree)  (* 0.017453292519943295 degree)) ; precalculated : pi/180(DEFUN RAD2DEG (radians)  (* 57.29577951308232 radians)) ; precalculated : 180/pi;(pw::deg2rad 360);(pw::rad2deg (/ pi 2))(DEFUN CART2POLAR (real imag)   "convert cartisian to polar coordinates; phase is in radians"  (list (sqrt (+ (* real real) (* imag imag))) (atan (/ imag (z2m real)))));(pw::cart2polar 0 1)(DEFUN POLAR2CART (amp phase)   "convert polar to cartisian coordinates; phase is in radians"  (list (m2z (* amp (cos phase))) (m2z (* amp (sin phase)))));(pw::polar2cart 1 (deg2rad 360));(g-round (mapcar #'polar2cart (cirlist 2.0) ;           (mapcar #'deg2rad '(0 45 90 135 180 225 270 315 360))) 16);=========================; TRANSLATION & ROTATION    (in fact equal to convolution)     ;IN DEVELOPMENT!!!! ;=========================(DEFUN ROT-POINT (x y phase)  "rotation using <phase> in degrees on <x> and <y>"       (eval (cons 'c* (cons x (cons y (polar2cart 1 (deg2rad phase)))))) );ROTATION USING PHASE (in degrees)(DEFUN ROTATE-LIST (xlist ylist ampl phase) ; POLAR VERSION : OK!  "rotation using <phase> in degrees on <xlist> and <ylist>"       (let* ( (phase   (deg2rad phase))               (xy-list (mat-trans (list xlist ylist)))                              (shifts  (mapcar #'(lambda(xy)                                   (cart2polar (first xy) (second xy))) xy-list)) )       (mat-trans (mapcar #'(lambda(xy)                     (polar2cart (* (first xy) ampl) (+ (second xy) phase))) shifts))) )(DEFUN CROTATE-LIST (xlist ylist ampl phase) ; CARTISIAN VERSION : FASTER!  "rotation using <phase> in degrees on <xlist> and <ylist>"       (let* ( (aphase  (polar2cart ampl (deg2rad phase)))               (xy-list (mat-trans (list xlist ylist))) )       (mat-trans (mapcar #'(lambda(xy) (cfun xy aphase 'c*)) xy-list))) );(pw::crotate-list '(50 100 150 200) '(0 100 -100 0) 1 90);TRY ON MAPPING ROTATION TO SPECIFIC LOCATION : source target  ....DEBUUUUG!!!!!;(pw::cfun '(1 0) '(1 1)) ; target - source = shift to origine;(pw::matrans (list xlist ylist)) ; organize in points (DEFUN TRANSLATE-LIST (xlist ylist source target)       (let* ( (shift-0 (cfun target source 'c-))               (xy-list (mat-trans (list xlist ylist)))                              (orig-xy (mapcar #'(lambda(xy) (cfun xy shift-0 'c*)) xy-list)) )                        (mat-trans (mapcar #'(lambda(xy) (cfun source xy 'c+)) orig-xy))) );(pw::translate-list '(0 1) '(0 0) '(0.5 0.5) '(0.9 1.0));==========================================================================================================; NEW IDEAS FROM HERE...TRY ON MAPPING ROTATION TO SPECIFIC LOCATION : source target  (called TRANSLATION);==========================================================================================================(DEFUN ZEROLATE-LIST (xlist ylist) ; ==> out is  xlist,ylist       (let* ( (xy-list   (mat-trans (list xlist ylist)))               (xy-orig   (mapcar #'(lambda(xy) (cfun xy (car xy-list) 'c-)) xy-list))                  (shift-0   (xfun (car (last xy-orig)) 'conj)) )                (mat-trans (mapcar #'(lambda(xy) (cfun xy shift-0 'c*)) xy-orig)) )) ;(pw::zerolate-list '(0.1 1.0) '(0.5 1.0) )(DEFUN XY-SCALE (xlist ylist scaler) ; scaler is xy-points ==> out is xy-points       (let* ( (x2    (car  scaler))               (y2    (cadr  scaler))                              (xN    (apply 'max xlist))                                       (yN    (max 0.000000000001 (apply 'max ylist))) )                                     (mapcar #'(lambda(x y) (list                                      (* (/ x xN) x2) (* (/ y yN) y2))) xlist ylist)));(pw::xy-scale '(0 1 .2 -4 1) '(0 0 0 -10 .1) '(1 0.5))(DEFUN ZJIFT-LIST (xlist ylist source target) ; source & targets are in xy-points ==> out is xlist,ylist       (let* ( ; (xy-list   (mat-trans (list xlist ylist)))                 ;not used               (st-list   (print (mat-trans (list source target))))         ;organize source / target               (xy-orig   (print (zerolate-list xlist ylist)))              ; shift xy to origine               (st-orig   (print (mat-trans (zerolate-list (first st-list) (second st-list))))) ;shift source/target to origine               (xy-diff   (cfun target source 'c-))               (lastx     (print (caar (last st-orig))))               ; last x = max x ?               (lasty     (print (cadr (cfun target source 'c-))))     ; last y = diff y-target y-source               (xy-shift  (print (xy-scale (first xy-orig) (second xy-orig) (list lastx lasty)))) )  ;scale xy-list               (mat-trans (mapcar #'(lambda(xy) (cfun xy source 'c+))                            (print (mapcar #'(lambda(xy) (cfun xy xy-diff 'c*)) xy-shift)))) )) ;shift and add source ;(pw::zjift-list '(0.5 0.9) '(0.5 1.0) '(0.1 0.5) '(1.0 1.0));====================; NOT TESTED!!!!!;====================(DEFUN ZRANSLATE-LIST (xlist ylist source target) ; NOT TESTED!!!!!       (let* ( (xy-list (mat-trans (list xlist ylist)))               (xy-0    (print (cfun (car (last xy-list)) (car xy-list) 'c-))) ;zero shifted xy-end               (ctrl-0  (print (cfun target source 'c-)))                      ;zero shifted ctrl-end               ;               (xy-orig (print (mapcar #'(lambda(xy) (cfun xy (car xy-list) 'c-)) xy-list)))               (shift-0 (print (cfun ctrl-0 xy-0 'c-)))                        ;end-diff               (diff-0 (print (cfun source (car xy-list) 'c-))))               ;beg-diff               (mat-trans (mapcar #'(lambda(xy) (cfun xy diff-0 'c+))                             (print (mapcar #'(lambda(xy) (cfun xy shift-0 'c*)) xy-list))))) );(pw::zranslate-list '(0 1) '(0 0) '(0.5 0.5) '(0.9 1.0));==============; 3D PLOTS          ; A SKETCH!;==============(DEFUN 3DPLOT (reals imags xoff yoff)  (list (g+ reals (g* xoff (arithm-ser 1 1 (length reals))))        (g+ imags (g* yoff (arithm-ser 1 1 (length imags))))));(pw::3dplot '(0 10 20 30 40 50) '(10 10 10 10 10 10) 0 0)(DEFUNP WATERFALL ((objs  list (:value "()" :type-list (bpf list)))                   (x-off fix/float (:value 0))                   (y-off fix/float (:value 0))                   (xzoom fix/float (:value 1))                   (yzoom fix/float (:value 1))                   (phase fix/float (:value 0))) all-types        "make bpfs-copies from <objs> suitable for a waterfall view.          first multiply <xzoom> & <yzoom>, then add <x-off> & <y-off>         to x-points and y-points, respectivly, in an accumulating manner.         Use <phase> in degrees to to shift or rotate the bpf as well."  (let (xbpf (x-val 0) (y-val 0) (width 1) (heigth 1) (rotate 0))        (mapcar #'(lambda(bpf);shoft,zoom,rotate bpf                                (setq xbpf                      (apply #'make-bpf                        (crotate-list                       (g+ x-val (g* width  (x-points bpf)))                       (g+ y-val (g* heigth (y-points bpf)))                       1 rotate)));update variables                (setq x-val  (+ x-val x-off))                (setq y-val  (+ y-val y-off))                (setq width  (* width xzoom))                (setq heigth (* heigth yzoom))                (setq rotate (+ rotate phase))                xbpf) (make-xbpf objs))));=================================; END FILE : COMPLEX ARITHMETICS;=================================