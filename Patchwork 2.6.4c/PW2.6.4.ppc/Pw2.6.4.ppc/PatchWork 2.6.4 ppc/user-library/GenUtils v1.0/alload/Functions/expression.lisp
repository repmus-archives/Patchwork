;===========================================; NEW FILE : EXPRESSION (simple LISP funcs)      HPST 11/4/94 Montmartre;===========================================#|     File that contians a collection of basic Trigonometric,Exponential,Distribution functions|#;====================; DEFINE ENVIRONMENT;====================   (in-package :genutils);====================; PIN-POINT FUNCTION;====================#| NOT USED ANY MORE (DEFUN SIGN (num)                               ;good for boolean tests  "returns 1,0,-1 if num is either >,=,< zero "        (if (> num 0) 1 (if (< num 0) -1 0)))(DEFUN NEW-PIN (incr pin)     ;general FINAL VERSION??????  "calculate new <incr> according to <pin>"  (if (< incr pin)      (* incr (/ 1 pin))                     ;upwards = just scale      (1+ (* (- incr pin) (/ 1 (1- pin)))))) ;downwards = reversed scaling|#(DEFUN PINING (incr pin)                        ;generalized calc of pin-point  "calculate new <incr> according to <pin>"  (let* ( (incr (abs (rem incr 1.0000001)))                         (flag (if (>= incr pin) 1 0)) )       ;is num pass pin?              (unit incr           (min flag pin)       ;stretch <incr> in 0,pin to 0,1/2          (max flag pin)       ;and ...          (min flag 1/2)       ;stretch <incr> in pin,1 to 1/2,1          (max flag 1/2) )))   ;should work now!;====================; SCALING FUNCTIONS;====================(DEFUN ZERO! (float &optional (subs 1.0E-8)) ;to avoid zero   (if (= 0.0 float) subs float))(DEFUN ONE! (float &optional (subs 0.99999999999999)) ;to avoid one  (if (= 1.0 (abs float)) (* float subs) float))(DEFUN UNIT (num x1 x2 y1 y2)                   ;classic unit scaler  "map num in the range [x1,x2] to [y1,y2]."    ;OBS! x1 not equal x2       (+ y1 (* (- num x1) (/ (- (float y2) y1) (zero! (- x2 x1))))))(DEFUN WIND (num unit base)                     ;good for 0-1 scaled to x,y  "scale num by unit, add base."       (+ (* (float num) unit) base))(DEFUN ZOOM (list xmax ymax)                    ;good to scale x-points in bpf      "scale a list to x,y"     (let ((xmin (apply 'min list))          (ymin (apply 'max list)))    (mapcar #'(lambda (n)                 (funcall 'unit n xmin ymin xmax ymax))                  list)));=======================; EXPONENTIAL FUNCTIONS;=======================(DEFUN IZERO (val) ;special convert float-zero to int-zero  (if (= 0 val) 0 val))(DEFUN POWER (incr max &optional (factor 1))      ;good for exponentials  "power between 0-1 with <incr> inside 0-<max>, power <factor>"        (expt (mod (* incr max) 1.0) (izero (abs factor))))(DEFUN SLOPE (incr max &optional (factor 1))      ;good for slopings  "slope between 0-1 with <incr> inside 0-<max>, nat-exp <factor>"  (let ((factor (if (= 0 factor) 1.0E-10 (- factor))))         (/ (- 1.0 (exp (* (mod (* incr max) 1.0) factor)))            (- 1.0 (exp factor)))));=========================; TRIGONOMETRIC FUNCTIONS;=========================(DEFVAR 2pi (* 2 pi))(DEFUN SINUS (incr frq &optional (phase 0))      ;sinus oscillation  "classic sine oscillation with unit amplitude"  (sin (- (* incr frq 2pi) (* phase 2pi))))(DEFUN COSINUS (incr frq &optional (phase 0))    ;cosinus oscillation  "classic sine oscillation with unit amplitude"  (cos (- (* incr frq 2pi) (* phase 2pi))));==========================; CLASSIC WINDOW FUNCTIONS;==========================(DEFUN HANNING (incr frq &optional (phase 0))    ;hanning window  "classic hanning window with unit amplitude"  (+ (* -0.5 (cosinus incr frq phase)) 0.5))(DEFUN HAMMING (incr frq &optional (phase 0))    ;hamming window  "classic hamming window with unit amplitude"  (+ (* -0.46 (cosinus incr frq phase)) 0.54))(DEFUN WINDOW (incr frq &optional (alfa 0.5))    ;alfa shaped window  "general classic <alfa> shaped window with unit amplitude"  (+ (* (1- alfa) (cos (* incr frq 2pi))) alfa))(DEFUN RECTANGLE (incr frq &optional (factor 1)) ;rect-to-tri shaped window  "general rectangular-to-triangular shaped window with unit amplitude"  (realpart (expt (zero! (- 1 (abs (1- (* incr frq 2 ))))) (* 2 factor))));=========================; OTHER SIGNAL FUNCTIONS;=========================(DEFUN PHASOR (incr frq &optional (phase 0))            ;phasor oscillation  "classic phasor oscillation with unit amplitude"  (mod (- (* (one! incr) frq) phase) 1.0))(DEFUN SQUARE (incr frq &optional (phase 0))           ;square oscillation  "classic square oscillation with unit amplitude"  (mod (truncate (+ (* (one! incr) frq) phase 0.5) 0.5) 2))(DEFUN TRIANGLE (incr frq &optional (phase 0))         ;triangle oscillation  "classic triangle oscillation with unit amplitude"  (- 1 (abs (1- (* 2 (phasor incr frq phase))))));==============================; IMPULSE GENERATION FUNCTIONS;==============================;UNTIL FURTHER SOLUTIONS, THIS IS IT!  (note dangerous <resolution> parameter);is there a way to calculate how much <incr> resolution;deviates from <frq> resolution, so as to find an appropriate ;zone around zero inwhich to "detect" when <incr> passes.(DEFUN DIRAC (incr frq &optional (phase 0) (resolution 100))  ;impulse train  "conditional impulse generation with unit amplitude"  (if (<  -1.0E-100          (phasor incr frq phase)          (/ frq resolution))    1 0));NEWEST SOLUTIONS, using phasor as safety mechanism;safety recomandation: that number of samples is some multiple of <frq>(DEFUN IMPULS (incr frq &optional (decay 1) (digits 4))       ;impulse generator  "exponential impulse generation with unit amplitude"  (g-round (expt (expt 10 digits) (- (* decay digits (phasor incr frq 0)))) digits));SOME ADDITIONAL IMPULSE GENERATORS;could they be windows as well?(DEFUN SINC (incr frq &optional (phase 0) (factor 2))       ;sinc-puls generator  "sinc impulse generation with unit amplitude"   (/ (expt (sinus incr frq phase) factor) (zero! incr)))(DEFUN COSC (incr frq &optional (phase 0) (factor 2))       ;cosc-puls generator  "cosc impulse generation with unit amplitude"   (/ (expt (cosinus incr frq phase) factor) (zero! incr)))(DEFUN NEUTRON (incr frq &optional (decay 1) (phase 0) (digits 8))    ;quasi-random-puls generator  "quasi-random impulse generation with unit amplitude"   (expt (impuls incr frq decay digits) (x-gauss (phasor (- 1 incr) frq phase))));====================; COMBINED FUNCTIONS   (exponential + trigonometric)  (adapted from TEMPELAARS);====================(DEFUN ISIN (incr frq)  (sin (* incr frq 2pi)))   (DEFUN ICOS (incr frq)  (cos (* incr frq 2pi)))    (DEFUN ESIN (incr frq &optional (decay 0))  (* (isin incr frq) (exp (- (* incr decay pi)))))(DEFUN ECOS (incr frq &optional (decay 0))  (* (icos incr frq) (exp (- (* incr decay pi)))))(DEFUN ATSIN (incr frq &optional (decay 0))  (* incr (esin incr frq decay)))(DEFUN ATCOS (incr frq &optional (decay 0))  (* incr (ecos incr frq decay)))(DEFUN BSIN (incr frq &optional (beats 0))  (* (isin incr frq) (isin incr beats)))(DEFUN BCOS (incr frq &optional (beats 0))  (* (icos incr frq) (icos incr beats)))(DEFUN SINOS (incr ratio &optional (decay 0))  (+ (isin incr (numerator ratio))      (ecos incr (denominator ratio) decay)))(DEFUN SONIS (incr ratio &optional (decay 0))  (+ (icos incr (numerator ratio))      (esin incr (denominator ratio) decay)));=========================; TEST BASIC FUNCTIONS        LEAVE OUT!;=========================#|(DEFUN XSIG-CALL (frq N func &optional (phase 0)) (loop for i from 0 to 1 by (/ 1 N)      collect (funcall func i frq phase)));(pw::g-round (pw::xsig-call 4 40 'neutron 1) 4);=========================; AND YET MORE DSP ....        LEAVE OUT!;=========================  (DEFUN FRQ-MASK (dur N) (loop for i from 0 to (1- N)      collect (/ N dur)))(DEFUN AMP-MASK (x N) (loop for i from 0 to (1- N)      collect (if (<= (1- i) x (1+ i)) 1 0)))(DEFUN PHA-MASK (N) (loop for i from 0 to (1- N)      collect (if (= 0 (mod i 2))                  0.0 0.5)))(DEFUN WINDS (time amps frqs phas)      "simulates a serie of hanning windows setup with amps,frqs,phas"        (mapcar #'(lambda (amp time frq ph)                     (* amp (hanning time frq ph)))                        amps (pw::cirlist time) frqs phas))(DEFUN ADDSYN (time amps frqs phas)      "simulates additive synthesis from amp,frq,pha-lists       (note : performs no normalisation what-so-ever)"        (mapcar #'(lambda (amp time frq ph)                     (* amp (sinus time frq ph)))                        amps (cirlist time) frqs phas))(DEFUN CASCADE (time amps frqs phas)      "simulates a left-to-rigth cascade of frq-modulation from amp,frq,pha-lists       (note : performs no normalisation what-so-ever)"      (let ((mod 0))        (mapcar #'(lambda (amp time frq ph)                    (setf mod (* amp (sinus time (+ frq mod) ph))))                        amps (cirlist time) frqs phas)))(DEFUN FRQ-AMP-MOD (time amps depths speeds frqs mods rates)      "simulates combined frq/amp modulation from amp,depth,speed & frq,mod,rate-lists       (note : performs no normalisation what-so-ever)"      (let ((phas (make-list (length amps) :initial-element 0)))        (g* (g+ amps (cascade time depths speeds phas))            (g+ frqs (cascade time mods   rates  phas)))))|#;=========================; DISTRIBUTION FUNCTIONS;=========================(DEFUN X-RAN ()"Uniform distribution, such that 0 =< <x> =< 1"  (random 1.0))(DEFUN  X-RAN01 ()"Uniform distribution, such that 0 < <x> < 1"  (let ((u))    (setf u (x-ran))    (if (or (= 0 u) (= 1 u)) (x-ran01)  u)))(DEFUN X-RAN0 (devia)"Uniform distribution, such that 0 < <x> =< devia"  (random (zero! devia)))(DEFUN X-LIN (devia) "Linear distribution of parameter <devia>"  (* (- 1 (sqrt (x-ran))) devia))(DEFUN X-PON (devia) "Variant on exponential distribution of density <devia>." (/ (* (log (x-ran01)) devia) -10))(DEFUN X-TRI (devia)  "Triangular distribution of average <devia>"  (* (/ (+ (x-ran) (x-ran)) 2) devia))(DEFUN X-ASIN (devia)  "Arc sinus distribution of parameter <devia>"  (* (expt (sin (/ (* pi (x-ran)) 2)) 2) devia))(DEFUN X-HCOS (devia)  "Hyperbolic cosinus distribution of parameter <devia>"  (* (log (tan (/ (* pi (x-ran01)) 2))) devia))(DEFUN X-GAUSS (devia)  ;FAKE VERSION UNTIL FURTHER!                             "A variant on gaussian distribution, that never passes devia"        (* (/ (- (apply '+ (loop for i to 11                                 collect (random 1.0))) 6.0) 6.5535) devia))(DEFUN X-BETA (a b)  "Beta distribution of parameters <a> and <b>.   For <a> = <b> = 1 the result is a continuous uniform    distribution, for <a> and <b> greater than 1 the result    is similar to a gaussian distribution."  (let* ((y1 (expt (x-ran) (/ 1 (zero! a))))         (y2 (expt (x-ran) (/ 1 (zero! b))))         (y3 (+ y1 y2)))    (if (> y3 1) (x-beta a b) (/ y1 y3))));========================; END FILE : EXPRESSION ;========================