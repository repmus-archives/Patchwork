;============================; NEW FILE : GENERIC METHODS          (HPST 5/5/95 IRCAM);============================#|  Generic methods, using <cons> as inheritor for list, and <t> for constants.    A root-class <C-GEN> is defined for all gen-types : c-curve,c-signal,c-bpf.    Methods specific to these objects are to be found in the following files:    c-curve : class-curve; c-signal : class-shape; c-bpf : transfer-shape.    Also the existing c-break-point-function has been redefined to allow for    flexible input to the BPF in PW (ints,floats,gens); for more see BPF-tools.|#  ;=====================; DEFINE ROOT CLASS;===================== (in-package :genutils)  (DEFCLASS C-GEN () ()) ;inherits from <standard-class>;=======================; BASIC GENERIC METHODS   ;=======================#| LIST of METHODS that should apply to all types : num,list,gens(DEFMETHOD NLENGTH       ((self c-gen)) 1)(DEFMETHOD GIVE-X-POINTS ((self c-gen)) 1)(DEFMETHOD GIVE-Y-POINTS ((self c-gen)) 1)(DEFMETHOD DO-ANY        ((self c-gen) method &rest args) (apply method self args))(DEFMETHOD SIGNAL-OUT    ((self c-gen)  &rest args) (declare (ignore args)) 1)(DEFMETHOD SAMPLE-GRID   ((self c-gen)  grid)  (declare (ignore grid)) 1)(DEFMETHOD SAMPLE-TIME   ((self c-gen)  times) (declare (ignore times)) 1)(DEFMETHOD SAMPLE-AUTO   ((self c-gen)) 1)|#;================; LENGTH METHODS;================;(DEFUN YLENGTH (any) ;THIS IS THE GOOD ONE!!!!;  (if (or (numberp  any);          (shapep   any)) 1 ;  (if (or (multip   any);          (numlistp any)) (length any);  (if (2listp any) (g-max (mapcar #'length any)) any))))(DEFMETHOD NLENGTH ((self t)) 1)(DEFMETHOD NLENGTH ((self cons))   (if (every #'numberp self) (length self) (mapcar #'nlength self)))(DEFMETHOD NLENGTH ((self c-gen)) (length (give-y-points self)))(DEFUN YLENGTH (&rest any)  (g-fun #'g-max (mapcar #'nlength any)))#| NOT USED ANYWAY(DEFMETHOD MANY ((self t)) 1)(DEFMETHOD MANY ((self cons))   (if (every #'numberp self) (length self) (mapcar #'many self)))(DEFMETHOD MANY ((self c-gen)) 1)(DEFUN XMANY (&rest any)  (g-fun #'g-max (mapcar #'many any)))|#;================; GET METHODS;================;;(in-package :PW)(DEFMETHOD GIVE-X-POINTS ((self t)) 1)    ;should return '(1 1) ?(DEFMETHOD GIVE-Y-POINTS ((self t)) self) ;should return (list self self) ?(DEFMETHOD GIVE-X-POINTS ((self cons)) (arithm-ser 1 1 (length self)))(DEFMETHOD GIVE-Y-POINTS ((self cons)) self);;(in-package :GU)(DEFMETHOD GIVE-X-POINTS ((self c-gen)) 1)(DEFMETHOD GIVE-Y-POINTS ((self c-gen)) 1);=========================; NUMBER SAMPLING METHODS;=========================(DEFMETHOD SIGNAL-OUT ((self t) &rest args)  ; args = '(fun sig time amp frq pha)  (declare (ignore self)) ;  (print args) (print "num")  (apply #'funcall args))(DEFMETHOD SAMPLE-GRID ((self t) grid)  (if (= 0 grid) self (make-list grid :initial-element self)))(DEFMETHOD SAMPLE-TIME ((self t) times)  (if (numberp times) self (make-list (length times) :initial-element self)));=======================; LIST SAMPLING METHODS;=======================(DEFMETHOD SIGNAL-OUT ((self cons) &rest args)  ; args = '(fun sig time amps frqs phas)  (declare (ignore self));  (print args) (print "cons")  (let* ((long (1- (ylength (nth 2 args))))         (func (nth 0 args))         (sign (nth 1 args))         (time (nth 2 args))         (amps (grid-sample (nth 3 args) long))         (frqs (grid-sample (nth 4 args) long))         (phas (grid-sample (nth 5 args) long)))   (mapcar #'(lambda(time amp frq pha)                           (signal-out time func sign time amp frq pha))  time amps frqs phas) ))(DEFMETHOD SAMPLE-GRID ((self cons) grid)    (sample-grid (make-xbpf self) grid))(DEFMETHOD SAMPLE-TIME ((self cons) times)    (sample-time (make-xbpf self) times))  ; rescale???;======================; GEN SAMPLING METHODS    to be defines specificly for each gen-type;======================(DEFMETHOD SIGNAL-OUT    ((self c-gen)  &rest args) (declare (ignore args)) 1)(DEFMETHOD SAMPLE-GRID   ((self c-gen)  grid)  (declare (ignore grid)) 1)(DEFMETHOD SAMPLE-TIME   ((self c-gen)  times) (declare (ignore times)) 1);===============================; APPLY ANY FOR CONSTANT "ARGS";===============================(DEFMETHOD DO-ANY ((self t) method &rest args)  (apply method self args))(DEFMETHOD DO-ANY ((self c-gen) method &rest args)  (apply method self args));ONLY TEST: is list a numlist? if-not then recurse(DEFMETHOD DO-ANY ((self cons) method &rest args);  (print args) (print "ANY")  (if (every #'numberp self) (apply method self args)     (mapcar #'(lambda(obj) (apply #'do-any obj method args)) self)));================================; APPLY DEEP FOR VARIABLE "ARGS";================================(DEFMETHOD DO-DEEP ((self t) method &rest args)  (apply method self args))(DEFMETHOD DO-DEEP ((self c-gen) method &rest args)  (apply method self args));ONLY TEST: is list a numlist? if-not then recurse(DEFMETHOD DO-DEEP ((self cons) method &rest args);  (print args) (print "DEEP")  (if (every #'numberp self) (apply method self args)       (apply #'mapcar #'(lambda(self &rest arg)       (apply #'do-deep self method arg)) (cons self args))));(defun &print (&rest args) (print args));(do-deep '((0 1) (2 3) (4 5)) '&print '(6 7 8) '(10 11 12) '((1 3) (1 4) (1 5)));================; AUTO SAMPLING;================(DEFMETHOD SAMPLE-AUTO ((self t)) self)(DEFMETHOD SAMPLE-AUTO ((self cons)) self)(DEFUN DIGITS? (list)   "find max number of digits in float part of tree"  (g-fun #'g-max          (epw::deep-mapcar/1                  #'(lambda(val)                      (if (rationalp val) 0                          (- (length (princ-to-string val))                              (length (princ-to-string (truncate val))) 1)))                  list)))(DEFUN ?ABS> (test val)  "key to get rid of very small numbers"  (< (abs val) test))(DEFUN AUTO-GCD (obj)  ;note the use of <TRANS-BPF>  "auto sample <obj> = sample at gcd of x-points."  (let* ((xpnts   (give-x-points obj))         (digs    (digits? xpnts))         (precis  (if (/= 0 digs) (expt 10 (- digs)) 0))         (clean   (remove (expt 10 (- 0 digs 2)) xpnts :test #'?abs>))         (step    (g-round (pw::pgcd clean precis) digs)) )     (trans-bpf (make-xbpf  obj)                 (make-xbpf (g-round xpnts digs))                (arithm-ser 1 step (* step (ylength obj))))))(DEFMETHOD SAMPLE-AUTO ((self c-gen))    "auto sample <obj> = sample at gcd of x-points."    (give-y-points (auto-gcd self)));================; END FILE;================