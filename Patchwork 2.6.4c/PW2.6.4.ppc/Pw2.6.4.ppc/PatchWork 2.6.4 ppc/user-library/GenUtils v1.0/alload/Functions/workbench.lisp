;===========================================; NEW FILE : WORKBENCH (simple LISP tools)       HPST 11/4/94 Montmartre;===========================================  (in-package :genutils);========================; ABORT & CLEANUPS;========================(DEFUN CLEAN ()  (room (eq nil (gc))))(DEFUN TOP ()  (toplevel));========================; ADD TO END OF LIST;========================(DEFMACRO ADDF (val name)  `(setf ,name (nconc ,name (pw::list! ,val))));(setf x '(0 1 2 3));(setf y '(3 4 5 6));(addf 88 x);(addf y x);========================; FUNCTIONS OF ALL SORTS   OUT?;========================(DEFUN NTHOF    (lpos list)"return item at <lpos> from <list>-of-lists"  (if  lpos    (nthof (rest lpos) (nth (first lpos) list)) list) )(DEFUN NTHCAR    (pos list)"this is the same as from-the-beginning"  (when   (/= pos 0)    (cons   (first list)             (nthcar (- pos 1) (rest list)))) )(DEFUN SIZE (list)                               ;length of list-1 ( = N-1 )  "length of list-1, to fit with loops."  (1- (length list)) )(DEFUN INDEX (num list)                          ;variant of search  "find index of num."  (search (list num) list) )(DEFUN INDEXOF   (item list)                     ;another variant of search  "find index of item."     (if  (/= item (first list))          (+ 1 (indexof item (rest list)))             0) )(DEFUN INDICES   (num list)                      ;yet another variant of search  "search for multiple indices."     (when list       (if (= num (first list))         (cons           (+ 1 (indices num (rest list)))            -1)          (+ 1 (indices num (rest list))))) );===============; REMOVE TOOLS  ;===============(DEFUN REMOVE-REPS (list &optional (pred 'eq))  (let (prev accum)    (mapcan #'(lambda(item)                (setq accum (if (not (funcall pred prev item)) (list item)))                (setq prev item) accum) list)));===========================; SOME LISP TOOLS              OUT?;===========================(DEFUN SHORTEST (list1 list2)  (if (> (length list1) (length list2))    list2 list1))(DEFUN LONGEST (list1 list2)  (if (< (length list1) (length list2))    list2 list1)) ;(shortest '(1 2 3 4) '(2 3 4) )(DEFUN FLET-LISTS (list1 list2)  (let ((temp))  (dotimes (1- (min (length list1) (length list2)))      (push (pop list1) temp)          (push (pop list2) temp))  (nreverse temp)) );(flet-lists '(1 2 3 4) '(2 3 4))(DEFUN CLIPTO (value low high)  (max (min value (max high low)) (min low high)) );(clipto  2 4 1) (DEFUN FOLDIN (num low high)  "function that 'folds' a <num> to lay inside low/high,    by recursivly wrapping it around borders.   Take care, not fast for <num> way beyond limits."  (let  ((high (max low high))         (low  (min low high)))    (if (<= low num high) num    (foldin     (if (> num high)       (- high (- num high))       (+ low  (- low num)))     low high))) );(foldin -12.03 -5.1 -2.5)(DEFUN INRANGE (num low high unit)  "function that 'folds' a <num> to lay inside <low> <high>,    by recursivly wrapping it around borders by add/sub of <unit>.   Take care, not fast for <num> way beyond limits."  (let  ((high (max low high))         (low  (min low high)))    (if (<= low num high) num    (inrange     (if (> num high)       (- num unit) (+ num unit))     low high unit))) )(DEFUN TEMPS (x nom den factor)  "tempo scaler that takes -1<x<+1 and maps it logarithmically to the range   nom/den^factor (faster) for 0<x1 and den/nom^factor for -1<x<0 (slower);   x=0 always denotes no changes."     (let ( (N (expt              (1+ (* (abs x) (1- (sqrt (/ nom den)))))              factor)))    (if (>= x 0) N (/ 1 N))) );(temps 1 2 3 2);(temps -1 2 3 2);===========================; ERROR CHECKING (boolean)    NOT USED??;===========================(DEFUN NOTEQ (list1 list2)  (not (and (= (length list1)                (length list2))               (every #'numberp list1)               (every #'numberp list2))))(DEFUN NUM? (num)  (if (numberp num)    num (car num)))(DEFUN LIST? (list)  (if (numberp list)    (list list) list));(DEFUN ZERO! (float)                  ;defined in Expression.lisp;  (if (= 0.0 float) 1.0E-8 float));====================; MULTIS PREDICATES    GET RID OFF!!;====================(DEFUN GENP (anything)  (eq 'gu::c-gen (type-of anything)))(DEFUN SUBGENP (anything) ;; Change name to BPFP  (and (subtypep (type-of anything) 'gu::c-gen) t))(DEFUN BPFP (anything) ;; definition for PatchWork  (eq 'pw::c-break-point-function (type-of anything)));;(DEFUN BPFP (anything);;  (and (subtypep (type-of anything) 'gu::c-gen) t))(DEFUN CURVEP (anything)  (eq 'gu::c-curve-function (type-of anything)))(DEFUN SIGNALP (anything)  (eq 'gu::c-signal-function (type-of anything)))  (DEFUN SHAPEP (anything)  (or (genp anything) (bpfp anything) (signalp anything) (curvep anything)))(DEFUN NUMLISTP (anything)  (if (listp anything) (every #'numberp anything)))(DEFUN ANYP (anything) ;SHOULDN'T NUMBERP BE LEFT OUT??  (or (numberp anything) (numlistp anything) (shapep anything)))(DEFUN 2LISTP (anything)  (if (listp anything) (every #'numlistp anything)))(DEFUN MULTIP (anything)  (and (listp anything) (every #'anyp anything))) (DEFUN NOR (flag &rest flags)  (let ((fl nil))  (epw::deep-mapcar/1 #'(lambda(item) (setf fl (or fl (eq t item))))                       (cons flag flags))   (not fl)))(DEFUN ALLNUMP (anything)  (let ((flag t))  (epw::deep-mapcar/1 #'(lambda(item) (setf flag (and flag (numberp item))))                       anything) flag))(DEFUNP DO-ANY-OLD ( (object symbol (:value "()"))                 (method symbol (:value "()"))                 &rest                  (args   symbol (:value "()")) ) all-types  "little module to apply <method> on its proper <object> with optional <args>;   input types can be a number, a list, a double-list, a shape or a multi-shape."     (if (anyp object) (apply method object args)     (if (multip object) (mapcar #'(lambda(obj) (apply method obj args)) object) object)));==================; SAEFTY FUNCTIONS   GET RID OFF!!;==================(DEFUN G-FUN (fun list)  (if (listp list) (g-fun fun (funcall fun list)) list));(g-fun 'g-min '((10 20) (5 30)))(DEFUN FUN-LENGTH (items &optional (fun 'max))       (apply fun (mapcar #'(lambda (item) (length (pw::list! item))) items)));(fun-length (list 51 50 '(0 50 100) '(0 100 0)))(DEFUN FUN-LIST (val max)  (if (not (listp val)) (make-list max :initial-element val) val));(fun-list 10 3);recursive function to check <list> if item at <depth> satifies <pred>(DEFUN XPRED (list pred &optional (depth 0))  (if (and (> depth 0) (listp list))    (xpred (car list) pred (1- depth))    (funcall pred list)));(xpred '(1) 'listp 1);if item in <list> at <depth> don't satifies <pred> then make as llist of <length>;meant to handle all the differences that migth occur in the input of a module;see ITERATOR in the control-shapes of SHAPES for an example(DEFUN MAKE-XLIST (list &optional (depth 0) (length 1))  (if (xpred list 'listp depth) list       (make-list length :initial-element list)));(make-xlist '((1 2)) 1 5);make depth of input correspond to depth of input;measure depth of input : (depth? <obj>);in between migth occur : all kinds of listsssss;force depth of output : (abs-flat! obj depth)  (DEFUN DEPTH? (obj &optional (depth 0))  (if (listp obj) (depth? (car obj) (1+ depth)) depth))(DEFUN DEPTH! (obj &optional (depth 0))  (if (> depth 0) (depth! (list obj) (1- depth))      (if (and (< depth 0) (listp obj))        (depth! (car obj) (1+ depth)) obj)))(DEFUN REL-FLAT! (obj &optional (depth 0))  "add/remove <depth> number of lists from <obj>"  (if (> depth 0) (depth! (list obj) (1- depth)) obj))(DEFUN ABS-FLAT! (obj &optional (depth 0))  "forces an <obj> to be a list of <depth> lists"   (depth! obj (- depth (depth? obj))))(DEFUN !LISTP (list &optional (pred 'numberp) (flag t))  "test if all items of <list> satisfy <pred>"  (if list (!listp (cdr list) pred (and flag (funcall pred (car list)))) flag))(defun ?LISTP (list &optional (pred 'numberp) (flag nil))  "test if one item of <list> satisfy <pred>"  (if list (?listp (cdr list) pred (or flag (funcall pred (car list)))) flag));=====================; TYPE CONVERSION       KEEP!;=====================(DEFUN INT (val)  (g-round val));=====================; SOME CONDITIONALS;=====================;(DEFUN ERSATS (list test pred sub);  (mapcar #'(lambda (item);             (if (funcall pred item test) sub item)) list));=====================; SHIFT FUNCTION        KEEP!;=====================(DEFUN SHIFT-LIST (list &optional (axis 0)) ;see also in complex.lisp    "function to shift a list to a minimum value of <axis>,     defaults to 0 = shifting values to positive domain."   (g+ (- axis (apply 'min list)) list) )(DEFUN REVERSE-LIST (list)  "function to reverse order of items in a <list>"  (reverse list))(DEFUN INVERSE-LIST (list)  "function to inverse values in a <list>, borders remains equal"  (shift-list (g- 0 list) (apply 'min list)));=====================; RECURSIVE FUNCTION    KEEP!;=====================(DEFUNP AVERAGER ( (list     list      (:value '(0 8 5 13 9)))                   (repeats  fix>0     (:value 2))                   (function symbol    (:value 'max))                   (weigth   fix/float (:value 2))                  &optional                   (permut   symbol    (:value 'permut-circ))) list       "basic recursive function, for successive applications of         a function to the multiple copying and permutating of a list"  (when (< 0 repeats)    (append list (averager                   (mapcar function list (funcall permut list) (cirlist weigth))                  (1- repeats) function weigth permut))))(DEFUNP ENERGY ((bpf    list   (:value "()" :type-list (bpf list)))                 (points fix>=0 (:value 2))                 (average menu  (:menu-box-list ( ("sum"  . sum)                                                  ("mean" . mean)                                                  ("pow2" . pow2)                                                  ("rms"  . rms) )                                                :type-list (all-types)))                 (iterations fix>0) ) list  "return measure of average force in <bpf> over <points> items at each item,   according to type of <measure>; function repeat <iterations> many times."  (let* ( (ypts (get-y-points bpf))          (pnts (if (= 0 points) (length ypts) points)) )  (if (> iterations 0)    (energy (loop for index to (- (length ypts) pnts)                 collect (funcall average (subseq ypts index (+ index pnts))))           points average (1- iterations)) ypts)));=========================================; CONCATENATED FILE : LIST MODIFICATIONS     HPST 26/4/94 IRCAM;=========================================;==========================; INDIRECT INVOCATION;==========================(DEFUN buffer-func (func vdata buffer)       "indirect buffer-function invocation"      (mapcar func vdata (cirlist buffer))) ; MORE GENERAL      ;;; (mapcar func (cirlist buffer) vdata)) ; GOOD FOR - & /(DEFUN vector-func (func vdata list)       "indirect vector-function invocation"             (mapcar func list vdata))(DEFUN buffer-lambda (func vdata buffer)       "indirect buffer-function invocation"             (mapcar #'(lambda (x) (funcall func x buffer)) vdata))(DEFUN vector-lambda (func vdata list)       "indirect vector-function invocation"             (mapcar #'(lambda (x) (funcall func x (pop list))) vdata));(mapcar '-  '(0.1 0.2 0.3) (pw::cirlist 2));(pw::buffer-func '-  '(0.1 0.2 0.3) 2);==========================; SIMPLE FUNCTIONS;==========================;to operate on a list and returning a single value(DEFUN sum (list)     (apply '+ list))(DEFUN mean (list)     (/ (sum list) (length list)))(DEFUN pow2 (list)     (mean (buffer-func 'expt list 2)))(DEFUN rms (list)     (sqrt (pow2 list)));==========================; SIMPLE MASKS;==========================;to operate term-by-term on two lists(DEFUN average2 (val1 val2 &optional (weigth 2.0))    ;rename mean2  (/ (+ val1 val2) weigth))(DEFUN abs-max (val1 val2 &optional (weigth 0))       ;rename amax2  (max (abs val1) (abs val2) weigth))(DEFUN abs-min (val1 val2 &optional (weigth 1000))    ;rename amin2  (min (abs val1) (abs val2) weigth))(DEFUN power-product (val1 val2 &optional (weigth 2)) ;rename pow*2  (expt (* val1 val2) weigth))(DEFUN sqrt-product (val1 val2 &optional (weigth 2))  ;rename sqt*2  (expt (* val1 val2) (/ 1 weigth)));VARIANT DEFINITIONS;(DEFUN AV2 (val &optional (weigth 2) &rest vals);  (/ (apply '+ (cons val vals)) weigth))(DEFUN M-max (val &rest vals)  (apply 'max (cons val vals)))(DEFUN M-min (val &rest vals)  (apply 'min (cons val vals)))(DEFUN M-abs-max (val &rest vals)  (apply 'max (mapcar 'abs (cons val vals))))(DEFUN M-average2 (val &rest vals)  (/ (apply '+ (cons val vals)) (length (cons val vals))))(DEFUN M-abs-max (val &rest vals)  (apply 'max (mapcar 'abs (cons val vals))))(DEFUN M-abs-min (val &rest vals)  (apply 'min (mapcar 'abs (cons val vals))))(DEFUN M-power-product (val &rest vals)   (expt (apply '* (cons val vals)) 2))(DEFUN M-sqrt-product (val &rest vals)   (expt (apply '* (cons val vals)) 1/2));==========================; SIMPLE MATHS;==========================(DEFUN ilog (val &optional (base 2))  (if (= 1 base) 0.0 (realpart (log (zero! val 1) base))));to operate on one item only(DEFUN exp2 (val)  (* val val))(DEFUN log2 (val)  (ilog val 2))(DEFUN log10 (val)  (ilog val 10))(DEFUN alog2 (val)  (abs (ilog val 2)))(DEFUN alog10 (val)  (abs (ilog val 10)));==========================; GREATEST COMMON DIVISOR;==========================(DEFUN IC/ (list)  (apply 'gcd (g-round list)));==========================; LOOPING LISTS;==========================(defun range-func (func arg low high list)   (let (temp)    (for (i 0 1 (1- (length list)))      (if (<= low i high)        (push (funcall func arg (pop list)) temp)        (push (pop list) temp)))    (nreverse temp)))(DEFUN bends (fund factor vdata)     "power-scale vdata with factor in reference to fund"                (mapcar #'(lambda (x) (power x fund factor)) vdata))(DEFUN pans (pan base rank length)  "opposite pans of base+irank items"     (let (temp)       (for (i 0 1 (1- length))         (if (= 0 (rem (- i base) rank))         (push pan temp)         (push (- 1 pan) temp)))       (nreverse temp)))(DEFUN ranks (factor base rank list)"scales every base+irank item by factor"     (let (temp)       (for (i 0 1 (1- (length list)))         (if (= 0 (rem (- i base) rank))         (push (* (pop list) factor) temp)         (push (pop list) temp)))       (nreverse temp)));alternative(DEFUN ranks2 (factor base rank list)"scales every base+irank item by factor"    (progn       (for (i 0 1 (1- (length list)))          (if (= 0 (rem (- i base) rank))          (setf (nth (+ i base) list)                (* (nth (+ i base) list) factor))))       list));(ranks 0 0 2 '(1 2 3 4 5 6 7 8 9))(DEFUN newdebs (new-dur att-list)"subtracts atts from dur to prevent overlapps"   (buffer-func '- att-list new-dur));(newdebs 8.0 '(1 2 3 4));======================; END FILE : WORKBENCH;======================