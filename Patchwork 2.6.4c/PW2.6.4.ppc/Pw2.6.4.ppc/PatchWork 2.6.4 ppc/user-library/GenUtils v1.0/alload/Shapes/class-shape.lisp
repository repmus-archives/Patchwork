;=============================; NEW FILE : SHAPE CLASS          (HPST IRCAM 28/4/95);=============================#|    File that contains new and generalised shape class and sample methods|#;====================; SETUP ENVIRONMENT;====================  (in-package :GU);======================; DEFINE SIGNAL CLASS;======================(DEFCLASS C-SIGNAL-FUNCTION (c-gen) ; use C-GEN as inheritage class  ((sign-type :initform nil :initarg :sign-type :accessor sign-type)   (func-type :initform nil :initarg :func-type :accessor func-type)   (amp-pars  :initform nil :initarg :amp-pars  :accessor amp-pars)   (frq-pars  :initform nil :initarg :frq-pars  :accessor frq-pars)   (pha-pars  :initform nil :initarg :pha-pars  :accessor pha-pars)) )(DEFUN MAKE-SIGNAL-CLASS (sign-type func-type amp-pars frq-pars pha-pars)   "make module for the signal class"    (make-instance 'c-signal-function                   :sign-type sign-type                    :func-type func-type                   :amp-pars  (make-xbpf amp-pars)                    :frq-pars  (make-xbpf frq-pars)                    :pha-pars  (make-xbpf pha-pars)) );=======================; BASIC HELP FUNCTIONS;=======================(DEFUN DEEP-ONE (list)  (mapcar #'(lambda(item)              (if (numberp item) 1 (length item))) list))(DEFUN LONG? (list)   (g-max (deep-one list)))(DEFUN DEEP? (list)   (let* ((depths   (deep-one list)))         (gu::index (g-max depths) depths)))(defun swap (old new)  (declare (ignore old)) new)(DEFUN COPY-XLIST (tree list)  (epw::arith-tree-mapcar #'swap tree list));(copy-xlist '((100 200) (0 400) (500 0)) '(1 1))(DEFUN 2ITEM (val)  (list val val))(DEFUN SMEAR-ALL (&rest args);  (print args);REPLACE GET-Y-POINTS WITH AUTO-SAMPLE  (let* ( (ypnts  (get-y-points args))          (args   (if (numlistp ypnts) (cons (2item (pop ypnts)) ypnts) ypnts))          (maxid  (deep? args)) ) ;MUST BE SAFER!!!!! find id of longest list at any depth     (mapcar #'(lambda(arg)                  (let ((curr (position arg args))) ;find current position                   (if (= maxid curr) (nth curr args) ;if longest just return                       (copy-xlist (nth maxid args) arg)))) args))) ;else smear it;(gu::smear-all 3 2 1);(gu::smear-all '((49 0) (8 8)) '(3 5) 1);(gu::smear-bpf '(2 3 5) '((100 200) (0 400) (500 300) (100 0)) 0)(DEFUN MANY? (item)  (if (listp item) (length item) 1));ALTERNATIVE TO SMEAR-ALL (works also for SIGNALS);allows only numbers, list, 2lists, shapes, xshapes(DEFUN SMEAR-BPF (&rest args)  (let* ((bpfs (mapcar #'make-xbpf args))         (lens (mapcar #'many? bpfs))         (maxl (g-max lens)))    (mapcar #'(lambda(bpf len)                (if (listp bpf)                  (nconc bpf                         (make-list (- maxl len) :initial-element bpf))                  (cons bpf                        (make-list (- maxl len) :initial-element bpf)))) bpfs lens)));=======================; EVALUATE FUNCTIONS;=======================(DEFUN SIGN-FUN (sign time amp frq par)  (* amp (funcall sign time frq par)))(DEFUN PIN-FUN (ctrl time amp pin par)  (* amp (funcall ctrl (pining time pin) 1 par)))(DEFUN SEG0-FUN (segm time low high par)  (unit (funcall segm time 1 par) 0 1 low high))(DEFUN SEG1-FUN (segm time low high par)  (unit (funcall segm time 1 par) -1 1 low high));==================; SAMPLE SIGNALS;==================(DEFMETHOD SIGNAL-OUT ((self c-signal-function) &rest args)  ; args = '(fun sig times amps frqs phas);;  (declare (ignore self));;  (print args) (print "signal")  (signal-out (nth 0 args)            (func-type self)             (sign-type self)            (nth 0 args)            (nth 1 args)            (nth 2 args)            (nth 3 args)) )(DEFMETHOD GIVE-X-POINTS ((self c-signal-function))  (do-any (amp-pars self) #'give-x-points))(DEFMETHOD GIVE-Y-POINTS ((self c-signal-function))  (do-any (amp-pars self) #'give-y-points))#| does not pass each AMP,FRQ,PHA as it should(DEFMETHOD SAMPLE-TIME ((self c-signal-function) times)  "sample signal at points specified by a list of <times>;   if times is just a number then sample at number of y-points."   (epw::deep-mapcar/1 #'(lambda(amp frq pha)                           (print pha) (print "HEJ")                           (signal-out self times amp frq pha))                        (amp-pars self) (frq-pars self) (pha-pars self)) )|#(DEFMETHOD SAMPLE-TIME ((self c-signal-function) times)  "sample signal at points specified by a list of <times>;   if times is just a number then sample at number of y-points."    (if (or (listp (amp-pars self))            (listp (frq-pars self))           (listp (pha-pars self)))     (mapcar #'(lambda(amp frq pha)                           (signal-out self times amp frq pha))  ;SOLUTION UNTIL FURTHER!!!!            (amp-pars self) (frq-pars self) (pha-pars self))     (signal-out self times (amp-pars self) (frq-pars self) (pha-pars self))) )(DEFMETHOD SAMPLE-GRID ((self c-signal-function) grids)  "sample whole signal from begin to end evenly by <grid>;   if grid is zero then sample at number of y-points."  (sample-time self        (epw::deep-mapcar/1 #'(lambda(grid)                    (arithm-ser 0 (/ 1 (if (= 0 grid)                                         (long? (give-y-points self)) (abs grid))) 1)) grids)) );=============; END FILE;=============