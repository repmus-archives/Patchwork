;=============================; NEW FILE : SHAPE FUNCTIONS          (HPST Menilmontant 27/3/95);=============================#|     File that contains signal function wrapped to Patch-Work|# ;====================; DEFINE ENVIRONMENT;====================   (in-package :genutils);====================; SIGNAL FUNCTIONS ;====================#| NOT NEEDED ANYMORE(DEFUN DEEP-MAPFUN (fun list &rest args)  (mapcar #'(lambda(str args)                                      (apply #'epw::deep-mapcar/1 fun str args))          list (pw::mat-trans args)))|#(DEFUNP SIGNALS ( (amps fix/fl/list (:value 1.0))                  (frqs fix/fl/list (:value 1.0))                  (pars fix/fl/list (:value 0.0))                   (sign menu (:menu-box-list ( ("sinus"    . sinus)                                               ("cosinus"  . cosinus)                                               ("power"    . power)                                               ("slope"    . slope)                                               ("phasor"   . phasor)                                               ("triangle" . triangle)                                               ("square"   . square)                                               ("impuls"   . impuls)                                               ("window"   . window) )                                                :type-list (all-types))) ) all-types    "signal control module, that generates a signal function according to <menu>.     set <amp> to control magnitude, <frq> for number of periods, and <par> for phase.     Note that <par> for menu-choice <slope> and <power> controls exponential slopes.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the signal-types availabe & value ranges for <amps>,<frqs> & best <pars> are:    <sinus>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <cosinus>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <power>    = [-inf,+inf], [-inf,+inf], [-inf,+inf] (slope:1.0)    <slope>    = [-inf,+inf], [-inf,+inf], [-inf,+inf] (slope:1.0)    <phasor>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <triangle> = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <square>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <impulse>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (decay:1.0)    <window>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (edges:0.5)"  (let ( (all-args (smear-all amps frqs pars)) ) ;can be SMEAR-BPF as well    (make-signal-class sign #'sign-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )))(DEFUNP IMPULSES ( (amps fix/fl/list (:value 1.0))                   (frqs fix/fl/list (:value 1.0))                   (pars fix/fl/list (:value 0.0))                   (imps menu (:menu-box-list ( ("dirac"   . dirac)                                                ("impuls"  . impuls)                                                ("sinc"    . sinc)                                                ("cosc"    . cosc)                                                 ("neutron" . neutron))                                     :type-list (all-types)))) all-types    "impulse control module, that generates an impulse function according to <menu>.      set <amp> to control magnitude, <frq> for number of periods, and <par> for phase.     <dirac> is the 'perfect' impulse, <impuls> an exponetial one with an extreme decay,      sinc and cosc are lope-type impulses, and <neutron> a randomly scattered peak.     Take care that <frqs> and <time> resolution should best be multiples of eachother     to allow the internal detection of time=0 (start of impulse) to be optimal.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the impulse-types availabe & value ranges for <amps>,<pins> & best <pars> are:    <dirac>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <impuls>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (decay:1.0)    <sinc>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <cosc>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <neutron> = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (decay:1.0)"     (let ( (all-args (smear-all amps frqs pars)) )    (make-signal-class imps #'sign-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )))(DEFUNP TRANSIENTS ((amps fix/fl/list  (:value 1.0))                    (frqs fix/fl/list  (:value 1.0))                    (decs fix/fl/list  (:value 1.0))                    (expo menu (:menu-box-list ( ("e*sin" . esin)                                                 ("e*cos" . ecos)                                                 ("b+sin" . bsin)                                                 ("b+cos" . bcos)                                                 ("atsin" . atsin)                                                 ("atcos" . atcos)                                                 ("sinos" . sinos)                                                 ("sonis" . sonis) )                                      :type-list (all-types)))) all-types    "classic transient control module (adapted from S.Tempelaars) that generates an      exponential + signal function according to <menu>. all the functions exist in double      as a sin & cos pair, adding a an exponentially decaying envelope or signal to a carrier signal.      slope of decay is controlled by <pars>, and carrier signal by <amps> and <frqs>.      Note that phase is not available, but can be optained by adding an offset to output of one-time.     The general idea is that of generating functions with transitional behaviour.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the transient-types availabe & value ranges for <amps>,<pins> & best <decs> are:    <e*sin>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)    <e*cos>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)    <b+sin>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (beats:1.0)    <b+cos>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (beats:1.0)    <atsin>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)    <atcos>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)    <sinos>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)    <sonis>     = [-inf,+inf], [-inf,+inf], [0.0,+inf] (decay:1.0)"  (let ( (all-args (smear-all amps frqs decs)) )    (make-signal-class expo #'sign-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )));=====================; ENVELOPE FUNCTIONS;=====================(DEFUNP ENVELOPES ( (amps fix/fl/list (:value 1.0))                    (frqs fix/fl/list (:value 1.0))                    (pars fix/fl/list (:value 0.0))                    (wind menu (:menu-box-list ( ("hanning"   . hanning)                                                 ("hamming"   . hamming)                                                 ("window"    . window)                                                 ("rectangle" . rectangle) )                                      :type-list (all-types)))) all-types    "window control module, that generate a window function according to <menu>.      set <amp> to control magnitude, <frq> for number of periods, and <par> for phase.     Note that <hanning> and <hamming> are special cases of the general <window>,     and that <rectangle> can be made triangular by the control of <pars>.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the envelope-types availabe & value ranges for <amps>,<pins> & best <pars> are:    <hanning>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <hamming>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <window>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (alpha:0.5)    <rectangle> = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (width:0.5)"  (let ( (all-args (smear-all amps frqs pars)) )    (make-signal-class wind #'sign-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )))(DEFUNP PIN-POINTS ( (amps fix/fl/list (:value 1.0))                     (pins fix/fl/list (:value 0.5))                     (pars fix/fl/list (:value 1.0))                     (ctrl menu (:menu-box-list ( ("sinus"     . sinus)                                                  ("cosinus"   . cosinus)                                                                                                                                                    ("triangle"  . triangle)                                                  ("square"    . square)                                                  ("hanning"   . hanning)                                                  ("hamming"   . hamming)                                                   ("window"    . window)                                                  ("rectangle" . rectangle))                                       :type-list (all-types)))) all-types    "envelope control module that generates 1 period of a function according to <menu>;     set <amp> in any range to control magnitude, <par> in the range [0,1] to control phase,      and <pin> in the range [0,1] to control the position of the center axis, called the 'pin-point'.      if <pin> is close to 0, the resulting curve will tend to fall left-wards (fast attack),     while being close to 1 it will tend rigth-wards (soft attack, fast decay). when set to     0.5 the chosen function will be unaffected. meant to easely create a family of envelopes.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the pin-point-types availabe & value ranges for <amps>,<pins> & best <pars> are:    <sinus>     = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <cosinus>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <triangle>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <square>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <hanning>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <hamming>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <window>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (alpha:0.5)    <rectangle> = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (width:0.5)"   (let ( (all-args (smear-all amps pins pars)))    (make-signal-class ctrl #'pin-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )))(DEFUNP SEGMENTS ( (lows  fix/fl/list (:value 0.0))                   (highs fix/fl/list (:value 1.0))                   (pars  fix/fl/list (:value 1.0))                   (segm menu (:menu-box-list ( ("sinus"    . sinus)                                                ("cosinus"  . cosinus)                                                ("power"    . power)                                                ("slope"    . slope)                                                ("phasor"   . phasor)                                                ("triangle" . triangle)                                                ("square"   . square)                                                ("impuls"   . impuls)                                                 ("window"   . window) )                                     :type-list (all-types)))) all-types    "segment control module that generates 1 period of a function according to <menu>;     the function scales to lie in the range of <low> <high> with phase set by <pars>;     more segments can be joined to make a function lay inside moving boundaries.     Ouput is a signal object and are normally fed to one of the time modules for sampling.      For that use please refer to the online help and tutorials.     the segment-types availabe & value ranges for <lows>,<highs> & best <pars> are:    <sinus>    = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <cosinus>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <power>    = [-inf,+inf], [-inf,+inf], [-inf,+inf] (slope:1.0)    <slope>    = [-inf,+inf], [-inf,+inf], [-inf,+inf] (slope:1.0)    <phasor>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <triangle> = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <square>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (phase:0.0)    <impulse>  = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (decay:1.0)    <window>   = [-inf,+inf], [-inf,+inf], [0.0,1.0]   (edges:0.5)"   (let ( (all-args (smear-all lows highs pars))          (seg-fun  (if (or (eq segm 'sinus) (eq segm 'cosinus)) 'seg1-fun 'seg0-fun)))    (make-signal-class segm seg-fun         (nth 0 all-args) (nth 1 all-args) (nth 2 all-args) )));====================; OTHER GENERATORS;====================(DEFUNP DEVIATIONS ( (dist menu (:menu-box-list ( ("random"      . x-ran0)                                                  ("linear"      . x-lin)                                                  ("exponential" . x-pon)                                                  ("triangular"  . x-tri)                                                  ("arcsin"      . x-asin)                                                  ("hypercos"    . x-hcos)                                                  ("gauss"       . x-gauss)                                                  ("beta"        . x-beta) )                                       :type-list (all-types)))                       (devia   fix/fl/list (:value 1.0))                      &optional                     (param   fix/fl/list (:value 0.5)) ) all-types    "deviation control module picking a random value according of <menu>,      in the range of <devia> (usually = 1) with optional <param> for beta;     the distribution-types availabe are:     <random>      = uniform distribution, such that 0 < x =< devia     <linear>      = linear distribution of parameter <devia>     <exponential> = variant on exponential distribution of density <devia>     <triangular>  = triangular distribution of average <devia>     <arcsin>      = arc sinus distribution of parameter <devia>     <hypercos>    = hyperbolic cosinus distribution of parameter <devia>     <gauss>       = variant on gaussian distribution, that never passes <devia>     <beta>        = beta distribution of parameters <devia> and <param> (extend module).                     for <devia> = <param> = 1 the result is a uniform distribution,                      for <devia> and <param> greater than 1 the result is similar to <gauss>.     Ouput is a list & for more elaborate information on distribution functions,      please refer to the 'PW-alea' library or the online help and tutorials."    (let* ( (devia    (epw::deep-mapcar/1 #'zero! (auto-sample devia)))           (param    (epw::deep-mapcar/1 #'zero! (auto-sample param) 1)))  (if (eq dist 'x-beta)   (epw::arith-tree-mapcar #'(lambda(v1 v2) (funcall dist v1 v2)) devia param)    (epw::deep-mapcar/1 dist devia)) ))  ;SHOULD RETRUN A BPF???(DEFUNP TIME-MASKS ( (list1 list)                     (list2 list)                     (mask  menu (:menu-box-list ( ("max±2" . m-max)                                                   ("min±2" . m-min)                                                   ("mean2" . m-average2)                                                   ("amax2" . m-abs-max)                                                   ("amin2" . m-abs-min)                                                   ("pow*2" . m-power-product)                                                    ("sqt*2" . m-sqrt-product))                                        :type-list (all-types))) ) all-types    "mask control module, that apply a function according to <menu> to <list1> and <list2>,     on a item-to-item basis (the lists may be of any but preferably of equal structure).     The idea is to 'merge' 2 lists in a way the retains aspects of both of them, fx.     taking the maximum of 2 'peaky' control function would be a way to combine them.                  the mask-types are:     <max±2> = take the abs/neg maximum of the 2 values     <min±2> = take the abs/neg minimum of the 2 values     <mean2> = take the average of the 2 values     <amax2> = take the absolute maximum of the 2 values     <amin2> = take the absolute minimum of the 2 values     <pow*2> = take the power 2 of the product of the 2 values     <sqt*2> = take the square root of the product of the 2 values     Ouput is a list. For more please refer to the online help and tutorials."   (let* ( (all-args (smear-all list1 list2))           (list1    (pop all-args))           (list2    (pop all-args))           (mlength  (max (ylength list1) (ylength list2))) )      (epw::arith-tree-mapcar #'(lambda(v1 v2) (funcall mask v1 v2))                             (grid-sample list1 mlength) (grid-sample list2 mlength))) );======================; NORMALISATIONS;======================(DEFUN TARGET-UNITS (type list)  "determine target y-min,y-max of <list> according to <type>."  (cond ((eq type 'norm)  '(0 1))          ((eq type 'unit)  '(-1 1))            ((eq type 'invs)  (list (g-fun 'g-max list) (g-fun 'g-min list)))        ((eq type 'shift) (list 0 (- (g-fun 'g-max list) (g-fun 'g-min list))))        ((eq type 'self)  (list (- 0 (abs (g-fun 'g-max list))) (abs (g-fun 'g-max list))))        ((eq type 'intgs) (list 0 1000))        ((eq type 'none)  (list (g-fun 'g-min list) (g-fun 'g-max list)))        (t '(0 1) )))(DEFUNP UNITS ( (list  list)                (unit  menu (:menu-box-list ( ("norm"  . norm)                                              ("unit"  . unit)                                              ("invs"  . invs)                                              ("shift" . shift)                                              ("intgs" . intgs)                                              ("self"  . self)                                              ("none"  . none))))                &optional                (y*min  fix/float (:value 1.0))                (y*max  fix/float (:value 1.0)) ) all-types    "scale <list> of (almost) anything to a <min>/<max>-range set according to <menu>;          the scaling-types availabe are:     <norm>  = classic normalisation in the range [0,1]     <unit>  = normalisation in the unit range [-1,1]     <invs>  = inversion by scaling ymin,ymax to the range [ymax,ymin]     <shift> = shift list to positive range only by scaling [0,ymax-ymin]     <intgs> = scale list to interger range [0,1000] fit for bpfs     <self>  = scale list symmetrically around zero in the range [-ymax,ymax]     <none>  = return list unaltered     the module can be extended to include a <y*min> and a <y*max> scaling factor.     Ouput is a list. For more please refer to the online help and tutorials."            (let* ( (list    (auto-sample list))           (units   (target-units unit list)) )     (epw::deep-mapcar/1 #'unit list (g-fun 'g-min list)                                     (g-fun 'g-max list)                                     (* y*min (first  units))                                     (* y*max (second units)))) )#| LEAVE OUT(DEFUNP XNORM ((list list)              (norm fix/float)) list    "normalises <list> on each side of zero to -norm and +norm"     (let ((ymin (abs (apply 'min list))) (ymax (apply 'max list)))      (mapcar #'(lambda(y) (* norm (/ y (if (< y 0) ymin ymax)))) list)) )|#;========================= ; SIGNAL MANIPULATIONS;========================= #| Functions moved to FILTERS(DEFUNP PHASE-SHIFTER ( (signal fix/fl/list (:value 1.0))                         (phase  fix/fl/list (:value 0.0)) ) all-types      "shift any oscilation with any phase (-1,+1)"           (epw::arith-tree-mapcar #'phase-shift signal phase) )(DEFUNP FRQ-SHIFTER ( (sig1 fix/fl/list (:value 1.0))                       (sig2 fix/fl/list (:value 0.0)) ) all-types     "convolve two simple signals (-1,+1)"     (epw::arith-tree-mapcar #'frq-shift sig1 sig2) )|#  ;===================; ENERGY MEASURE      (based on recursive functions);===================(DEFUNP FORCE ((bpf     list   (:value "()" :type-list (bpf list)))                 (points fix>=0 (:value 2))                 (measure menu  (:menu-box-list ( ("sum"  . sum)                                                 ("mean" . mean)                                                 ("pow2" . pow2)                                                 ("rms"  . rms) )                                      :type-list (all-types)))                (iterations fix>0) ) list  "return measure of average force in <bpf> over <points> items at each item,   according to type of <measure>; function repeat <iterations> many times.   Note that for each iteration <bpf> will be reduced by <points-1> items,   meaning that <iterations>*<points-1> should not be > than length of <bpf>.   Input to <bpf> can be (almost) anything, and output is a shortend list."  (let* ( (xpnts (get-x-points bpf))          (ypnts (get-y-points bpf))          (min-x (first xpnts))          (max-x (last  xpnts))          (min-y (first ypnts))          (max-y (last  ypnts)) )            (if (> iterations 0)    (force     (make-bpf (x-append min-x (energy xpnts points measure 2) max-x)               (x-append min-y (energy ypnts points measure 2) max-y))     points measure (1- iterations)) bpf)))(DEFUNP ITERATOR ((bpf        list  (:value "()" :type-list (bpf list)))                  (iterations fix/fl/list (:value 2))                  (function   menu  (:menu-box-list ( ("mean2" . average2)                                                      ("amax2" . abs-max)                                                      ("amin2" . abs-min)                                                      ("pow*2" . power-product)                                                       ("sqt*2" . sqrt-product))                                           :type-list (all-types)))                  (weigths    fix/fl/list (:value 2))                  &optional                  (permut     menu (:menu-box-list ( ("circular" . permut-circ)                                                     ("randomly" . permut-random)                                                     ("reversed" . reverse-list)                                                     ("inversed" . inverse-list)                                                     ("x-points" . get-x-points)                                                     ("copyself" . copy-list))                                          :type-list (all-types) ))) list    "funny recursive function, that apply a <function> on a   term-by-term basis to a <bpf> and a permutated copy of itself.    The action is repeated <iterations> number of times, the results    being accumulated, with the last result used for successive    applications of the function. The user can write new functions   provided that they take the parameters <val1> <val2> and   optionally also the parameter <weigth>, used internally    for eg. some scaling purpose. The module is extensible,   to include a menu <permut> of choises of how to permutate the list,   eg. circular, randomly, reverse, inverse. It is meant for forcing    a special tendency on a multiple copy of a list, as fx. going    towards max or min only, mean, square, sum, select, etc...   Input to <bpf> can be (almost) anything, and output is an accummulated list."  (let* ( (list       (get-y-points bpf))          (maxelm     (fun-length (list (make-xlist list 1 1) iterations weigths)))          (allist     (make-xlist list 1 maxelm))           ;is it a double list?          (iterations (make-xlist iterations 0 maxelm))     ;is it a single list?          (weigths    (make-xlist weigths 0 maxelm))        ;is it a single list?          (permut     (if (numberp permut) 'permut-circ permut)) )          (mapcar    #'averager allist (g-round iterations)                               (cirlist function) weigths (cirlist permut))) );===================; END FILE;===================