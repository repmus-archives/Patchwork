;============================; NEW FILE : TRANSFER STUFF              (HPST 10/05/95 IRCAM);============================#|    File that contains various utillities and applicated ways of using BPF's    so as functions to insert a bpf in another BPF, binding a BPF to a range, etc...|#  ;=====================; DEFINE ENVIRONMENT;=====================  (in-package :genutils);=====================; INSERT XY-POINTS;=====================(DEFUN 2NUM-INSERT (x y xlist ylist) (let* ( (xlist  (copy-seq xlist))         (ylist  (copy-seq ylist))         (xy-id  (search (list x) xlist :test '>=)) ) ; equal to search-higher            (progn     (if (not xy-id) ; means that val is larger than largest item          (setf xlist (append xlist (list x)))         (setf (nth xy-id xlist) (list x (nth xy-id xlist))))     (if (not xy-id) ; means that val is larger than largest item          (setf ylist (append ylist (list y)))         (setf (nth xy-id ylist) (list y (nth xy-id ylist))))          (list (flat xlist) (flat ylist)))));(2num-insert 31 49 '(0 50 100) '(0 100 0))(DEFUNP XY-INSERT ( (xs    fix/fl/list (:value '(0 50 100))) ;MAIN INSERT FUNCTION                    (ys    fix/fl/list (:value '(0 100 0)))                    (xlist list (:value '(0 50 100)))                    (ylist list (:value '(1 100 1))) ) list  "non-destructive function that makes a sorted insert of <xs>,<ys> into <xlist> and <ylist>"  (let ( (list (list (copy-seq (list! xlist))                      (copy-seq (list! ylist)))) )    (if (noteq (first list) (second list)) (error "xy-list are of uneven length!")    (epw::arith-tree-mapcar #'(lambda (x y)                 (setq list (2num-insert x y (first list) (second list))))                            xs ys)) list));(xy-insert '(31 62) '(-5 49) '(0 50 100) '(0 100 0));===============; SPLIT BPF;===============(DEFUN INSERT-BPF   (bpf xy-bpf xval width magnitude)  (let* ( (envel   (grid-sample (envelopes magnitude 1.0 0.0 'hanning) (ylength bpf)))          (xlist   (x-points bpf))                    (prev-x  (min xval (max (- xval (/ width 2))                         (nth (search-lower xval xlist) xlist))))          (next-x  (max xval (min (+ xval (/ width 2))                         (nth (search-higher xval xlist) xlist))))          (ylist   (time-sample bpf (list prev-x next-x)));;         (xy-bpf  (car (bind-bpf xy-bpf (list prev-x next-x) envel)))         (xy-bpf  (car (bind-bpf xy-bpf ylist envel)))           (xy-list (xy-insert (g-scaling (x-points xy-bpf) prev-x next-x)                              (y-points xy-bpf)                               (x-points bpf)                                  (y-points bpf))) )          (make-bpf (flat (first xy-list)) (flat (second xy-list)) 1)) )(DEFUNP SPLIT-BPF  ( (bpf       list (:value "()" :type-list (bpf list)))                     (xy-bpf    list (:value "()" :type-list (bpf list)))                     (anchor    fix/fl/list (:value 25))                     (width     fix/fl/list (:value 5))                      (magnitude fix/fl/list (:value 1)) ) all-types        "insert <xy-bpf> into <bpf> at x-position <anchor>; x-range of <xy-bpf> is          scaled to fit within <anchor> plus-minus <width>/2, while y-range is scaled          to <magintude> before being added to an interpolation between previuos and next y-points;          This way one is garuenteed that end-points will meet, so that insertion will be smooth.          Note that when inserting outside of existing x-domain, the module calculates         a linear extrapolation from limit values to achieve new y-values."  (let* ( (maxl        (fun-length (list anchor width magnitude (list! xy-bpf))))          (xy-bpfs     (fun-list xy-bpf maxl))          (xvals       (fun-list anchor maxl))          (widths      (fun-list width maxl))          (magnitudes  (fun-list magnitude maxl)) )    (mapcar #'(lambda (xy-bpf xval width magnitude)                 (setq bpf                (insert-bpf bpf xy-bpf xval width magnitude)))             xy-bpfs xvals widths magnitudes) bpf));===============; NEW BIND ...;===============(DEFUNP BIND-BPF  ( (bpfs-list  list (:value "()" :type-list (bpf list)))                    (axis-list  list (:value "()" :type-list (bpf list)))                     (width-list list (:value "()" :type-list (bpf list))) ) all-types        "function to 'hang' a <bpfs-list> each around a time-evolving <axis-list>,         degree of deviation determined by a time-evolving <width-list>.         The general effect is a bpf scaled inside moving boundaries,         if bws = 0 a linear interpolation between frqs occurs.";A BETTER LENGTH CHECK : what if some sub lists are of unequal length?         (let* ((x-min       (g-fun #'g-min (get-x-points bpfs-list)))                (x-max       (g-fun #'g-max (get-x-points bpfs-list)))                (all-bpfs    (smear-bpf bpfs-list axis-list width-list)) );OUTER LOOP : melt all times and scale to dur                    (mapcar #'(lambda (bpf-vals axis-vals width-vals);CALCULATE Y-RANGE                      (let* ( (y-min     (g-min (give-y-points bpf-vals)))                              (y-max     (g-max (give-y-points bpf-vals)));SCALE ALL X-POINTS TO DURS                                                            (xs-bpf    (g-scaling (give-x-points bpf-vals) x-min x-max))                              (xs-axis   (g-scaling (give-x-points axis-vals) x-min x-max))                              (xs-width  (g-scaling (give-x-points width-vals) x-min x-max));RESET ALL X-LISTS NEW DUR                              (bpf-vals  (make-bpf xs-bpf (give-y-points bpf-vals)))                              (axis-vals  (make-bpf xs-axis (give-y-points axis-vals)))                                                            (width-vals  (make-bpf xs-width (give-y-points width-vals)));REUNION ALL TIME-POINTS                               (all-times (rem-dups (sort-list (flat (list xs-bpf xs-axis xs-width))))) );MAKE A FLOAT BPF FOR OUTPUT : find a enable/disable mechanism                   (make-bpf all-times  ;INNER LOOP : interpolate within bandwidth                                      (mapcar #'(lambda (time)               ; sample each bpf before doing UNIT scaling                                                 (let* ((val  (bpf-out bpf-vals time xs-bpf 1))                                                        (axis  (bpf-out axis-vals time xs-axis 1))                                                        (width  (bpf-out width-vals time xs-width 1)))            ; unit scale each val to ± width/2                                                   (unit val y-min y-max (- axis (/ width 2))                                                                          (+ axis (/ width 2))))) all-times)))  )                            (nth 0 all-bpfs) (nth 1 all-bpfs) (nth 2 all-bpfs))));==============================; GENERAL INTERPOLATION MODULE   (adapted from L.Pottier);==============================(DEFUNP SLIDE-BPF ( (source-bpf list (:value "()" :type-list (bpf list)))                    (target-bpf list (:value "()" :type-list (bpf list)))                     (transi-bpf list (:value "()" :type-list (bpf list))) ) all-types        "Interpolate from <source-bpf> to <target-bpf> according to <trans-bpf>";A BETTER LENGTH CHECK : what if some sub lists are of unequal length?         (let* ((all-bpfs (smear-bpf source-bpf target-bpf transi-bpf)) );OUTER LOOP : melt all times and scale to dur                    (mapcar #'(lambda (bpf-beg bpf-end bpf-int);CALCULATE Y-RANGES                      (let* ( (x-min     (g-min (give-x-points bpf-beg)))                              (x-max     (g-max (give-x-points bpf-beg)))                              (y-min     (g-min (give-y-points bpf-int)))                              (y-max     (g-max (give-y-points bpf-int)));SCALE ALL X-POINTS TO DURS                                                            (xs-beg    (g-scaling (give-x-points bpf-beg) x-min x-max))                              (xs-end    (g-scaling (give-x-points bpf-end) x-min x-max));REUNION ALL TIME-POINTS                               (all-times (rem-dups (sort-list (flat (list xs-beg xs-end)))));RESET ALL X-LISTS NEW DUR                              (bpf-beg   (make-bpf xs-beg (give-y-points bpf-beg)))                              (bpf-end   (make-bpf xs-end (give-y-points bpf-end))) ) ;MAKE A FLOAT BPF FOR OUTPUT : find a enable/disable mechanism                   (mapcar #'(lambda(point)                               (make-bpf all-times  ;INNER LOOP : interpolate within bandwidth                                (mapcar #'(lambda (time)                                           (unit point y-min y-max                                                 (bpf-out bpf-beg time xs-beg 1)                                                (bpf-out bpf-end time xs-end 1))) all-times)))                            (give-y-points bpf-int))))                           (nth 0 all-bpfs) (nth 1 all-bpfs) (nth 2 all-bpfs))));==============================; GENERAL DISTRIBUTION MODULE    (adpated from M. Malt and L. Polard);==============================(DEFUNP DENSE-BPF ( (bounds  list (:value "()" :type-list (bpf list)))                    (density list (:value "()" :type-list (bpf list)))                    (source  list (:value "()" :type-list (bpf list)))                    (target  list (:value "()" :type-list (bpf list))) ) all-types        "A distribution module with variable boundaries, density and distribution form.Input to <bounds> 2 bpfs for high and low boundaries respectivly. The number ofunique x-points in those 2 bpfs will determine the number of distributions sampled.Subsequently sub-divide the low/high-range of <bounds> in as many steps as given at that point in the <density>. The actual distribution or interval-form in each subdivision is controlled by interpolating from <source> to <target>."  (let* ( (hi     (first bounds))           (lo     (second bounds));FIND X-RANGE OF DENSITY                                        (xs-den (give-x-points density))          (x-min  (g-min xs-den))          (x-max  (g-max xs-den));SCALE ALL X-POINTS TO DURS                                        (xs-lo  (g-scaling (give-x-points lo) x-min x-max))          (xs-hi  (g-scaling (give-x-points hi) x-min x-max))                     ;RESET ALL X-LISTS NEW DUR          (bpf-lo (make-bpf xs-lo (give-y-points lo)))          (bpf-hi (make-bpf xs-hi (give-y-points hi)))                    ;REUNION ALL TIME-POINTS           (times  (rem-dups (sort-list (flat (list xs-lo xs-hi)))) );MAKE INTERPOLATED DISTRIBUTIONS           (slides (first (slide-bpf source target (make-bpf times times)))) );MAKE A FLOAT BPF FOR OUTPUT : find a enable/disable mechanism    (mapcar #'(lambda (time slide)                (g-scaling (sample-grid slide                            (bpf-out density time xs-den 1))                                     (bpf-out bpf-lo  time xs-lo  1)                           (bpf-out bpf-hi  time xs-hi  1))) times slides)) );===============; END FILE;===============