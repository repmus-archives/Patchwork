;============================; NEW FILE : ALL CLASS STUFF              (HPST 4/05/95 IRCAM);============================#|    File that contains various general utillities applicable for all classes|#  ;=====================; DEFINE ENVIRONMENT;=====================  (in-package :genutils);====================; TIME FUNCTIONS ;====================(DEFUN EXPTIME (incr factor)  (* (signum incr) (expt (abs incr) (abs factor))))(DEFUN TIME/n (n off flag) ;if n : over whole range  (pw::dx->x off (make-list n :initial-element (/ flag n))))(DEFUN TIME/1 (grids signs &optional (factor 1))  (epw::deep-mapcar/1 #'exptime        (epw::deep-mapcar/1 #'time/n grids (first signs) (second signs)) factor))(DEFUNP ONE-TIME ( (grids fix/fl/list (:value 100))                    (time  menu (:menu-box-list ( ("forward"  . (0  1))                                                 ("backward" . (1 -1))                                                 ("reverse"  . (0 -1))                                                 ("inverse"  . (-1 1)) )))                   &optional                   (factor fix/float (:value 1.0))                    (unit   fix/float (:value 1.0))) all-types    "time module ramping in <grids> steps, ranges set by the <time> menu:    <forward> [0,1], <backward> [1,0], <reverse> [0,-1], <inverse> [-1,0].     allows for exponential ramps when extended, where <factor> set to 1     will result in linear ramps, less than 1 = acc, larger than 1 = rit.     the module is meant to feed <time> parameter of signal modules.     finally an optional <unit> allows for scaling of result to <unit>."           (g* unit (time/1 grids time factor)));==========================; GENERAL SAMPLE FUNCTIONS    ;PUT OUTPUT INTO MAKE-XBPFS ?;==========================(DEFUNP TIME-SAMPLE ((objs  symbol  (:value "()"))                      (times fix/fl/list (:value 0))) all-types   "sample <objs> in the x-range at points given by <times>,  <times> migth be a number or a list of any depth and order.   sampling outside of the x-range forces output to end-points."  (do-any objs #'sample-time times));(epw::deep-mapcar/1 #'(lambda(obj) (sample-time obj times)) objs)(DEFUNP GRID-SAMPLE ((objs  symbol  (:value "()"))                      (grids fix/fl/list (:value 10))) all-types   "sample <objs> evenly over the whole x-range in <grids> steps,  <grids> migth be a number or a list of any depth and order, reflected in the output."  (do-any objs #'sample-grid grids))(DEFUNP AUTO-SAMPLE ((objs symbol (:value "()"))) all-types   "auto sample <objs> at gcd-interval of x-points.   may take a while if x-points are very scattered."  (do-any objs #'sample-auto))(DEFUNP GET-X-POINTS ((objs symbol (:value "()"))) all-types   "get all x-points from <objs>"  (do-any objs #'give-x-points))(DEFUNP GET-Y-POINTS ((objs symbol (:value "()"))) all-types   "get all y-points <objs>"  (do-any objs #'give-y-points));=============; MAKE CURVE;=============(DEFUNP MAKE-CURVE ( (xlist fix/fl/list (:value 10))                     (ylist list (:value '(100 200)))                      (c-key menu (:menu-box-list (("spline"  . spline)                                                  ("blend"   . blend)                                                  ("matrix"  . matrix)                                                  ("hermite" . hermite)                                                  ("bezier"  . bezier))                                       :type-list (all-types)))                     (plist menu (:menu-box-list (("hermite" . hermite)                                                  ("parabol" . parabol)                                                  ("bspline" . bspline)                                                  ("catmull" . catmull)                                                  ("tension" . tension))                                       :type-list (all-types))) ) all-types  "global make of a CURVE function according to <c-key>;   if input is just a <ylist> then <xlist> is an interval (as with bpf),   otherwise <xlist> and a <ylist> should be of equal lengths.   for the use of menu <plist> please refer to the tutorials."  (init-curve c-key (make-tlist xlist ylist) (make-vlist ylist) (eval plist)) );=============; MAKE SIGNAL   ;=============(DEFUNP MAKE-SIGNAL ( (amps fix/fl/list (:value 1.0))                      (frqs fix/fl/list (:value 1.0))                      (pars fix/fl/list (:value 0.0))                       (sign menu (:menu-box-list ( ("sinus"     . sinus)                                                   ("cosinus"   . cosinus)                                                   ("power"     . power)                                                   ("slope"     . slope)                                                   ("phasor"    . phasor)                                                   ("triangle"  . triangle)                                                   ("square"    . square)                                                   ("impuls"    . impuls)                                                   ("hanning"   . hanning)                                                   ("hamming"   . hamming)                                                   ("window"    . window)                                                   ("rectangle" . rectangle)                                                    ("dirac"     . dirac)                                                   ("impuls"    . impuls)                                                   ("sinc"      . sinc)                                                   ("cosc"      . cosc)                                                    ("neutron"   . neutron)                                                    ("e*sin"     . esin)                                                   ("e*cos"     . ecos)                                                   ("b+sin"     . bsin)                                                   ("b+cos"     . bcos)                                                   ("atsin"     . atsin)                                                   ("atcos"     . atcos)                                                   ("sinos"     . sinos)                                                   ("sonis"     . sonis) )                                        :type-list (all-types))) ) all-types    "general make module for all signal types"     (let ( (all-args (smear-all amps frqs pars)) )    (make-signal-class sign  #'sign-fun                (nth 0 all-args) (nth 1 all-args) (nth 2 all-args)) ));=============; MAKE xBPFs   ;=============(DEFUNP MAKE-BPF ((tlist list (:value '(-1 1)))                   (vlist list (:value '(-1 1)))                  &optional                  (logs  menu (:value 10                               :menu-box-list (("log10" . 10)                                                ("log2"  . 2)                                               ("none"  . 1))))) all-types      "make a floating break point function from <tlist> and <vlist>;     for floating points to be seen, points are internally scaled     to a range choosen by (optional) menu (xy-points are unaffected):     write 10 or choose <log10> : scales to [-1000,1000] (default)     write  2 or choose <log2>  : scales to [-16383,16383]     write  1 or choose <none>  : no scaling."  (make-bpf-class (make-tlist tlist vlist) (make-vlist vlist) logs) )(DEFUNP MAKE-XBPF ((thing symbol (:value "()"))) all-types     "auto make xBPFs according to type of <thing>"  (do-any thing #'make-dummy-bpf));===============; REDUCE POINTS        (HPST Menilmontant 6/6/95)   ;===============;uses file: functions:complex.lisp;;;(gu::rad2deg (second (apply 'gu::cart2polar (gu::c- 5 6 7 8)))(DEFUN CALC-PHASE (p1 p2)  "calculate angle in degrees from xy-points <p1> & <p2>"  (rad2deg (second (cart2polar      (- (first p2) (first p1))     (- (second p2) (second p1)))))) (DEFUN CALC-ANGLES (bpf)  "calculate phase differences between points in <bpf>"  (let* ((xs   (x-points bpf))         (ys   (y-points bpf))          (all  (mat-trans (list xs ys)))         (prev (first all))          new)    (mapcar #'(lambda(curr)                                (setf new (calc-phase curr prev)                      prev curr) (cons new curr)) all)))#|(DEFUN REDUCE-ANGLES (degs thresh) ; 0<degs> = a list of phase-points = (phase x y)  "reduce points in <degs> that has an angle less than <tresh>"  (let* ((degs (calc-angles degs))         (prev (first degs))           new)     (apply #'make-bpf (mat-trans       (append (list (cdr prev))              (mapcan #'(lambda(curr)                          (setf new (if (> thresh (abs (- (car curr) (car prev))))                                      nil (list (cdr prev))))                          (setf prev curr) new) (cdr degs))               (list (cdar (last degs))))))))(DEFUNP REDUCER  ((bpfs   list (:value "()" :type-list (bpf list)))                  (thresh fix/float (:value 1))) all-types  "reduce number of points in <bpfs> by eliminating adjacent points,   that has an angle less than <tresh>; start & end are always kept."  (do-any (make-xbpf bpfs) #'reduce-angles thresh))|#(DEFUN REDUCE-XY-DATA (bpf degree time floor) ; 0<degs> = a list of phase-points = (phase x y)  "reduce points in <degs> that has an angle less than <degree>,   OR a x-interval less than <time> AND an y-value less than <floor>."  (let* ((degs (calc-angles bpf))         (prev (first degs))           new);output data reduction in a BPF     (apply #'make-bpf (mat-trans;always append (first point) result (last point)      (append (list (cdr prev))              (mapcan #'(lambda(curr);test1 : is phase difference less than degree?                          (setf new (if (<= degree (abs (- (first curr) (first prev))));test2 : is y's less-or-equal to floor AND x-interval less-or-equal to time?;should (third curr) and (third prev) be abs?                                      (if (and (< floor (third curr)) (< floor (third prev))                                             (> time (abs (- (second curr) (second prev)))));if test2 is true: average xy-point                                     (list (list (/ (+ (second curr) (second prev)) 2)                                              (/ (+ (third  curr) (third  prev)) 2)));if test1 is true: return previous point, else return nil = eliminate point                                        (list (cdr prev)))));update for next iteration : store current point into previous                         (setf prev curr) new) (cdr degs))               (list (cdar (last degs))))))))(DEFUNP REDUNDANCE  ((bpfs   list (:value "()" :type-list (bpf list)))                     (degree fix/float (:value 1))                     (time   fix/float (:value 1))                     (floor  fix/float (:value 0))) all-types  "remove redundant data from <bpfs> by eliminating adjacent points,   that has an angle less than <degree>,   OR a x-interval less than <time> AND an y-value less than <floor>.   start & end are always kept.   usefull in conjunction with the module FORCE"  (do-any (make-xbpf bpfs) #'reduce-xy-data degree time floor))#| SOME TESTS FOR ISABELLE(in-package :GU);(substitute 0 100 '(12 120 150 11 480 65) :test #'>=);(substitute 0 100 '(12 120 150 11 480 65) :test #'<);match source to lo or hi and sample (DEFUN MAKE-BORDER (origine object)  (match-bpf origine (make-xbpf object) 1))(DEFUN CLIPTO (value low high)  (max (min value (max high low)) (min low high)) )(DEFUN CLIPTO-DATA (source lo-bpf hi-bpf) ; all off equal x's  (let* ((lo-match (sample-time lo-bpf (x-points (make-border source lo-bpf))))         (hi-match (sample-time hi-bpf (x-points (make-border source hi-bpf))))         (sub-points (mapcar #'clipto (y-points source) lo-match hi-match)))    (make-bpf-class (x-points source) sub-points))) (DEFUNP BORDERS  ((bpfs list (:value "()" :type-list (bpf list)))                  (low  list (:value "()" :type-list (bpf list)))                  (high list (:value "()" :type-list (bpf list)))) all-types  "clip data in <bpfs> to lie within the range given by <low> & <high>."  (do-any (make-xbpf bpfs) #'clipto-data (make-xbpf low) (make-xbpf high)))(DEFUN REDUCE-TIME-DATA (bpf times)   "reduce points in <bpf> that has a x-interval less than <time>.   iterate for optimal result."  (let* ((times  (sample-time times (x-points (make-border bpf times))))         (points (mat-trans (list (xs (x-points bpf))                                  (ys (y-points bpf)))))         (prev (first points)))    (mapcan #'(lambda(curr time)                (list (setf prev                        (if (> time (abs (- (first curr) (first prev))))                         (list (/ (+ (first curr)  (first prev)) 2)                               (/ (+ (second curr) (second prev)) 2)))                       curr))) points times)))(DEFUNP TIMERS  ((bpfs list (:value "()" :type-list (bpf list)))                 (times  list (:value "()" :type-list (bpf list))) all-types  "average data in <bpfs> that has a x-interval less than <times>."  (do-any (make-xbpf bpfs) #'reduce-time-data (make-xbpf times)));MAKE A 3 STEP REDUCTION:; according to (variable?) degree; according to lo-hi variable borders; according to variable time-interval ;========================; MASKING LIKE FUNCTION;========================(DEFUN BINDTO (value bound limit)  (if (> value bound) value limit) )(DEFUN LIMIT-DATA (source bound limit)  (let* ((bound-match (sample-time bound (x-points (make-border source bound))))         (limit-match (sample-time limit (x-points (make-border source limit))))         (sub-points  (mapcar #'bindto (y-points source) bound-match limit-match)))    (make-bpf-class (x-points source) sub-points))) (DEFUNP CLIPPER  ((bpfs  list (:value "()" :type-list (bpf list)))                  (bound list (:value "()" :type-list (bpf list)))                  (limit list (:value "()" :type-list (bpf list))) all-types  "force data in <bpfs> that is higher than <bound> to <limit>."  (do-any (make-xbpf bpfs) #'limit-data (make-xbpf bound) (make-xbpf limit)))|#;===========; END FILE;===========