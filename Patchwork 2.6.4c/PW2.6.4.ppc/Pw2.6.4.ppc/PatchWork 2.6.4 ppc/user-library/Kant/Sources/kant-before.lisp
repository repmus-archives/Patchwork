;;;;=========================================================;;;;  KANT PATCH-WORK;;;;  Rep. Mus.;;;;  © 1994 IRCAM ;;;;=========================================================(in-package "C-PATCH-BOX-KANT")(defun tolerant-gcd (values grid-ratio)  "floating gcd with grid tolerance grid-ratio around the values."  (labels ((grid-above (val) (* val (1+ grid-ratio)))           (grid-below (val) (- val (* val grid-ratio)))           (gcd-try (values gcd-min gcd-max)             (when (<= gcd-min gcd-max)               (ifnot values                 (/ (+ gcd-min gcd-max) 2.0)                 (let* ((val-below (grid-below (first values)))                        (val-above (grid-above (first values)))                        (quo-min (ceiling (/ val-below gcd-max)))                        (quo-max (floor (/ val-above gcd-min))))                   (do* ((quotient quo-min (1+ quotient)) (gcd-interval))                        ((> quotient quo-max) nil)                     (setf gcd-interval                           (gcd-try (rest values)                                         (max gcd-min (/ val-below quotient))                                         (min gcd-max (/ val-above quotient))))                     (when gcd-interval                       (return-from gcd-try gcd-interval))))))))    (setf values (sort  (remove-duplicates values :test '=) '<=))    (gcd-try values .1 (grid-above (apply 'min values)))))(defun tolerant-gcd2 (values grid-ratio)  "floating gcd with grid tolerance grid-ratio around the values."  (labels ((grid-above (val) (* val (1+ grid-ratio)))           (grid-below (val) (- val (* val grid-ratio)))           (gcd-try (values gcd-min gcd-max)             (when (<= gcd-min gcd-max)               (ifnot values                      (/ (+ gcd-min gcd-max) 2.0)                 (let* ((val-below (grid-below (first values)))                        (val-above (grid-above (first values)))                        (quo-min (ceiling (/ val-below gcd-max)))                        (quo-max (floor (/ val-above gcd-min)))                        (ratio 1.0))                   ;(format t  " ------------------ value: ~S quomin: ~S quomax: ~S ~%" (first values) quo-min quo-max)                   (when  (< quo-max quo-min)                     (setf quo-min  (ceiling (/ val-below (/ gcd-max 2)))                           quo-max (floor (/ val-above (/ gcd-min 2))))                     ;(format t "half reducing ~S gcd-min : ~S gcd-max ~S ~%" (first values)                     ;        (/ gcd-max 2) (/ gcd-max 2))                     ;stocker flag                     (setf ratio 2.0))                   (do* ((quotient quo-min (1+ quotient)) (gcd-interval))                        ((> quotient quo-max) nil)                                           ;(format t  " value: ~S quotient: ~S gcd-min: ~S gcd-max: ~S ~%" (first values) quotient                      ;       (max gcd-min (* ratio (/ val-below quotient)))                     ;        (min gcd-max (* ratio (/ val-above quotient))))                                          (setf gcd-interval                           (gcd-try (rest values)                                         (max gcd-min (* ratio (/ val-below quotient)))                                         (min gcd-max (* ratio (/ val-above quotient)))))                     (when gcd-interval                       (return-from gcd-try gcd-interval))                     ;(print 'fail)                     ))))))    (setf values (sort  (remove-duplicates values :test '=) '<=))    (gcd-try values .1 (grid-above (apply 'min values)) )))(defun tolerant-gcd3 (values grid-ratio)  "floating gcd with grid tolerance grid-ratio around the values."  (labels ((grid-above (val) (* val (1+ grid-ratio)))           (grid-below (val) (- val (* val grid-ratio)))           (gcd-try (values gcd-min gcd-max div-list)             (when (<= gcd-min gcd-max)               (ifnot values                      (list (/ (+ gcd-min gcd-max) 2.0) div-list)                 (let* ((val-below (grid-below (first values)))                        (val-above (grid-above (first values))))                   ;(format t  " ------------------ value: ~S quomin: ~S quomax: ~S ~%" (first values) quo-min quo-max)                   (do ((gcd-divisor 1 (1+ gcd-divisor))) ((> gcd-divisor 3) nil)                     (let ((quo-min (ceiling (/ val-below (/ gcd-max gcd-divisor))))                           (quo-max (floor (/ val-above (/ gcd-min gcd-divisor)))))                       (do* ((quotient quo-min (1+ quotient)) (gcd-interval))                            ((> quotient quo-max) nil)                                                  ;(format t  " value: ~S quotient: ~S gcd-min: ~S gcd-max: ~S ~%" (first values) quotient                          ;       (max gcd-min (* ratio (/ val-below quotient)))                         ;        (min gcd-max (* ratio (/ val-above quotient))))                                                  (setf gcd-interval                               (gcd-try (rest values)                                        (max gcd-min (* gcd-divisor (/ val-below quotient)))                                        (min gcd-max (* gcd-divisor (/ val-above quotient)))                                        (cons gcd-divisor div-list)))                         (when gcd-interval                           (return-from gcd-try gcd-interval)) ))))))))    (setf values (sort   values  '<=))    ;(setf values (sort  (remove-duplicates values :test '=) '<=))    (gcd-try values .1 (grid-above (apply 'min values)) nil)))(defun verif-gcd (values gcd)  (mapcar #'(lambda (val)              (list val                    (/ val gcd)                    ;(/ (round (* 100 (/ val gcd))) 100.0)                    ;(round (* 100 (1- (/ val (* (round val gcd) gcd)))))))                    (1- (/ val (* (round val gcd) gcd)))))          values))(defun list! (element) (if (listp element) element (list element)));aaa 94(defun reduce-event-list (ev-list)  (let* ((inter-list  (events->intervals ev-list 'onset)))       (mapc #'(lambda (x) (setf (nth 1 (source x)) (value x))) inter-list)       (intervals->events  inter-list)))         (defun mk-event (onset dur voice-nb weight) (if (< dur 0)   (list onset dur voice-nb weight t )   (list onset  dur voice-nb weight nil)))(defun mk-event2 (onset dur voice-nb weight pitch velocity) (if (< dur 0)   (list onset dur voice-nb weight t pitch velocity)   (list onset  dur voice-nb weight nil pitch velocity)))(defun onset (event &optional value) (when value (setf (first event) value)) (first event))(defun vrai-dur (event) (second event))(defun voice (event) (third event))(defun weight (event  &optional value) (when value (setf (fourth event) value)) (fourth event))(defun silence (event) (fifth event))(defun pitch (event) (sixth event))(defun velocity (event) (seventh event))(defun dur (event) (abs (second event)))(defun value (interval) (first interval))(defun value-vrai (interval)          (if (silence (source interval)) (* -1 (first interval)) (first interval)))(defun source (interval) (second interval))(defun destination (interval) (third interval))(defun magnitude (peak) (second peak))(defun event-dims (event dims)  (mapcar #'(lambda (dim) (funcall dim event)) (list! dims)))(defun select (list dims test &rest params)  "selects elements for which dims + params pass the test"   (remove-if-not #'(lambda (element)                     (apply test                             (nconc (event-dims element dims) params)))                 list))(defun modify (list dim modifier &rest params)  (mapc #'(lambda (element)            (funcall dim                      element                     (if (functionp modifier)                       (apply modifier (funcall dim element) params)                       modifier)))        list)  list)(defun collecte (ev-list dims)  "collects the dimensions dims in ev-list"  (ifnot (listp dims)    (mapcar dims  ev-list)    (mapcar #'(lambda (event) (event-dims event dims))            ev-list)))(defun project (ev-list dims)  "projects (no duplicates) the dimensions dims in  ev-list"    (remove-duplicates (collecte ev-list dims) :test 'equal))(defun mk-interval (event1 event2 dim)  (list (- (funcall dim event2) (funcall dim event1)) event1 event2))(defun events->intervals (ev-list dim)  "makes a list of intervals on one dimension (dime(e1)-dim(e2) e1 e2)"  (mapcar #'(lambda (ev1 ev2) (mk-interval ev1 ev2 dim))          ev-list           (rest ev-list)))(defun intervals->events (intervals)  "rebuild the list of events that where involved in intervals"  (remove-duplicates    (mapcan #'(lambda (interval)               (list (source interval) (destination interval)))           intervals)   :test 'equal))(defun merge-intervals (intervals min)  (ifnot (rest intervals)         intervals    (if (>= (caar intervals) min)      (cons (car intervals) (merge-intervals (cdr intervals) min))      (cons (list (+ (caar intervals) (caadr intervals))                  (cadar intervals)                  (caddr (cadr intervals)))            (merge-intervals (cddr intervals) min)))));aaa(defun mk-event-list (polyphony list-pitch list-velo)  "builds a list of events from a list of list of durations"  (let* ((onset 0) (voice-nb -1) (weight 0)         (list-max (mapcar #'(lambda (voice) (apply '+  (mapcar #'abs  voice))) polyphony))         (dur-max (apply 'max list-max))         (i 0)        )    (mapc #'(lambda (maxi) (progn              (if (< maxi dur-max)                (setf (nth i polyphony) (reverse (cons (- maxi dur-max) (reverse (nth i polyphony))))))              (setf i (+ i 1)))) list-max)    (if (and list-pitch list-velo)    (sort     (append      (mapcan #'(lambda (voice pitch velo)                  (setf onset 0.0 weight 10)                  (incf voice-nb)                  (mapcar #'(lambda (dur pit vel)                              (prog1                                (mk-event2 onset dur voice-nb weight pit vel)                                (incf onset (abs dur))                                (setf weight 0)))                          voice pitch velo))              polyphony list-pitch list-velo)      (do* ((j -1 (1+ j))            ;;; should change the duration dim.            (stop-events () (cons (mk-event2 dur-max 0 j 10 6000 100) stop-events)))           ((>= j voice-nb) (nreverse stop-events))))     '< :key 'onset)    (sort     (append      (mapcan #'(lambda (voice)                  (setf onset 0.0 weight 10)                  (incf voice-nb)                  (mapcar #'(lambda (dur)                              (prog1                                (mk-event onset dur voice-nb weight)                                (incf onset (abs dur))                                (setf weight 0)))                          voice))              polyphony)      (do* ((j -1 (1+ j))            ;;; should change the duration dim.            (stop-events () (cons (mk-event dur-max 0 j 10) stop-events)))           ((>= j voice-nb) (nreverse stop-events))))     '< :key 'onset))))(defun coupe (event-list max) (mapcan #'(lambda (ev)             (if (> (+ (onset ev) (dur ev)) max)               (list (mk-event (onset ev) (- max (onset ev))  (voice ev)  (weight ev)  ))               )) event-list))(defun find-peaks (values)  "computes a list of peaks (position magnitude) in a value list"  (let ((prev-val -1000) next-val cur-val peaks (i 0))    (while values      (setf cur-val (pop values)            next-val (or (first values) 0))      (when (and (> cur-val prev-val) (> cur-val next-val))        (push (list i (/ (+ (- cur-val prev-val) (- cur-val next-val)) 2.0))              peaks))      (setf prev-val cur-val i (1+ i)))    ; should have a special first event with silence to generate a peak on the first interval.    (nreverse peaks)))(defun find-transitions (values threshold)  (let (trans-list         (max-value (apply 'max values))        (min-value (apply 'min values)))    (labels ((scale (x) (/ (- x min-value) (- max-value min-value))))      (do* ((first 0.5 (pop values))            (second (first values) (first values))            (index 0 (1+ index)))          ((null values))        (when (> (abs (- (scale second) (scale first))) threshold)          (push (list index (- (scale second) (scale first))) trans-list)))      (nreverse trans-list))))(defun transition-curve (values trans-list)   (let ((curve (make-list (length values) :initial-element 0)))    (mapc #'(lambda (transition)              (replace curve                        (list (nth (first transition) values))                       :start1 (first transition) :end1 (1+ (first transition))))          trans-list)    curve))(defun transitions1 (values threshold)  (transition-curve values (find-transitions values threshold)))(defun transitions2 (values threshold)  (let ((transitions (find-transitions values threshold))        (curve (make-list (length values) :initial-element -1.0)))    (mapc #'(lambda (transition)              (replace curve                        (list (abs (second transition)))                       :start1 (first transition) :end1 (1+ (first transition))))          transitions)    curve))    (defun select-pos (list positions)  "select elements matching a list of positions"  (mapcar #'(lambda (n) (nth n list)) positions))(defun mk-segmentation (ev-list intervals)  "groups events following intervals. -> a list of lists of events"  (maplist #'(lambda (interval)              (select ev-list                      'onset                      (if (null (rest interval))                        #'(lambda (o)                            (and (>= o (onset  (source (first interval))))                                 (<= o (onset (destination (first interval))))))                      #'(lambda (o)                          (and (>= o (onset  (source (first interval))))                               (< o (onset (destination (first interval)))))))))          intervals))(defun average (&rest list)  (/ (apply '+ list) (length list)))(defun is-a-big-peak (a b c)  (and (> b a)       (> b c)       (or (> (/ b a) 2)           (> (/ b c) 2))))(defun is-a-peak (a b c)  (and (>= b a) (>= b c)))(defun smooth (list order)  (dotimes (i order)    (setf list (smooth2 list)))  list)(defun smooth2 (list)  (let (a b c newlist (list `(,(/ (+ (first list) (second list)) 2.0)  ,.list                               ,(/ (+ (first (last (butlast list))) (first (last list))) 2.0))))    ;(print list)    (while (cddr list)      (setf a (pop list) b (first list) c (second list))      (setf b (float (average a b c)))      ;(setf (first list) b)      (push b newlist))    (nreverse newlist)    ))(defun fold (values)  (let ((min (apply 'min values)) (max (apply 'max values)))    (epw::g-scaling (epw::g-abs (epw::g-scaling values -1.0 1.0)) min max)))(defun mk-aficha (poly-lis)    (let ((eve-lis (mk-event-list poly-lis nil nil)) chor)          (mapcar           #' (lambda (lista)               (progn                   (setf chor (pw::Chbuild  (+ 6000 (* 700 (voice lista))) (list (vrai-dur lista))  (list (onset lista)) (list (+ (voice lista) (weight lista)))))                   (setf (pw::t-time chor) (onset lista))                    chor)) eve-lis)))(defun get-archimes (event-list from to dims voix)  (let* ((lis1 (make-list  voix  :initial-element  nil))         (to2 (if (null (nth to event-list)) (- (length event-list) 1) to))         (ev-list (subseq event-list from to2)))    (mapc #'(lambda (mes)              (push (funcall dims mes) (nth (voice mes) lis1))) ev-list)    (mapcar #'(lambda (mes)                (reverse mes)) lis1)))    