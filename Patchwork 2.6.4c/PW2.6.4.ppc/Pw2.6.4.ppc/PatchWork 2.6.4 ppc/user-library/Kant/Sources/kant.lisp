;;;;=========================================================;;;;  KANT PATCH-WORK;;;;  Rep. Mus.;;;;  © 1994 IRCAM ;;;;=========================================================(in-package "C-PATCH-BOX-KANT")(import '(epw::flat-once ))(in-package :pw)(defun  put-notes-graces (objs)  (let* ((chords (construct-chords  (list! '(6000))))         measures chord-objects)    (setq measures (get-measure-object objs))    (unless (listp measures) (setq measures (list measures)))    (setf (measures objs) measures)    (setq chord-objects           (ask-all (collect-all-chord-beat-leafs objs) 'beat-chord))    (setq chords (put-in-grace-notes (extra-measure-stuff (car measures)) chords))    (dolist (chord chords)      (unless chord-objects (return nil))      (setf (notes (car chord-objects)) (notes chord))      (update-chord (pop chord-objects)))    objs))(in-package "C-PATCH-BOX-KANT");=================== Menu qua================================(defmethod do-default ((self C-MN-view-mod-kant))  (let ((dialog (make-instance 'dialog :window-show nil :view-size #@(285 200)                                :window-type :double-edge-box                                :view-position (ccl:make-point 100 200)))        (totmax (make-instance 'pw::radio-button-dialog-item                       :view-position (make-point 26 40)                       :dialog-item-text "Max-T"                       :view-font '("monaco" 9 :srcor)                       :dialog-item-action                       #'(lambda(item) (declare (ignore item)) (setf (tot-or-rel self) 1))))        (relmax (make-instance 'pw::radio-button-dialog-item                       :view-position (make-point 110 40)                       :dialog-item-text "Max-R"                       :view-font '("monaco" 9 :srcor)                       :dialog-item-action                       #'(lambda(item) (declare (ignore item)) (setf (tot-or-rel self) 2)))))        (add-subviews dialog                  (slot-value self 'forbid)                  totmax relmax                   (make-dialog-item 'static-text-dialog-item (make-point 42 80) (make-point 40 16) "Forbid" nil :view-font '("monaco" 9 :srcor))                  (slot-value self 'maxi)                  (make-dialog-item 'static-text-dialog-item (make-point 42 60) (make-point 40 16) "Preci" nil :view-font '("monaco" 9 :srcor))                  (slot-value self 'preci)                  (slot-value self 'cancel-button)                   (make-instance 'pw::button-dialog-item                    :default-button t                    :dialog-item-text "OK"                    :view-position (make-point 80 150)                    :view-size (make-point 40 23)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (return-from-modal-dialog ()))))    (modal-dialog dialog)))(defmethod do-forbid ((self C-MN-view-mod-kant))  (if (null (forbid-list self))    (let* ((measures   (list-of-mes self))           (n (length measures)))      (setf (forbid-list self) (make-list  n  :initial-element "def"))))  (setf (cambio-par self) 31)             (view-draw-contents self))(defmethod do-preci ((self C-MN-view-mod-kant))  (if (null (preci-list self))    (let* ((measures (list-of-mes self))           (n (length measures)))      (setf (preci-list self) (make-list  n  :initial-element  "def"))))  (setf (cambio-par self) 32)             (view-draw-contents self))(defmethod do-max ((self C-MN-view-mod-kant))  (if (null (max-list self))    (let* ((measures (list-of-mes self))           (n (length measures)))      (setf (max-list self) (make-list  n  :initial-element  "def"))))  (setf (cambio-par self) 33)             (view-draw-contents self));esta funcion tiene guevo hay que volver a escribirla;porque esta muy chambona(defmethod chan-tempi ((self C-MN-view-mod-kant) les-tempi lis-tempi)  (let* ((valide t) listemp)    (mapc #'(lambda (ca ca1)              (if (null ca)                (if (null (read-from-string (dialog-item-text ca1)))                  (push nil listemp)                  (setf valide nil))                (if (> (abs (- ca (read-from-string (dialog-item-text ca1)))) 5)                  (setf valide nil)                  (push (read-from-string (dialog-item-text ca1)) listemp))))  les-tempi lis-tempi)    (if valide      (progn        (setf listemp (reverse listemp))        (mapc  #'(lambda (ca1 ca2 ca3)                   (if (not (eq ca1 ca2))                     (progn                       (setf (nth 0 ca3) (mapcan #'(lambda (mes)                                                     (list  (mapcan #'(lambda (mes2)                                                                        (list (* (/ ca1 ca2) mes2))) mes))) (nth 0 ca3)))                       (setf (nth 2 ca3) ca2)))                   ) les-tempi listemp  (reverse (rep-seg self)))        (setf (entre3 self) (copy-tree (entre2 self)))        (setf (rep-m2 self) (reverse (rep-seg self)))        (let ((r 0)  lis1 lis2 lis22 lis3 lis4 rep)          (mapcan #'(lambda (lis)                      (prog1                        (setf lis1 (concatenate 'list lis1 (list (car lis))))                        (setf lis22 (concatenate 'list lis22 (list (cadr lis))))                        (setf lis2 (concatenate 'list lis2  (cadr lis)))                        (setf lis4 (cons (fourth lis) lis4 ))                        (let* (( longi (length (cadr lis)))                               (nlis (if (listp (caddr lis)) (caddr lis) (make-list longi :initial-element (caddr lis)))))                          (setf lis3 (concatenate 'list    lis3  nlis))))) (rep-m2 self))          (setf lis4 (reverse lis4))          ;(setf (list-of-mes self) (butlast  (mk-merge (resume-m2 self) (reverse (list-of-mes self)))))          (setf lis1                (let* (rep1)                  (while (< r (length (entre2 self)))                     (let* ((acu 0))                      (setf r (+ r 1))                      (setf rep nil)                      (mapc #'(lambda (c d)                                (progn                                  (if (null (selection-m1 self) )                                    (progn                                      (replace (nth (- r 1) (entre3 self)) (nth (- r 1) c) :start1 acu)                                      (setf acu (+ acu (length (nth (- r 1) c))))                                      )                                    (replace (nth (- r 1) (entre3 self)) (nth (- r 1)  c) :start1                                              (position (nth (caaar  (entre-m2 self)) (collecte (mk-event-list (entre2 self) nil nil) 'onset))                                                        (collecte (mk-event-list (list (nth (- r 1) (entre3 self))) nil nil) 'onset) :test #' <=)  ))                                  (when  d                                    (setf rep (concatenate 'list rep (nth (- r 1) c)))))) lis1 lis22)                      (setf  rep1 (cons rep rep1))))                  rep1))          (setf lis1 (reverse lis1))          (setf (compaces self) nil)          (let ((co 0))            (mapc #'(lambda (c)                      (progn                        (setf (compaces self) (mk-merge (compaces self) (mk-beat self  c co  lis4 (nth 2 (nth co (rep-m2 self))))))                        (incf co )))  lis22))          (setf (rep-m2 self)   (list lis1 lis2 lis3))          )        (setf (pw::chords (pw::chord-seq (papa self)))               (butlast (mk-aficha  (entre3 self)) (length (entre3 self))))        (mapc #'(lambda (mes) (pw::update-all-notes mes)) (editor-objects self))        (setf (ant-size self) 0)        (view-draw-contents self))      (progn (ed-beep) (print "a big difference of tempo"))))  (return-from-modal-dialog ()))(defmethod fun-tempi ((self C-MN-view-mod-kant))  (let* ((i 0) lis-tempi les-tempi temp dialog)        (setf lis-tempi (mapcan  #'(lambda (ca)                                 (progn                                   (setf i (+ i 1))                                   (setf temp (copy-tree (list (third ca))))                                   (setf  les-tempi (cons (third ca) les-tempi))                                   (list (make-dialog-item 'editable-text-dialog-item (make-point 10 (* 30 i))                                                            (make-point 40 16) (format () "~A" (car temp)) nil :view-font '("monaco" 9 :srcor)))))                              (reverse (rep-seg self))))    (setf les-tempi  (reverse les-tempi))    (setf i (- i 1))    (setf dialog (make-instance 'dialog :window-show nil :view-size (ccl::make-point 110 (+ (* i 30) 100))                                 :window-type :double-edge-box                                 :view-position (ccl:make-point 100 200)))    (add-subviews dialog (make-dialog-item 'static-text-dialog-item (make-point 10 6) (make-point 100 16) "LIST OF TEMPI" ))    (mapc #'(lambda (ca) (add-subviews dialog ca)) lis-tempi)    (add-subviews dialog                  (make-instance 'pw::button-dialog-item                       :default-button ()                       :dialog-item-text "cancel"                       :view-position (make-point  62 (+ (* i 30) 63))                       :view-size (make-point 45 23)                       :dialog-item-action                       #'(lambda(item) (declare (ignore item)) (return-from-modal-dialog nil)))                   (make-instance 'pw::button-dialog-item                    :default-button t                    :dialog-item-text "OK"                    :view-position (make-point 5 (+ (* i 30) 65))                    :view-size (make-point 40 18)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (chan-tempi self les-tempi lis-tempi))))        (modal-dialog dialog)))  (defmethod fun-forbid ((self C-MN-view-mod-kant))(let ((x (view-nick-name (selected-par self))))  (if (or (listp (read-from-string (dialog-item-text (slot-value self 'forb2)))) (equal (dialog-item-text (slot-value self 'forb2)) "def"))       (progn        (setf (elt (forbid-list self) x)  (dialog-item-text (slot-value self 'forb2)))        (setf (cambio-par self) 31))      (progn (print "Sintaxe error")             (ed-beep)))      (return-from-modal-dialog ())))(defmethod fun-max ((self C-MN-view-mod-kant))(let ((x (view-nick-name (selected-par self))))  (if (or (numberp (read-from-string (dialog-item-text (slot-value self 'maxi2))))           (listp (read-from-string (dialog-item-text (slot-value self 'maxi2))))          (equal (dialog-item-text (slot-value self 'maxi2)) "def"))    (progn      (setf (elt (max-list self) x)  (dialog-item-text (slot-value self 'maxi2)))      (setf (cambio-par self) 33))    (progn (print "Sintaxe error")             (ed-beep)))      (return-from-modal-dialog ())))(defmethod fun-preci ((self C-MN-view-mod-kant))  (let ((x (view-nick-name (selected-par self))))    (if (or (numberp (read-from-string (dialog-item-text (slot-value self 'preci2))))             (listp (read-from-string (dialog-item-text (slot-value self 'preci2))))            (equal (dialog-item-text (slot-value self 'preci2)) "def"))      (progn        (setf (elt (preci-list self) x)  (dialog-item-text (slot-value self 'preci2)))        (setf (cambio-par self) 32))      (progn (print "Sintaxe error")             (ed-beep)))    (return-from-modal-dialog ())))(defmethod do-chosen-action ((self C-MN-view-mod-kant))   (case (act-num self)               (3 (fun-forbid self ))              (4 (fun-preci self ))              (5 (fun-max self ))              (6 (fun-m2 self ))              (9 (fun-pat self ))))(defun del-def (lista valor) (if (listp lista)    (mapcar #' (lambda (mes)               (if (symbolp mes)                  (read-from-string valor) mes)) lista)    lista))(defun operat (ma divi)  (if (listp ma)      (mapcan #' (lambda (ma1 )                   (list (operat ma1 divi))) ma)      (let ((rep (if (zerop divi) 1 (floor ma divi))))        (if (<= rep 1)          2 rep))))        (defun mk-rel-max (max mesu-list)  (mapcan #' (lambda (ma mes)               (let ((divi (/ (second mes) 4.0)))                 (list (operat ma divi)))) max mesu-list));;; GA 17/10/94(defmethod Quanti ((self C-MN-view-mod-kant))   (let* ((durs  (car (rep-m2 self)))         (measures (cadr (rep-m2 self)))         (tempi    (caddr (rep-m2 self)))         (gmax (dialog-item-text (slot-value self 'maxi)))         (gpreci (dialog-item-text (slot-value self 'preci)))         (gforbid (dialog-item-text (slot-value self 'forbid)))         (max   (if (null (max-list self)) (setf (max-list self) (make-list  (length (list-of-mes self))  :initial-element  "def"))))         (max   (mapcan #' (lambda (mes)                                 (list (list (if (equal mes "def") (read-from-string gmax)                                                  (del-def (read-from-string mes) gmax))))) (max-list self)))         (max (if (eq (tot-or-rel self) 1)  max (mk-rel-max max measures)))         (preci   (if (null (preci-list self)) (list (list (read-from-string gpreci)))                      (mapcan #' (lambda (mes)                                   (list (list (if (equal mes "def") (read-from-string gpreci)                                                   (del-def (read-from-string mes) gpreci))))) (preci-list self))))         (forbid   (if (null (forbid-list self)) (read-from-string gforbid)                       (mapcan #' (lambda (mes)                                    (list (if (equal mes "def") (read-from-string gforbid)                                              (del-def (read-from-string mes) gforbid)))) (forbid-list self))))         (evento-lista (mk-event-list (entre3 self) (entre2-pitch self) (entre2-velo self)))         (voces (length (entre self))))    (setf (sortie self)  (reverse (mapcan #' (lambda (mes)                                                (list (pw::quantify mes tempi measures max forbid 0 preci))) durs)))    (mapc #'(lambda (mes)              (pw::put-notes-graces mes)) (sortie self))    (if (and (selection-m1 self) (not (= 0 (selection-m1 self))))      (progn        (setf (entre3-pitch self)              (get-archimes evento-lista                               (nth (selection-m1 self) (resume-m1 self)) (nth (+ (selection-m1 self) 1) (resume-m1 self)) 'pitch voces))        (setf (entre3-velo self)              (get-archimes evento-lista                               (nth (selection-m1 self) (resume-m1 self)) (nth (+ (selection-m1 self) 1) (resume-m1 self)) 'velocity voces)))      (let ((y 0)            (lisp (make-list  voces  :initial-element  nil))            (lisv (make-list  voces  :initial-element  nil)) respuep respuev)        (mapc  #'(lambda (ca)                   (if (not (null (third ca)))                     (progn                       (push (get-archimes evento-lista (nth y (resume-m1 self)) (nth (+ y 1) (resume-m1 self)) 'pitch voces) respuep)                       (push (get-archimes evento-lista (nth y (resume-m1 self)) (nth (+ y 1) (resume-m1 self)) 'velocity voces) respuev)))                   (incf y))               (reverse  (rep-seg self)))        (mapc  #'(lambda (mesp mesv)                   (let* ((z 0))                     (while (< z voces)                       (setf (nth z lisp) (concatenate 'list (nth z lisp) (nth z mesp)))                       (setf (nth z lisv) (concatenate 'list (nth z lisv) (nth z mesv)))                       (incf z)))) (reverse respuep) (reverse respuev))        (setf (entre3-pitch self) lisp)        (setf (entre3-velo self) lisv)                              ))    (mapcar #'(lambda (line-mes line-pitch line-velo)                (let ((co 0))                  (mapcar #'(lambda (mes)                              (mapcar #'(lambda (sem)                                          (setf co  (ponga-pitch sem line-pitch line-velo co)))                                      (pw::beat-objects mes)))                          (pw::measures line-mes))))             (sortie self) (reverse (entre3-pitch self)) (reverse (entre3-velo self)))    (let* ((n (length (sortie self)))           (editor (pw::make-n-rtm-editors-window n  (sortie self))))      (window-select editor)      (pw::edit-rtm-editor-transpose-global editor  0))));;; GA 17/10/94(defun ponga-pitch (beat pitch-list velo-list i)  (if (not (null (pw::beat-chord  beat)))    (mapc #'(lambda (mes)              (progn                 (while (and (nth i pitch-list) (= 0 (nth i pitch-list)))                  (incf i))                (when (nth i pitch-list) (setf (pw::midic mes)  (nth i pitch-list)))                (when (nth i velo-list) (setf (pw::vel mes)  (nth i velo-list)))                (incf i)))           (sort (copy-list (pw::notes (pw::beat-chord beat))) '< :key 'pw::offset-time))    (mapcar #'(lambda (sem2)                (setf i (ponga-pitch sem2 pitch-list velo-list i)))            (pw::rtm-list beat)))  i)(defun conc-measure-line (line1 line2)  (list (make-instance 'pw::C-measure-line     :measures (concatenate 'list (pw::measures line1) (pw::measures line2)))));========================Menu ARCH===================================================(defmethod do-bpf ((self C-MN-view-mod-kant))  (let ((num 0)        (dialog (make-instance 'dialog :window-show nil :view-size #@(210 80)                                :window-type :double-edge-box                                :view-position (ccl:make-point 100 200))))    (add-subviews dialog                  (make-dialog-item 'static-text-dialog-item (make-point 10 10) (make-point 60 16) "Duration" nil :view-font '("monaco" 9 :srcor))                  (make-dialog-item 'static-text-dialog-item (make-point 10 30) (make-point 60 16) "Pitchs" nil :view-font '("monaco" 9 :srcor))                  (make-dialog-item 'static-text-dialog-item (make-point 10 50) (make-point 60 16) "Velocity" nil :view-font '("monaco" 9 :srcor))                  (make-instance 'pw::radio-button-dialog-item                    :view-position (make-point 90 10)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (setf num 0)))                  (make-instance 'pw::radio-button-dialog-item                    :view-position (make-point 90 30)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (setf num 1)))                  (make-instance 'pw::radio-button-dialog-item                    :view-position (make-point 90 50)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (setf num 2)))                  (make-instance 'pw::button-dialog-item                       :default-button ()                       :dialog-item-text "cancel"                       :view-position (make-point 138 40)                       :view-size (make-point 60 25)                       :dialog-item-action                       #'(lambda(item) (declare (ignore item)) (return-from-modal-dialog nil)))                   (make-instance 'pw::button-dialog-item                    :default-button t                    :dialog-item-text "OK"                    :view-position (make-point 140 8)                    :view-size (make-point 55 23)                    :dialog-item-action                    #'(lambda(item) (declare (ignore item)) (fun-bpf self num))))    (modal-dialog dialog)))(defmethod fun-bpf ((self C-MN-view-mod-kant) num)  (let* ((labpf (case num                  (0 (bpf self))                  (1 (bpf-p self))                  (2 (bpf-v self)))))    (if (null labpf)      (let*  ((event (mk-event-list (entre self) (entre-pitch self) (entre-velo self)))               (lis1 (mapcar #' (lambda (mes)                                 (round mes (case num (0 1) (1 100) (2 1)))) (collecte (reduce-event-list event) (case num (0 'dur) (1 'pitch) (2 'velocity)))))              (lis2 (mapcar #' (lambda (mes)                                 (round mes)) (collecte (reduce-event-list event) 'onset))))        (setf labpf  (pw::make-BPF-edi (pw::make-break-point-function lis2 lis1)                                       'C-bpf-kant (view-container self) (case num (0 "Duration") (1 "Pitch") (2 "Velocity"))))        (setf (kant-ob (pw::BPF-editor-object labpf)) self)        (case num          (0  (setf (bpf self) labpf))          (1  (setf (bpf-p self) labpf))          (2  (setf (bpf-v self) labpf)))))    (pw::BPF-editor-object labpf)    (window-select labpf)    (return-from-modal-dialog ())))                                       ;=========================================================; Parametro arbitrario 10 OJO hacer una posible heuristica;=========================================================(defmethod mk-repm1 ((self C-MN-view-mod-kant) entrada entre-pitch entre-velo)  (setf (entre2-pitch self) (copy-tree entre-pitch ))  (setf (entre2-velo self) (copy-tree entre-velo ))  (setf (rep-m1 self)        (let* ((minimo 10)               (marca (copy-tree (resume-m1 self)))               (event-list (mk-event-list entrada nil nil))               (durs (collecte event-list 'onset))                (lista1                (let* ((k -1))                  (mapcan #'(lambda (lis )                              (declare (ignore lis))                              (setf k (+ k 1))                              (list (let* ((list-voix (select event-list 'voice '= k))                                           (list-voix-on   (collecte list-voix 'onset))                                           (list-voix-dur  (collecte list-voix 'vrai-dur) )                                           (i 1))                                      (mapcan #'(lambda ( mes1)                                                  (let* ((rep nil)                                                         (valor (onset (nth  mes1 event-list)))                                                         ti pos-ini j)                                                    (setf pos-ini (position (nth (nth  (- i 1) marca) durs) list-voix-on :test #'<=) )                                                    (setf ti   (position  valor list-voix-on :test #'<=))                                                    (setf rep  (subseq list-voix-dur pos-ini  ti))                                                    (setf j (- (length rep) 1))                                                    (if (> (nth ti list-voix-on) valor)                                                      (progn                                                         (setf (nth j rep) (* (if (< (nth j rep) 0) -1 1)  (- (abs (nth j rep)) (- (nth ti list-voix-on) valor))))                                                        (if (> (- (nth ti list-voix-on) valor) minimo)                                                          (progn                                                            (if (> (- (nth ti list-voix-on) valor) 0)                                                              (progn                                                                (setf (nth k (entre2-pitch self)) (inserte (nth k (entre2-pitch self)) (nth (- ti 1) (nth k (entre2-pitch self))) ti))                                                                (setf (nth k (entre2-velo self)) (inserte (nth k (entre2-velo self)) (nth (- ti 1) (nth k (entre2-velo self))) ti))))                                                            (setf list-voix-dur (inserte list-voix-dur  (- (nth ti list-voix-on) valor)  ti))                                                            (setf list-voix-on (inserte list-voix-on  valor  ti))                                                            (setf (resume-m1 self) (incremente (resume-m1 self) i 1)))                                                          (setf (nth ti list-voix-dur) (* (if (< (nth ti list-voix-dur) 0 ) -1 1) (+ (abs (nth ti list-voix-dur)) (- (nth ti list-voix-on) valor)))))))                                                    (incf i)                                                    (list  (remove 0 rep  :test #'=))))  (cdr marca))))) entrada )))               (n (length lista1))               (m (length (car lista1)))               (k 0) (j 0) rep rep1)          (setf (entre2 self)  (mapcan #'(lambda (mes)                                           (list (flat-once mes))) lista1))           (while (< k m)            (setf j 0)            (setf rep nil)            (while (< j n)              (setf rep (cons (nth k (nth j lista1)) rep))              (incf j))            (setf rep1 (cons (list (list  (nth  k  (resume-m1 self)) (nth (+ k 1) (resume-m1 self)))                                   (reverse rep)) rep1))            (incf k))          rep1))           (setf (rep-m1 self) (reverse (rep-m1 self))))(defmethod do-resume-m1 ((self C-MN-view-mod-kant))  (let* (rep)    (if (null (nth 0 (marcas-archi self)))      (mapc #'(lambda (mes)                (setf rep (mk-merge  rep mes))) (marcas-archi self))      (setf rep (nth 0 (marcas-archi self))))      (setf (resume-m1 self)  (mk-merge rep (domaine self))))  (setf (cambio-resume self) 1)  (mk-repm1 self (entre self) (entre-pitch self) (entre-velo self))   (setf (cambio-resume self) 1)  (setf (resume-selected self) nil)  (setf (selection-m1 self) nil)  (enable-menu self 2)  (setf (pw::chords (pw::chord-seq (papa self)))         (butlast (mk-aficha  (entre2 self)) (length (entre2 self))))  (mapc #'(lambda (mes) (pw::update-all-notes mes)) (editor-objects self))  (setf (marcas-seg self) (mapcan #' (lambda (mes) (declare(ignore mes))(list nil)) (marcas-seg self)))  (setf (patte self) nil)  (setf (active-menu self) (num (popUpBox2 self)))  (view-draw-contents self));======================Menu MES=====================================(defmethod go-pattern ((self C-MN-view-mod-kant))  (setf (nth 1 (marcas-seg self)) nil)  (setf (act-num self) 9)  (setf (patte self) nil)  (setf (cont self) 0)  (if (not (null (selection-m1 self)))    (setf (entre-m2 self) (list (nth (selection-m1 self) (rep-m1 self))))    (setf (entre-m2 self) (rep-m1 self)))  (mapcan #'(lambda (lis)              (declare (ignore lis))              (let ((dialog (make-instance 'dialog :window-show nil :view-size #@(285 200)                                            :window-type :double-edge-box                                            :view-position (ccl:make-point 100 200))))                (prog1                  (add-subviews dialog                                (make-dialog-item 'static-text-dialog-item (make-point 10 10) (make-point 45 16) "Min" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 10 45) (make-point 45 16) "Max" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 10 80) (make-point 45 16) "Error" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 110 10) (make-point 50 16) "(Notes)" nil :view-font '("monaco" 9 :srcor))                                ;(make-dialog-item 'static-text-dialog-item (make-point 230 10) (make-point 45 16) "(Dur)" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 110 45) (make-point 50 16) "(Notes)" nil :view-font '("monaco" 9 :srcor))                                ;(make-dialog-item 'static-text-dialog-item (make-point 230 45) (make-point 45 16) "(Dur)" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 110 80) (make-point 45 16) "( % )" nil :view-font '("monaco" 9 :srcor))                                (make-dialog-item 'static-text-dialog-item (make-point 230 80) (make-point 45 16) "(Dur)" nil :view-font '("monaco" 9 :srcor))                                (slot-value self 'minnotes1) ;(slot-value self 'minnotes2)                                (slot-value self 'maxnotes1) ;(slot-value self 'maxnotes2)                                (slot-value self 'err1) (slot-value self 'err2)                                (make-dialog-item 'static-text-dialog-item (make-point 10 115) (make-point 45 16) "Pattern" nil :view-font '("monaco" 9 :srcor))                                 (slot-value self 'sequence)                                (slot-value self 'cancel-button) (slot-value self 'OK-button))                  (modal-dialog dialog)                  (setf (cont self) (+ (cont self) 1))))) (entre-m2 self))  (if (ok-b self)    (progn      (setf (ok-b self) nil)      (setf (cont self) 0)      (setf (cambio-marca self) 22)      (view-draw-contents self)))) (defmethod do-resume-m2 ((self C-MN-view-mod-kant))  (setf (act-num self) 6)  (setf (cont self) 0)  (setf (list-of-mes self) nil)  (setf (rep-seg self) nil)  (if (not (null (selection-m1 self)))    (setf (entre-m2 self) (list (nth (selection-m1 self) (rep-m1 self))))    (setf (entre-m2 self) (rep-m1 self)))  (if (null (nth 0 (marcas-seg self)))    (let* (rep )      (mapc #'(lambda (mes)                (setf rep (mk-merge  rep mes)))  (marcas-seg self))      (setf (resume-m2 self)  rep))    (setf (resume-m2 self) (mk-merge (nth 0 (marcas-seg self)) nil)))  (when (selection-m1 self)    (let* (rep )      (mapc #'(lambda (mes)                (if (and (>= mes (caaar (entre-m2 self))) (<= mes (cadaar (entre-m2 self))))                  (setf rep (cons  mes rep ))))  (resume-m2 self))      (setf (resume-m2 self)  (reverse rep))))  (setf (compaces self) nil)  (mapcan  #'(lambda (lis)       (setf (list-of-mes self) (cons (caar lis) (list-of-mes self)))       (setf (list-of-mes self) (cons (cadar lis) (list-of-mes self)))       (let ((dialog (make-instance 'dialog :window-show nil :view-size #@(285 200)                                     :window-type :double-edge-box                                     :view-position (ccl:make-point 100 200))))         (prog1           (setf (rep-kant self) (list (cadr (nth (cont self) (entre-m2 self))) nil nil (caar (nth (cont self) (entre-m2 self)))))           (add-subviews dialog                         (slot-value self 'auto-tol)                          (make-dialog-item 'static-text-dialog-item (make-point 50 10) (make-point 60 16) "Auto-tol" nil :view-font '("monaco" 9 :srcor))                         (make-dialog-item 'static-text-dialog-item (make-point 86 40) (make-point 40 16) "Tol1" nil :view-font '("monaco" 9 :srcor))                         (slot-value self 'val-tol1)                         (make-dialog-item 'static-text-dialog-item (make-point 86 60) (make-point 40 16) "Tol2" nil :view-font '("monaco" 9 :srcor))                          (slot-value self 'val-tol2)                         (make-dialog-item 'static-text-dialog-item (make-point 86 80) (make-point 40 16) "Minsd" nil :view-font '("monaco" 9 :srcor))                         (slot-value self 'minsd)                         (make-dialog-item 'static-text-dialog-item (make-point 86 100) (make-point 40 16) "Times" nil :view-font '("monaco" 9 :srcor))                          (slot-value self 'btimes)                         (slot-value self 'kant1)                         (slot-value self 'kant2)                         (slot-value self 'cancel-button) (slot-value self 'OK-button))           (modal-dialog dialog)           (setf (rep-seg self) (cons  (rep-kant self)  (rep-seg self)))           (setf (cont self) (+ (cont self) 1))))) (entre-m2 self))  (if (ok-b self)    (progn      (setf (ok-b self) nil)      (setf (entre3 self) (copy-tree (entre2 self)))      (setf (entre3-pitch self) (copy-tree (entre2-pitch self)))      (setf (rep-m2 self) (reverse (rep-seg self)))      (let ((r 0)  lis1 lis2 lis22 lis3 lis4 rep )        (mapcan #'(lambda (lis)                    (prog1                      (setf lis1 (concatenate 'list lis1 (list (car lis))))                      (setf lis22 (concatenate 'list lis22 (list (cadr lis))))                      (setf lis2 (concatenate 'list lis2  (cadr lis)))                      (setf lis4 (cons (fourth lis) lis4 ))                      (let* (( longi (length (cadr lis)))                             (nlis (if (listp (caddr lis)) (caddr lis) (make-list longi :initial-element (caddr lis)))))                        (setf lis3 (concatenate 'list    lis3  nlis)))                      )) (rep-m2 self))        (setf lis4 (reverse lis4))        (setf (list-of-mes self) (butlast  (mk-merge (resume-m2 self) (reverse (list-of-mes self)))))        (setf lis1              (let* (rep1)                (while (< r (length (entre2 self)))                   (let* ((acu 0))                    (setf r (+ r 1))                    (setf rep nil)                    (mapc #'(lambda (c d)                            (progn                              (if (null (selection-m1 self) )                                (progn                                  (replace (nth (- r 1) (entre3 self)) (nth (- r 1) c) :start1 acu)                                  (setf acu (+ acu (length (nth (- r 1) c))))                                  )                                (replace (nth (- r 1) (entre3 self)) (nth (- r 1)  c) :start1                                          (position (nth (caaar  (entre-m2 self)) (collecte (mk-event-list (entre2 self) nil nil) 'onset))                                                           (collecte (mk-event-list (list (nth (- r 1) (entre3 self))) nil nil) 'onset) :test #' <=)  ))                              (when  d                                  (setf rep (concatenate 'list rep (nth (- r 1) c)))))) lis1 lis22)                  (setf  rep1 (cons rep rep1))))                   rep1))        (setf lis1 (reverse lis1))        (let ((co 0) temporal)                    (mapc #'(lambda (c)                            (progn                              (setf (compaces self) (mk-merge (compaces self) (mk-beat self  c co lis4 (nth 2 (nth co (rep-m2 self))))))                              (when c                                (setf temporal (mk-merge temporal (mk-bar-mesu self c  co lis4 ))))                              (incf co )))  lis22)                    (setf (list-of-mes self)  temporal))        (setf (rep-m2 self)   (list lis1 lis2 lis3)))      (setf (pw::chords (pw::chord-seq (papa self)))             (butlast (mk-aficha  (entre3 self)) (length (entre3 self))))      (mapc #'(lambda (mes) (pw::update-all-notes mes)) (editor-objects self))      (enable-menu self 3)      (setf (active-menu self) (num (popUpBox3 self)))      (setf (cambio-resume self) 2)      (view-draw-contents self))))(defmethod mk-beat ((self C-MN-view-mod-kant) lmes co lis-arch tempo)  (let* ((durs (collecte (mk-event-list (entre3 self) nil nil) 'onset))         (onset (nth (nth co lis-arch) durs))         (lis (copy-tree  (ind4->pix self (list-of-mes self) (entre3 self))))         repons tempi)    (mapc #'(lambda ( mes mes2 )                 (let ((j 0)                      (i mes2))                  (setf tempi (/ 6000 (* tempo (/ (cadr mes) 4))))                  (while (< j (car mes))                    (push (round i) repons)                    (incf j)                    (setf i (+ i (floor tempi)))))) lmes (delete-if #'(lambda (item) (< 1 (- onset item ))) lis))      (sort repons '<)))                             (defmethod mk-bar-mesu ((self C-MN-view-mod-kant) lmes co lis-arch )  (let* ((onset (nth co lis-arch))         (lis (copy-tree  (list-of-mes self) ))         repons)    (mapc #'(lambda ( mes mes2)               (declare (ignore mes))              (push mes2 repons)              ) lmes  (delete-if #'(lambda (item) (< item onset)) lis)  )    (sort repons '<)))(defmethod view-mouse-up ((self C-MN-view-mod-kant))  (if (not (or (multi-sele self) (double-click-p)))    (if (and (not (null (item-selected self)))  (< 5  (abs (- (pos-mouse self) (view-mouse-position self)))))       (let* ((h (- (point-h (view-mouse-position self)) (point-h (pos-mouse self))))             (c (car-select self))             (fact-scal (pw::MN-zoom-scaler self))             (whichmarca (cond                          ((position c (simbol-archi self) :test 'equal)                            (copy-tree (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self))))                          ((position c (simbol-seg self) :test 'equal)                            (copy-tree (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self))))                          ((or (equal c "<") (equal c ">") (equal c "x"))                           (nth 1 (marcas-seg self)))))             (entrada (collecte (mk-event-list (if (eq (active-menu self) 1) (entre self) (entre2 self)) nil nil) 'onset))             (marca  (nth (nth  (view-nick-name (item-selected self)) whichmarca)  entrada))             (pos (+ marca (/ h fact-scal))))        (if (position (find pos entrada :test #'<) entrada)          (delete-selec self (position (find pos entrada :test #'<) entrada))          (progn (print "out of range") (ed-beep)))        (view-draw-contents self)))))(defmethod shift-marca ((self C-MN-view-mod-kant)  num)  (if (multi-sele self)    (let* (( c (car-select self))           (lista (cond                   ((position c (simbol-archi self) :test 'equal)                     (copy-tree (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self))))                   ((position c (simbol-seg self) :test 'equal)                     (copy-tree (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self))))))            rep)      (mapc #' (lambda (mes)                   (if (and (> mes 0) (< mes (car (last (domaine self)))))                   (push (+ mes num) rep)                   (push mes rep))) lista)      (setf rep (reverse rep))      (cond       ((position c (simbol-archi self) :test 'equal)         (setf (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self)) rep)        (setf (cambio-marca self) (+ (position c (simbol-archi self) :test 'equal) 10))        (reset-select self))       ((position c (simbol-seg self) :test 'equal)         (setf (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self)) rep)        (setf (cambio-marca self) (+ (position c (simbol-seg self) :test 'equal) 21))        (reset-select self))))))(defmethod f-union-inter ((self C-MN-view-mod-kant) char)  (if (multi-sele self)    (let* (( c (car-select self))           (lista2 (cond                    ((position c (simbol-archi self) :test 'equal)                      (copy-tree (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self))))                    ((position c (simbol-seg self) :test 'equal)                      (copy-tree (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self))))                    ((or (equal c "<") (equal c ">") (equal c "x"))                     (copy-tree (nth 1 (marcas-seg self))))))           (res (if (null (position c (simbol-archi self) :test 'equal)) 2 1)))      (if (eq res 1) (if (eq char #\+) (setf (nth 0 (marcas-archi self)) (sort (union (nth 0 (marcas-archi self)) lista2) '<))                         (setf (nth 0 (marcas-archi self)) (sort (intersection (nth 0 (marcas-archi self)) lista2) '<)))          (if (eq char #\+) (setf (nth 0 (marcas-seg self)) (sort (union (nth 0 (marcas-seg self)) lista2) '<))              (setf (nth 0 (marcas-seg self)) (sort (intersection (nth 0 (marcas-seg self)) lista2) '<))))      (setf (cambio-marca self) (+ 1 (* 10 res))))))(defun tes6 ( item elem)  (>= (car elem)  item  ) )(defmethod fun-delete-chord ((self C-MN-view-mod-kant) even gc bi bs voz)  (let* ((lista even)         (pos  (- (position bi lista :test #'tes6) 1))         (indic (- (position gc  (ind4->pix self  (resume-m1 self) (entre2 self)) :test #' <) 1)))    (if (<= (onset (nth (+ pos 1)  lista)) bs)      (if (> (onset (nth (+ pos 1)  lista)) gc)        (progn          (setf (nth 1 (nth (+ pos 1) lista))  (+ (vrai-dur (nth (+ pos 1) lista))                                                   (if (silence (nth (+ pos 1) lista)) (- gc  (onset (nth  (+ pos 1)  lista)) ) (-  (onset (nth (+ pos 1) lista)) gc ))))          (setf (nth 1 (nth pos lista))  (+ (nth 1 (nth pos lista))                                             (if (silence (nth  pos  lista)) (-  (onset (nth (+ pos 1) lista)) gc ) (- gc (onset (nth (+ pos 1)  lista)) ))))          (onset (nth (+ pos 1) lista) gc))              (progn           (setf (nth 1 (nth  pos  lista))  (+ (vrai-dur (nth  pos  lista))                                               (if (silence (nth  pos  lista)) (-  (onset (nth  (+ pos 1)  lista)) gc) (- gc (onset (nth  (+ pos 1)  lista)) ))))          (setf (nth 1 (nth (+ pos 1) lista))  (+ (vrai-dur (nth (+ pos 1) lista))                                                   (if (silence (nth  (+ pos 1)  lista)) (- gc (onset (nth  (+ pos 1)  lista)) ) (-  (onset (nth  (+ pos 1)  lista)) gc))))          (onset (nth (+ pos 1) lista) gc)          (while (and (nth (+ pos 2)  lista) (<= (onset (nth (+ pos 2)  lista)) bs))            (delete (nth (+ pos 2) (nth voz (entre2-velo self))) (nth voz (entre2-velo self)))            (delete (nth (+ pos 2) (nth voz (entre2-pitch self))) (nth voz (entre2-pitch self)))            (setf lista (delete (nth (+ pos 2) lista) lista :test #'equal))            (setf (resume-m1 self) (incremente (resume-m1 self) indic -1)))          (when (nth (+ pos 2)  lista)          (setf (nth 1 (nth (+ pos 1) lista))  (* (if (silence (nth (+ pos 1) lista)) -1 1)                                                     (- (onset (nth (+ pos 2) lista)) gc)))))))    lista))(defmethod f-aligne-un-chord ((self C-MN-view-mod-kant) mes )  (let* (( delta (+ 1 (slot-value self 'deltachord)))         (n-voices (length (entre2 self)))         (eve (mk-event-list (entre2 self) nil nil))         (ev (collecte eve 'onset))         (n (length ev))         i j rep rep2 cg bs bi )    (setf i  (position mes ev :test #'=))    (setf j i)    (setf rep nil)    (while (and (< j n) (> delta (abs (-  (nth i ev)  (nth j ev)))))      (setf rep (cons   (nth j ev) rep))      (setf j (+ j 1)))    (setf cg (grav-cent rep))    (setf bs (nth (- j 1) ev))    (setf bi (nth i ev))    (setf i 0)    (setf rep2 nil)    (while (< i n-voices)      (setf rep2 (cons (butlast (collecte (fun-delete-chord self (select eve 'voice '= i) cg  bi bs i) 'vrai-dur)) rep2))      (setf i (+ i 1)))    (setf (entre2 self) (reverse rep2))    (mk-repm1 self (entre2 self) (entre2-pitch self) (entre2-velo self))    ))     (defun fun-minus (l1 l2)  (mapc #' (lambda (mes)             (if (not (null (position mes l2 :test #'=)))               (setf l1 (delete mes l1 :test #'=)))) l1)  l1)(defun grav-cent (lis) (let ((n (length lis)) (total 0))   (mapc #' (lambda (mes)              (setf total (+ total mes))) lis)   (/ total n)))(defmethod f-aligne-chords ((self C-MN-view-mod-kant) )  (if (and (item-selec self) (equal (car-select self) "¯"))    (let* ((eve (mk-event-list (entre2 self) nil nil))           (chordes  (mapcan #' (lambda (mes)                                   (list (onset (nth mes eve)))) (fun-minus (copy-tree (nth 4 (marcas-seg self))) (resume-m1 self))))           (lista2 (if (multi-sele self)   chordes                        (list (onset (nth (nth (view-nick-name (item-selected self)) (nth 4 (marcas-seg self))) eve)))))           i)      (mapc #' (lambda (mes)                 (f-aligne-un-chord self mes)) lista2)      (setf (pw::chords (pw::chord-seq (papa self)))             (butlast (mk-aficha  (entre2 self)) (length (entre2 self))))      (setf i 1)      (setf (marcas-seg self) (mapcan #' (lambda (mes) (declare (ignore mes))                                                 (progn (delete-marca self (+ 20 i))                                                        (setf i (+ i 1))                                                        (list nil))) (marcas-seg self)))      (mapc #' (lambda (mes) (pw::update-all-notes mes)) (editor-objects self))      (reset-select self)      (setf (ant-size self) 0)      (view-draw-contents self))      (progn (ed-beep) (print "choice one or more chord" ))))(defmethod view-double-click-event-handler ((self C-MN-view-mod-kant) where)  (declare (ignore where))  (if (item-selec self)    (let* ((c (car-select self))           (lista (cond                   ((position c (simbol-archi self) :test 'equal)                     (copy-tree (nth (position c (simbol-archi self) :test 'equal) (vis-marcas-archi self))))                   ((position c (simbol-seg self) :test 'equal)                     (copy-tree (nth (position c (simbol-seg self) :test 'equal) (vis-marcas-seg self))))                   ((or (equal c "<") (equal c ">") (equal c "x"))                    (copy-tree (nth 1 (vis-marcas-seg self))))                   (t (ed-beep)))))      (mapc #'(lambda (mes)                (prog1                   (set-part-color mes :body 0)                  (set-part-color mes :text 16777215))) lista)      (setf (multi-sele self) t));    (when (resume-selected self);       (if (position (resume-selected self) (vis-resume-m1 self));           (prog1;            (set-view-size (resume-selected self) (make-point 2 50));            (if (nth (+  (view-nick-name  (resume-selected self) ) 1) (vis-resume-m1 self));             (set-view-size  (nth (+  (view-nick-name  (resume-selected self) ) 1) (vis-resume-m1 self))  (make-point 2 50))))) ;         (setf (selection-m1 self) nil);         (setf (resume-selected self) nil)))) (defmethod view-click-event-handler ((self C-MN-panel-Mod-kant) where)  (let ((diag (find-clicked-subview self where)))    (if (not (equal diag self))    (dialog-item-action diag))))(defmethod view-click-event-handler ((self C-MN-view-mod-kant) where)  (setf (pos-mouse self) (view-mouse-position self))   (if (option-key-p)    (case (active-menu self)       (1 (progn (setf (edit-archi self) t)                (setf (edit-mesu self) nil)))      (2 (progn (setf (edit-archi self) nil)                (setf (edit-mesu self) t)))      (3 (progn (setf (edit-archi self) nil)                (setf (edit-mesu self) nil))))    (progn (setf (edit-archi self) nil)           (setf (edit-mesu self) nil)))  (if (double-click-p) (view-double-click-event-handler self where)      (if (or (edit-archi self) (edit-mesu self))        (let* ((fact-scal (pw::MN-zoom-scaler self))               (x (/ (- (point-h (view-mouse-position self)) 40) fact-scal))               (y  (point-v (view-mouse-position self)) )               (wins (point-v (view-size (car (editor-objects self)))))               (anch (/ (- (point-h (view-size (car (editor-objects self)))) 40) fact-scal))               (sc (/ (point-h (view-scroll-position (car (editor-objects self)))) fact-scal))               (num (floor y wins))               (x (+ (+ x (* anch num)) sc))               (durs (mk-event-list (if (edit-archi self) (entre self) (entre2 self)) nil nil))               (lis (mapcar #' (lambda (mes)                                 (round mes)) (collecte durs 'onset)))               (lis2 (copy-tree lis))               (i 0) ti)          (when lis            (setf ti (car lis))            (while (and (< ti x) (not (null lis)))              (setf i (+ i 1))              (setf lis (cdr lis))              (when lis                (setf ti (car lis))))            (if (not (eq i 0))              (when lis                (if (< (abs (- (nth (- i 1) lis2) x)) (abs (- (nth i lis2) x)))                  (setf i (- i 1)))                (if (edit-archi self)                  (progn                    (setf (nth 0 (marcas-archi self)) (remove-duplicates (sort (cons i (nth 0 (marcas-archi self))) '<)))                    (setf (cambio-marca self) 11)                    (when (bpf self) (pw::view-draw-contents (bpf self)))                    (when (bpf-p self) (pw::view-draw-contents (bpf-p self)))                    (when (bpf-v self) (pw::view-draw-contents (bpf-v self))))                  (progn                    (setf (nth 0 (marcas-seg self)) (remove-duplicates (sort (cons i (nth 0 (marcas-seg self))) '<)))                    (setf (cambio-marca self) 21))))))          (view-draw-contents self))         (prog1          (if (item-selec self)            (if (multi-sele self)              (let* ((c (car-select self))                     (lista (cond                             ((position c (simbol-archi self) :test 'equal)                               (copy-tree (nth (position c (simbol-archi self) :test 'equal) (vis-marcas-archi self))))                             ((position c (simbol-seg self) :test 'equal)                               (copy-tree (nth (position c (simbol-seg self) :test 'equal) (vis-marcas-seg self))))                             ((or (equal c "<") (equal c ">") (equal c "x"))                              (nth 1 (vis-marcas-seg self))))))                (mapc #' (lambda (mes)                           (set-part-color mes :text 0)                           (set-part-color mes :body 16777215)) lista))               (prog1                (set-part-color (item-selected self) :text 0)                (set-part-color (item-selected self) :body 16777215))))          (reset-select self)          (call-next-method)))))             (defmethod reset-select ((self C-MN-view-mod-kant))  (setf (item-selected self) nil)  (setf (item-selec self) nil)  (setf (multi-sele self) nil))          (defmethod delete-selec ((self C-MN-view-mod-kant) nuevo )(when (item-selected self)     (let* ((c (car-select self))            (lista (cond                    ((position c (simbol-archi self) :test 'equal)                      (copy-tree (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self))))                    ((position c (simbol-seg self) :test 'equal)                      (copy-tree (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self))))                    ((or (equal c "<") (equal c ">") (equal c "x"))                     (nth 1 (marcas-seg self)))))            (num  (nth (view-nick-name (item-selected self)) lista)))       (if (multi-sele self)         (prog1           (setf lista nil)           (if (or (equal c "<") (equal c ">") (equal c "x")) (setf (patte self) nil))           (if (equal c "Æ")  (setf (resume-m1 self) (domaine self))))         (prog1           (setf lista (remove  num lista))           (if (or (equal c "<") (equal c ">") (equal c "x"))             (setf (patte self) (remove-if #'(lambda (mes) (= num (car mes))) (patte self))))           (if (equal c "Æ")  (setf (resume-m1 self) (remove num (resume-m1 self))))           (if (not (eq nuevo -150))             (progn               (setf lista (sort (cons nuevo lista) '<))               (if (or (equal c "<") (equal c ">") (equal c "x"))                 (setf (patte self) (sort (cons (list nuevo c) (patte self)) #'(lambda (x y) (< (car x) (car y))))))))))       (cond        ((position c (simbol-archi self) :test 'equal)          (prog1            (setf (nth (position c (simbol-archi self) :test 'equal) (marcas-archi self)) lista)           (setf (cambio-marca self) (+ 11 (position c (simbol-archi self) :test 'equal)))))        ((position c (simbol-seg self) :test 'equal)          (prog1            (setf (nth (position c (simbol-seg self) :test 'equal) (marcas-seg self)) lista)           (setf (cambio-marca self) (+ 21 (position c (simbol-seg self) :test 'equal)))))        ((or (equal c "<") (equal c ">") (equal c "x"))         (prog1            (setf (nth 1 (marcas-seg self)) lista)           (setf (cambio-marca self) 22))))       (reset-select self)))(when (bpf self) (pw::view-draw-contents (bpf self)))(when (bpf-p self) (pw::view-draw-contents (bpf-p self)))(when (bpf-v self) (pw::view-draw-contents (bpf-v self))))       (defmethod set-display-value ((self C-MN-view-mod-kant) value)  (set-dialog-item-text (car (last (external-controls self)))                          (if value (format () "~S" value) " ")));RECHERCHE DU TEMPO(defun tes (item elem)  (and (<= elem (+ item 1)) (>= elem (- item 1))))(defun tes3 (item elem)  (eq (car item) (car elem)  ))(defun approx-decimals (x y nbdec)  (let ((ndec        (if (> nbdec 0 ) (float (expt 10 nbdec)) (expt 10 nbdec))))    (/ (round (/ x y) (/ ndec)) ndec)))(defmethod mk-auto-to  ((self C-MN-view-mod-kant) values1 minto1 maxto1 minto2 maxto2 paso btimes)(let ((values (copy-tree values1))      rep rep2 to2 li )   (while (<= minto1 maxto1)     (progn       (setf to2 minto2)       (while (<= to2 maxto2)         (let* ((gcd (case (num-kant self) (0 (tolerant-gcd values minto1))                                           (1 (tolerant-gcd2 values minto1))))                (gcd-2 (tolerant-gcd (mapcar 'second (verif-gcd values gcd)) to2))                (gcd-2-round (if (null gcd-2)  1 (round gcd-2 )))                (beat-duration (/ (* gcd gcd-2-round) btimes))                (tempo (if (>  beat-duration 0)  (round 6000 beat-duration)   1))                )             (if (> gcd-2-round 0 )               (when (and (<= tempo 300) (>= tempo 40))                 (setf rep2 (cons (list tempo  minto1 to2  gcd gcd-2-round) rep2))                 (setf rep (cons (list  tempo (if (< tempo 100) " " "") "                       " (approx-decimals minto1 1 2)                                        "                " (approx-decimals to2 1 2)  ) rep))))             (setf to2 (+ to2 paso))))       (setf minto1 (+ minto1 paso))))   (setf rep (remove-duplicates rep :test 'tes3) )   (setf rep (reverse rep))   (setf rep2 (remove-duplicates rep2 :test 'tes3) )   (setf rep2 (reverse rep2))   (setf li (select-item-from-list  rep  :window-title  "tempo                         tol1                             tol2  "))   (nth (position (car li) rep) rep2)))       (defmethod fun-m2 ((self C-MN-view-mod-kant))  (let* ((tol2  (read-from-string (dialog-item-text (tol2 self))))         (tol1  (read-from-string (dialog-item-text (tol1 self))))         (minsd  (read-from-string (dialog-item-text (minsd self))))         (btimes  (read-from-string (dialog-item-text (btimes self))))         (durs   (nth (cont self) (entre-m2 self)))         (ofset  (car durs))         (durs (cadr durs))         (*ev-list* (mk-event-list durs nil nil))         (debut  (car ofset))         (fin (cadr ofset))         (ofset debut)         (lista    (resume-m2 self))         (peak nil)         (peak-positions (mapc #' (lambda (mes)                                    (if (and (< mes fin) (> mes debut))                                      (setf peak (cons  (- mes ofset) peak)))) lista))         (peak-positions  peak)         (inter-events-by-onsets  (events->intervals *ev-list* 'onset))         (selected-intervals (modify  (project  (select-pos inter-events-by-onsets   peak-positions)                                                'source)                                       'weight #'+ 10))         (selected-events  (project (select *ev-list* 'weight '> 0) '(onset)))         (selected-intervals  (merge-intervals (events->intervals selected-events 'onset) minsd))         (articulations   (collecte  selected-intervals 'value))         (autotol (check-box-checked-p (auto-tol self)))         (result (if autotol (mk-auto-to self articulations 0.01 0.3 0.04 0.3 (if (minusp tol1) (abs tol1) 0.02) btimes)                     (mk-auto-to self articulations tol1 tol1 tol2 tol2 0.02 btimes)))         (gcd  (fourth result))         (gcd-2  (fifth result))         (segments  (mk-segmentation *ev-list* selected-intervals))         (gcd-2-round (round gcd-2))         (beat-duration (/ (* gcd gcd-2-round) btimes))         (tempo (round 6000 beat-duration))         (beat-duration (/ 6000.0 tempo))         (time 0.0)         beat-list         density-list                            aligned-ev-list)    (setf (resume-m2 self) (mk-merge (resume-m2 self) (list ofset)))    (setf (resume-m2 self)          (let* ((co 0)                 (lalis (copy-tree (resume-m2 self)))                 (n (length peak-positions))                 (dure (mk-event-list (entre2 self) nil nil)))            (while (< co  (- n 1) )              (if (and (integerp (nth co lalis)) (integerp (nth (+ co 1) lalis)))                (if (= 0 (- (onset (nth (nth co lalis) dure)) (onset (nth (nth (+ co 1) lalis) dure))))                  (progn                    (delete  (nth  (+ co 1) lalis) lalis :test #'=)                    (setf peak-positions (delete  (nth  co  (reverse  peak-positions)) peak-positions :test #'=))                    (setf n (- n 1)))                   (incf co))                (incf co)))            lalis)          )    (let* ((co 0)           (listaza    (delete-if #'(lambda (item) (= 0 (car item ))) (collecte (events->intervals selected-events 'onset) 'second) ))           (lalis    (delete-if #'(lambda (item) (= 0 (car item ))) (collecte selected-intervals 'second)))           (n (length listaza)) mes)      (while (< co  n )        (setf mes (nth co listaza))        (if (and (null (position   mes lalis)) (< co (length peak-positions)))              (setf (resume-m2 self) (delete  (+ ofset (nth   co (reverse peak-positions))) (resume-m2 self) :test #'=)))        (incf co)        )        )    (case (num-kant self)      (0   (setf aligned-ev-list                 (mapcar                   #'(lambda (segment interval)                      (let* ((nb-beats (if (zerop (round (/ interval beat-duration))) 1 (round (/ interval beat-duration))))                             (scale-factor (if (zerop nb-beats) (progn (print "aprox rara") 1) (/ (* beat-duration nb-beats) interval)))                             (aligned-interval (* interval scale-factor))                             (new-intervals (mapcar #'(lambda (i) (* i scale-factor))                                                    (collecte (events->intervals segment 'onset) 'value)))                             (time-saved time)                             (new-segment                               (mapcar                                #'(lambda (event interval)                                   (mk-event (incf time interval)                                             (*  (vrai-dur event) scale-factor)                                              (voice event) (weight event)))                               segment                               (cons 0.0 new-intervals))))                        (setf time (+ time-saved aligned-interval))                        (push nb-beats beat-list)                        (push (length (project segment 'onset)) density-list)                        new-segment))                  segments                  articulations)))      (1 (setf aligned-ev-list               (mapcar                 #'(lambda (segment interval)                    (let* ( (pulsation 1/4)                            (beat-duration2 beat-duration)                            (nb-beats (if (zerop (round (/ interval beat-duration))) 1 (round (/ interval beat-duration))))                            (scale-factor (if (zerop nb-beats) (progn (print "aprox rara") 1) (/ (* beat-duration nb-beats) interval)))                            aligned-interval                            new-intervals                            (time-saved time)                            new-segment                            deviation)                      (setf deviation                             (1- (/ interval (* (round interval gcd) gcd))))                      (when  (>= (- (abs deviation) tol1) 0.005)                        ;(format t "Value : ~S Deviation : ~S ~%" interval deviation)                        (setf pulsation (/ pulsation 2)                              beat-duration2 (/ (* (/ gcd 2) gcd-2-round) btimes)                              nb-beats (round interval beat-duration2)                              scale-factor (/ (* nb-beats beat-duration2) interval)))                      (setf aligned-interval (* interval scale-factor)                            new-intervals (mapcar #'(lambda (i) (* i scale-factor))                                                  (collecte (events->intervals segment 'onset) 'value))                            new-segment  (mapcar  #'(lambda (event interval)                                                      (mk-event (incf time interval)                                                                (* (vrai-dur event) scale-factor)                                                                 (voice event) (weight event)))                                                  segment                                                  (cons 0.0 new-intervals)))                      (setf time (+ time-saved aligned-interval))                      (push (list nb-beats pulsation) beat-list)                      (push (length (project segment 'onset)) density-list)                      new-segment))                segments                articulations))))    (setf beat-list (nreverse beat-list)          density-list (nreverse (cons (- (first density-list) 1) (rest density-list))))    (setf aligned-ev-list (flat-once aligned-ev-list))    (case (num-kant self)      (0 (setf (rep-kant self)                (list                (let (voice aligned-inter-onsets (voice-nb -1))                  (while (setf voice                                (select  aligned-ev-list 'voice '= (incf voice-nb)))                    (push (collecte (events->intervals voice 'onset) 'value-vrai)                          aligned-inter-onsets))                  (nreverse aligned-inter-onsets))                (mapcar #'(lambda (nb-beats) (list nb-beats 4)) beat-list)                tempo ofset)                ))      (1 (setf (rep-kant self)                (list                (let (voice aligned-inter-onsets (voice-nb -1))                  (while (setf voice                                (select  aligned-ev-list 'voice '= (incf voice-nb)))                    (push (collecte (events->intervals voice 'onset) 'value-vrai)                          aligned-inter-onsets))                  (nreverse aligned-inter-onsets))                (let* ((i -1))                   (mapcan #'(lambda (signature)                              ;(incf i)                              (if (= (second signature) 1/8)                                (if (evenp (first signature))                                  (list (list (/  (first signature) 2) 4))                                  (list (list (first signature) (denominator (second signature)))))                                ;    (if (eq 1 (first signature))                                ;      (list '(1 8))                                ;      (progn (setf (resume-m2 self) (aumente (resume-m2 self) (+ i (position  ofset (resume-m2 self))) (first signature)))                                ;             (incf i)                                ;             (list (list (/ (1- (first signature)) 2) 4) '(1 8)))))                                (list (list (first signature) (denominator (second signature))))) )  ;)                          beat-list))                tempo ofset))))     (setf (ok-b self) t)    (return-from-modal-dialog ())))(defun index-list (list)  (loop for value in list        for index = 0 then (1+ index)        collect (list index value)))(defun density-function (evt-list window)  (loop  for event-tail on  evt-list         with max-onset         do (setf max-onset (+ (onset (first event-tail)) window))         collect          (loop for event in event-tail               ;for count from 1               while (<= (onset event) max-onset)               sum  (if (zerop (dur event)) 0 (/ 100.0 (dur event))))))#|(defun get-peaks (values &key min plateaux )   (let ((list `(,(list 0 (if min 1e+5 0)) ,@ values ,(list 0 (if min 1e+5 0)))))    (loop      for (i1 previous) in list      for (i2 current) in (rest list)      for (i3 next) in (rest (rest list))      when (if  min             (and (or (and plateaux (>= previous current))                      (> previous current))                  (<=  current next))             (and (or (and plateaux (<= previous current))                      (< previous current))                  (>=  current next)))      collect  (list i2 current))))(defun compute-peaks (values niter min)  (let ((values (index-list values)))    (compute-peaks-aux values niter nil min)))(defun compute-peaks-aux (values niter plateaux min)  (if (zerop niter)    values    (let ((values2 (get-peaks values :plateaux plateaux :min min)))      (if (equal values values2)        values        (compute-peaks-aux values2 (1- niter) t min)))))|#;; GA 13/10/94(defun compute-peaks (values niter min &key (threshold 1))  (let ((values (index-list values)))    (compute-peaks-aux values niter nil min :threshold threshold)));; GA 13/10/94(defun compute-peaks-aux (values niter plateaux min &key (threshold 1))  (if (zerop niter)    values    (let ((values2 (get-peaks values :plateaux plateaux :min min :threshold threshold)))      (if (equal values values2)        values        (compute-peaks-aux values2 (1- niter) t min :threshold threshold)))));; GA 13/10/94(defun get-peaks (values &key min plateaux (threshold 1))   (let ((list `(,(list 0 (if min 1e+5 0)) ,@ values ,(list 0 (if min 1e+5 0)))))    (loop      for (i1 previous) in list      for (i2 current) in (rest list)      for (i3 next) in (rest (rest list))      when (if  min             (and (or (and plateaux (>= previous current))                      (> previous current))                  (<=  current next))             (and (>= current threshold)                  (or (and plateaux (<= previous current))                      (< previous current))                  (>=  current next)))      collect  (list i2 current))))(defun plot-peaks (values niter)  (epw::mat-trans   (mapcar 'epw::mat-trans           (list (index-list values)                 (compute-peaks values niter nil)                 (compute-peaks values niter t)))))(defun mk-merge (l1 l2)  (sort  (remove-duplicates (concatenate 'list l1 l2) :test '=) '<=))(defun mk-merge2 (l1 l2)  (concatenate 'list l1 l2))(defmethod ind->pix ((self C-MN-view-mod-kant) lista1 lista2)(when lista2  (let* ((fact-scal (pw::MN-zoom-scaler self))        (lista (mk-event-list lista2 nil nil)))    (mapcan #'(lambda (mes) (list (round (* fact-scal (onset (nth mes lista)))))) lista1))))(defmethod ind4->pix ((self C-MN-view-mod-kant) lista1 lista2)(when lista2  (let* ((lista (mk-event-list lista2 nil nil)))    (mapcan #'(lambda (mes) (list  (onset (nth mes lista)))) lista1))))(defmethod mk-scal ((self C-MN-view-mod-kant) lista1)  (let* ((fact-scal (pw::MN-zoom-scaler self)))    (mapcan #'(lambda (mes) (list (round (* fact-scal  mes )))) lista1)))(defun incremente (lista i val)  (let ((k -1))    (mapcan #'(lambda (lis)                (progn                  (incf k)                   (if (> k i)                    (list (+ lis val))                    (list lis)))) lista)))              (defun inserte (lista elem pos)(let ((k -1) ante)    (concatenate 'list (mapcan #'(lambda (lis)                                   (progn                                     (setf k (+ k 1))                                     (cond                                       ((= k pos) (progn                                                   (setf ante (nth k lista))                                                   (list  elem)))                                      ((> k pos) (prog1                                                    (list ante)                                                   (setf ante  (nth k  lista))))                                      ( t       (list lis))))) lista) (last lista))))    (defunp kant ((durs list (:value '((100))))                     (pitch list (:value '()))                     (velocity list (:value '()))                      &optional (objs list (:value '() :type-list ())))        list        "quantifies a polyphonic list of lists of durations."   (declare (ignore durs pitch velocity objs)))(defparameter *kant-menu-pri*  (pw::new-menu "Kant"))(pw::add-menu-items (pw::the-user-menu) *kant-menu-pri*)(pw::pw-addmenu-fun *kant-menu-pri* 'Kant 'C-patch-box-kant)