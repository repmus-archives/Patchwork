;;;;=========================================================;;;;  KANT PATCH-WORK;;;;  Rep. Mus.;;;;  © 1994 IRCAM ;;;;=========================================================(in-package "C-PATCH-BOX-KANT")(defmethod fun-pat ((self C-MN-view-mod-kant))  (let* ((m (length (second (car  (entre-m2 self)))))         (durs    (nth (cont self) (entre-m2 self)))         (ofset  (caar durs))         (fin (second (car durs)))         (event-list (mk-event-list (entre2 self) (entre2-pitch self) (entre2-velo self)))         ;(lis-p (get-archimes event-list ofset fin 'pitch (length durs)))  GA 270996         ;(lis-v (get-archimes event-list ofset fin 'velocity (length durs)))  GA 270996         (lis-p (get-archimes event-list ofset fin 'pitch (length (entre self))) )         (lis-v (get-archimes event-list ofset fin 'velocity (length (entre self))))          (seq  (pw::expand-lst (list (read-from-string (dialog-item-text (sequence self))))))         (minnot1 (read-from-string (dialog-item-text (slot-value self 'minnotes1))))         ;(minnot2 (read-from-string (dialog-item-text (slot-value self 'minnotes2))))         (maxnot1 (read-from-string (dialog-item-text (slot-value self 'maxnotes1))))         ;(maxnot2 (read-from-string (dialog-item-text (slot-value self 'maxnotes2))))         (errpor  (/ (read-from-string (dialog-item-text (slot-value self 'err1))) 100))         (errseg  (read-from-string (dialog-item-text (slot-value self 'err2))))         (durs (cadr durs))         (listap (mk-primitives (precodage lis-p) 0 0))         (listav (mk-primitives (precodage lis-v) errpor 0))         (primi (mk-primitives (precodage  durs) errpor  errseg)))    (setf (patte self)          (mk-merge2 (patte self)                     (if (null seq) nil                         ;(mapcar #'(lambda (mes) (list (+ ofset (car mes)) (cadr mes)))                         ;         (mk-subpatterns primi))                         (mapcan #'(lambda (mes)  (list (list (+ ofset (if (= 0 (car mes)) 0                                                                           (second (nth (if  (= 0 (position (second (nth (car mes) primi)) (collecte primi 'second)))                                                                                          0                                                                                          (- (position (second (nth (car mes) primi)) (collecte primi 'second)) 1))                                                                                         primi)) ) ) "<")                                                        (if (null (nth (cadr mes) primi))                                                          (list (+  ofset  (second (car (last primi)))) ">")                                                          (if (= m 1)                                                            (list (+   ofset   (cadr mes) )  ">")                                                            (list (+  ofset  (second (nth (- (position (second (nth (cadr mes) primi)) (collecte primi 'second)) 1) primi))) ">")))))                                 (matcher self seq (collecte primi 'car) (collecte listap 'car) (collecte listav 'car) minnot1 maxnot1 )))))    (setf (ok-b self) t)    (setf (patte self) (elimine-dobles (patte self)))    (setf (nth 1 (marcas-seg self)) (mk-merge (collecte (patte self) 'car) nil))    (return-from-modal-dialog ())))  (defun elimine-dobles (l)  (let ((n (length l)) (i 0))    (while (< i (- n 1))      (if (or (equal (car (nth i l)) (car (nth (+ i 1) l))) (> (car (nth i l)) (car (nth (+ i 1) l))))        (progn           (delete (nth i l ) l)          (setf (cadr (nth  i  l)) "x")          (setf i (- i 1))          (setf n (- n 1))          ))      (setf i (+ i 1)))    l))  (defun simple (l)  (let ((ult  (car (last l))))    (if (listp ult) t        (not (or (equal (symbol-name ult) "AND") (equal (symbol-name ult) "OR") (equal (symbol-name ult) "*") (equal (symbol-name ult) "+"))))))(defun matcher-p (pattern listad listap listav  i)  (if (and (eq (length pattern) 1) (listp (car pattern)))           (matcher-p (car pattern) listad listap listav i)           (let* ((k 0) (j 0) (siga t)                  (m (if (simple pattern) (length pattern) 1))                  ca temp pat1 cont elmin)             (while (and (< k m) siga)               (progn                 (if (simple pattern)                   (setf pat1 (nth k pattern))                   (setf pat1 pattern))                 (if (atom pat1)                   (if (match-p (list pat1)  (+ j i) listad listap listav)                      (setf j (+ j 1))                     (setf siga nil))                   (progn                     (setf ca (symbol-name (car (last pat1))))                     (cond                      ((equal ca "OR") (progn                                         (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                         (if (first temp)                                           (setf siga t j (+ j (second temp)))                                           (progn                                             (setf siga nil)                                             (setf pat1 (cdr (butlast pat1)))                                             (while (and pat1 (not siga))                                               (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                               (if (first temp)                                                 (setf siga t  j (+ j (second temp)))                                                 (setf pat1 (cdr pat1))))))))                      ((equal ca "AND") (progn                                         (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                         (if (not (first temp))                                           (progn                                             (setf siga nil)                                             (incf j))                                           (progn                                             (setf elmin (second temp))                                             (setf siga t)                                             (setf pat1 (cdr (butlast pat1)))                                             (while (and pat1 siga)                                               (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                               (if (not (first temp))                                                 (setf siga nil )                                                 (progn                                                   (setf pat1 (cdr pat1))                                                   (setf elmin (min elmin (second temp))))))                                             (if siga                                               (setf  j (+ j elmin))                                               (setf  j (+ j 1)))))))                      ((equal ca "*")  (progn                                         (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                         (while (first temp)                                           (setf j (+ j (second temp)) temp (matcher-p (list (first pat1)) listad listap listav (+ i j))))                                         ))                      ((equal ca "+")  (progn                                         (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))                                         (setf cont 0)                                         (while (first temp)                                           (progn                                             (incf cont)                                             (setf j (+ j (second temp)))                                             (setf temp (matcher-p (list (first pat1)) listad listap listav (+ i j)))))                                         (if (eq cont 0) (setf siga nil))))                      (t                (progn                                          (setf temp (matcher-p  pat1 listad listap listav (+ i j)))                                          (if (first temp)                                           (setf siga t j (+ j (second temp)))                                           (setf siga nil)))))))                 (setf k (+ k 1))))             (list siga j))))              (defmethod matcher ((self C-MN-view-mod-kant) pattern lista1 listap listav  minnot maxnot )  (let* ((lista (butlast lista1))         (i 0)         (n (length lista))         rep temp)    (if (<= minnot maxnot)      (while (< i n)        (progn          (setf temp (matcher-p pattern lista listap listav i))          (if (and (first temp)  (> (+ (second temp) 1)  minnot))            (if (<= (second temp)  maxnot)              (progn (push  (list i (+ i  (+ (second temp) 1) )) rep)                       (if (eq (second temp) 0) (setf i (+ i 1)) (setf i (+ i (+ (second temp) 1)))))              (progn (push  (list i (+ i   maxnot )) rep)                     (if (eq (second temp) 0) (setf i (+ i 1)) (setf i (+ i   maxnot  ))))) ; ojo antes era maxnot mas uno            (setf i (+ i 1))))))    (reverse  rep)))(defun match-p (pat k listad listap listav)  (let* ((pat-car (car pat))         (sim (symbol-name pat-car))         (list (cond                ((or (equal sim ">P") (equal sim "<P") (equal sim "=P")) (nthcdr k listap))                ((or (equal sim ">V") (equal sim "<V") (equal sim "=V")) (nthcdr k listav))                (t (nthcdr k listad))))         (list-car (car list)))    (if (or (null pat-car) (and (not (null list-car)) (equal (symbol-name pat-car) "?")) (igual sim list-car) (equal list-car 'j))      t nil)))(defun igual ( sim b)  (cond   ((equal (symbol-name b) "<") (or (equal sim "<") (equal sim "<P") (equal sim "<V")))   ((equal (symbol-name b) ">") (or (equal sim ">") (equal sim ">P") (equal sim ">V")))   ((equal (symbol-name b) "=") (or (equal sim "=") (equal sim "=P") (equal sim "=V")))   (t nil)))(defun match-p1 (pat list)  (let* ((pat-car (car pat))         (list-car (car list)))    (if (or (null pat-car) (equal pat-car list-car) )      t nil)))(defun precodage (poly-list)  (let*(( event-list (mk-event-list poly-list nil nil))        (list-dur (collecte (reduce-event-list event-list) 'dur))        (dur2 (copy-tree list-dur))        (list-dur2 (delete-if #'(lambda (item )                                  (= item 0)) dur2))        (n (length list-dur2))        (i 0) (j 0)  rep)    (while (< i (- n 1))      (progn        (while (= 0 (nth j list-dur))          (incf j))        (push (list  (abs (- 1 (/ (nth (+ i 1) list-dur2) (nth i list-dur2))))                     (- (nth (+ i 1) list-dur2) (nth i list-dur2)) (+ j 1)) rep)        (incf i)        (incf j)))    (reverse rep)))(defun mk-primitives (lis errpro errreal)  (mapcar  #'(lambda (mes )       (cond           ((or (< (abs (second mes)) errreal) (< (first mes)  errpro))           (list 'j (third mes)))          ((= (second mes) 0)           (list '= (third mes)))          ((> (second mes) 0)           (list '> (third mes)))          (t (list '< (third mes))))         ) lis))(defun mk-subpatterns (lis)  (let* ((i 0)         (n (length lis)) j rep subpat simb)    (while (< i n)      (progn        (setf j 0)        (setf simb (car (nth i lis)))         (cond         ((equal simb '=)          (progn (while (match-p1 '(=) (list (car (nth (+ i j) lis))))                               (setf j (+ j 1)))                 (setf subpat "e")))                                  ((equal simb '<)          (progn (while (match-p1 '(<) (list (car (nth (+ i j) lis))))                               (setf j (+ j 1)))                 (setf subpat "d")))         ((equal (car (nth i lis)) '>)          (progn (while (match-p1 '(>) (list (car (nth (+ i j) lis))))                               (setf j (+ j 1)))                 (setf subpat "a")))         ((equal simb 'c-patch-box-kant::j)          (progn                  (while (match-p1 '(j) (list (car (nth (+ i j) lis))))                               (setf j (+ j 1)))                 (setf subpat "j"))))        (push (list (- (second (nth i lis)) 1)  subpat) rep)        (setf i (+ i j))))    (reverse rep)))