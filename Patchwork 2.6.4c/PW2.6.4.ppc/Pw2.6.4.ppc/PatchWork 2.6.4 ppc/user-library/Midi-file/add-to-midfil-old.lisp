(in-package "PW");;---------------- add-to-midfil -------------------;;----------in pw->mf-write.lisp---------------(defun  write-midi-file (liste format nom-fich)  (let ((score-list (make-instance 'lp-scores))        (current-score (make-instance 'lp-score)))    (set-bits-per-beat current-score 480)           (setf  *tempo* 60 (slot-value current-score 'tempo-bpm) *tempo*)    (if (atom (caar liste))      (progn (setf  (events current-score) liste)             (push current-score (scores  score-list)))      (dolist (elt liste (setf (scores  score-list) (reverse (scores  score-list))))        (push (make-instance 'lp-score :events  elt) (scores  score-list))))    (track-writ-lp (flat  (mf-writ-lp score-list format)) nom-fich)));;----------in pw-midi-fil-write.lisp---------------(defun tempo-mf (score)  (let ((tmp (num->n-vals-n               (* (/ 60 (print (get-tempo-bpm score))) 500000))))    (append (list 0 255 81 (length tmp)) tmp)));***********************************************;modifs def variable pour stocker bits/beat Adrien Russovich (03/96)(defvar *bits-per-beat* 480)(defclass lp-score ()  ((events :initarg :events :accessor events :initform nil :reader get-events)   (bits-per-beat :initarg :bits-per-beat :initform *bits-per-beat* :reader get-bits-per-beat)   (bits-per-second :initarg :bits-per-second :initform *bits-per-beat*)   (tempo-bpm :initarg :tempo-bpm :initform 60 :reader get-tempo-bpm)   (score-name :initarg :score-name :accessor score-name :initform "No Name" :reader get-score-name)   (score-length  :initform 0 :reader get-score-length)   (last-event :initform nil)   (first-event-time :initform nil)   (rest-of-events :initform nil)   (output-channel :initarg :output-channel :initform 0                   :accessor output-channel)))(defun read-header (instream)  (let ((length (n-bytes-to-num 4 instream))         (format (n-bytes-to-num 2 instream))         (ntrks  (n-bytes-to-num 2 instream)))    (declare (ignore length format ntrks))    (set-bits-per-beat *current-score* (n-bytes-to-num 2 instream))    (setf *bits-per-beat* (get-bits-per-beat *current-score*))))           ;setf bits/beat(defun read-set-tempo ( instream)  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream)    (let ((tempo (round 6.0E+7                        (n-bytes-to-num 3 instream))))      (setf *tempo* tempo)      (format t "tempo ~a ~%"  tempo)      (push (list (round (* (/ *current-time* (get-bits-per-beat *current-score*)) 100)) *tempo*) *tempi*) ;lp 01/96      (+ 2 length-o-length length))));**********************************************;*********** dynamique tempo ******************;new(defun read-set-tempo ( instream)  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream)    (let ((tempo (round 6.0E+7                        (n-bytes-to-num 3 instream))))      (setf *tempo* tempo)      (format t "tempo ~a ~%"  tempo)      (push (list *current-time*  *tempo*) *tempi*) ;lp 04/96      (+ 2 length-o-length length))));old(defun read-set-tempo ( instream)  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream)    (let ((tempo (round 6.0E+7                        (n-bytes-to-num 3 instream))))      (setf *tempo* tempo)      (format t "tempo ~a ~%"  tempo)      (push (list (round (* (/ *current-time* (get-bits-per-beat *current-score*)) 100)) *tempo*) *tempi*) ;lp 01/96      (+ 2 length-o-length length))));new(defun read-midi-file (&optional (filename (choose-file-dialog :mac-file-type "Midi")))  "permet d'aller lire un fichier MIDI-FILEet retourne une liste d'objets correspondant chacun ˆ une piste du fichier MIDI-FILEattention, suivant le format MIDI-FILE:format 0 = tous les Žvnements sont sur une mme pisteformat 1 = les pistes sont sŽparŽes et la premirene contient que des infos gŽnŽrales (tempo etc...)"  (setf *score-list* ())  (catch 'file-error    (with-open-file (instream filename                              :element-type 'unsigned-byte)      (setf  *tempi* ())                                                         ;initialisation lp 3/04      (do ((chunk-type (get-chunk-type instream) (get-chunk-type instream)))          ((eql chunk-type *end-o-stream*))        (setq *current-score* (make-instance 'lp-score)              *current-time* 0              *running-type* 0              *running-channel* 0              )        (cond         ((equal chunk-type *header-chunk-name*)          (read-header instream))         ((equal chunk-type *track-chunk-name*)          (read-track instream))         (t          (read-garbage-chunk instream)))))    (setf *tempi* (reverse *tempi*) *score-list* (reverse *score-list*))));------------- lecture tempo -------------(defun nbits->tpos (nbits)  "donne la position (1/100e sec.) dans le temps d'un evenement en fonction des tempi"  (print "mjh")(let ((n 1) (curtime 0))    (while (> nbits (if (<= (length *tempi*) n) nbits (first (nth n *tempi*))))      (incf curtime (/ (* (/                            (- (first (nth n *tempi*))(first (nth (1- n) *tempi*)))                           (get-bits-per-beat *current-score*)) 6000)                        (second (nth (1- n) *tempi*))))      (incf n))    (+ curtime (/ (* (/                       (- nbits (first (nth (1- n) *tempi*)))                      (get-bits-per-beat *current-score*)) 6000)                   (second (nth (1- n) *tempi*))))))      ;(nbits->tpos 0);(nbits->tpos (* 9 1024));(nbits->tpos 0);(setf *tempi* '((0 60)(4096 120)))