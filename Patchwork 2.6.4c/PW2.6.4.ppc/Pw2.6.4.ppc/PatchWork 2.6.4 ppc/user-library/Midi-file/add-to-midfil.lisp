(in-package "PW");;---------------- add-to-midfil -------------------;;----------in pw->mf-write.lisp---------------(defun  write-midi-file (liste format nom-fich)  (let ((score-list (make-instance 'lp-scores))        (current-score (make-instance 'lp-score)))    (set-bits-per-beat current-score 480)           (setf  *tempo* 60 (slot-value current-score 'tempo-bpm) *tempo*)    (if (atom (caar liste))      (progn (setf  (events current-score) liste)             (push current-score (scores  score-list)))      (dolist (elt liste (setf (scores  score-list) (reverse (scores  score-list))))        (push (make-instance 'lp-score :events  elt) (scores  score-list))))    (track-writ-lp (flat  (mf-writ-lp score-list format)) nom-fich)));;----------in pw-midi-fil-write.lisp---------------(defun tempo-mf (score)  (let ((tmp (num->n-vals-n               (* (/ 60 (print (get-tempo-bpm score))) 500000))))    (append (list 0 255 81 (length tmp)) tmp)));***********************************************;modifs def variable pour stocker bits/beat Adrien Russovich (03/96)(defvar *bits-per-beat* 480)(defclass lp-score ()  ((events :initarg :events :accessor events :initform nil :reader get-events)   (bits-per-beat :initarg :bits-per-beat :initform *bits-per-beat* :reader get-bits-per-beat)   (bits-per-second :initarg :bits-per-second :initform *bits-per-beat*)   (tempo-bpm :initarg :tempo-bpm :initform 60 :reader get-tempo-bpm)   (score-name :initarg :score-name :accessor score-name :initform "No Name" :reader get-score-name)   (score-length  :initform 0 :reader get-score-length)   (last-event :initform nil)   (first-event-time :initform nil)   (rest-of-events :initform nil)   (output-channel :initarg :output-channel :initform 0                   :accessor output-channel)))(defun read-header (instream)  (let ((length (n-bytes-to-num 4 instream))         (format (n-bytes-to-num 2 instream))         (ntrks  (n-bytes-to-num 2 instream)))    (declare (ignore length format ntrks))    (set-bits-per-beat *current-score* (n-bytes-to-num 2 instream))    (setf *bits-per-beat* (get-bits-per-beat *current-score*))))           ;setf bits/beat;(defun read-set-tempo ( instream);  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream);    (let ((tempo (round 6.0E+7;                        (n-bytes-to-num 3 instream))));      (setf *tempo* tempo);      (format t "tempo ~a ~%"  tempo);      (push (list (round (* (/ *current-time* (get-bits-per-beat *current-score*)) 100)) *tempo*) *tempi*) ;lp 01/96;      (+ 2 length-o-length length))));**********************************************;*********** dynamique tempo ******************;new(defun read-set-tempo ( instream)  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream)    (let ((tempo (round 6.0E+7                        (n-bytes-to-num 3 instream))))      (setf *tempo* tempo)      (format t "tempo ~a ~%"  tempo)      (push (list *current-time*  *tempo*) *tempi*) ;lp 04/96      (+ 2 length-o-length length))));old;(defun read-set-tempo ( instream);  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream);    (let ((tempo (round 6.0E+7;                        (n-bytes-to-num 3 instream))));;      (setf *tempo* tempo);      (format t "tempo ~a ~%"  tempo);      (push (list (round (* (/ *current-time* (get-bits-per-beat *current-score*)) 100)) *tempo*) *tempi*) ;lp 01/96;      (+ 2 length-o-length length))));new(defun read-midi-file (&optional (filename (choose-file-dialog :mac-file-type "Midi")))  "permet d'aller lire un fichier MIDI-FILEet retourne une liste d'objets correspondant chacun ˆ une piste du fichier MIDI-FILEattention, suivant le format MIDI-FILE:format 0 = tous les Žvnements sont sur une mme pisteformat 1 = les pistes sont sŽparŽes et la premirene contient que des infos gŽnŽrales (tempo etc...)"  (setf *score-list* ())  (catch 'file-error    (with-open-file (instream filename                              :element-type 'unsigned-byte)      (setf  *tempi* ())                                                         ;initialisation lp 3/04      (do ((chunk-type (get-chunk-type instream) (get-chunk-type instream)))          ((eql chunk-type *end-o-stream*))        (setq *current-score* (make-instance 'lp-score)              *current-time* 0              *running-type* 0              *running-channel* 0              )        (cond         ((equal chunk-type *header-chunk-name*)          (read-header instream))         ((equal chunk-type *track-chunk-name*)          (read-track instream))         (t          (read-garbage-chunk instream)))))    (setf *tempi* (reverse *tempi*) *score-list* (reverse *score-list*))));------------- lecture tempo -------------(defun nbits->tpos (nbits)  "donne la position (1/100e sec.) dans le temps d'un evenement en fonction des tempi"  ;(print "m jh")(let ((n 1) (curtime 0))    (while (> nbits (if (<= (length *tempi*) n) nbits (first (nth n *tempi*))))      (incf curtime (/ (* (/                            (- (first (nth n *tempi*))(first (nth (1- n) *tempi*)))                           (get-bits-per-beat *current-score*)) 6000)                        (second (nth (1- n) *tempi*))))      (incf n))    (+ curtime (/ (* (/                       (- nbits (first (nth (1- n) *tempi*)))                      (get-bits-per-beat *current-score*)) 6000)                   (second (nth (1- n) *tempi*))))))      ;(nbits->tpos 5120 );(nbits->tpos (* 5 1024));(nbits->tpos 0);(nbits->tpos date);(setf *tempi* '((0 60)(4096 120)))(defmethod mf->pw-sco ((self lp-score))  (let ((score (get-events+bk self))        (L ()) (new-score (make-instance 'lp-score))        date  params event-typ event)    (dotimes (n (length score)(setf (events new-score) (reverse L)))       (setf event (pop score)            date (car event)            event-typ (car (cadr event))            params (cdr (cadr event)))      (if (equal event-typ "note-off") nil          (if (equal event-typ "sysex")              (push  (list (nbits->tpos date)                     (cadr event)) L)                        (push (list (round (nbits->tpos date))                        (if (equal event-typ "note-on") "note" event-typ)                        (1+ (first params))                        (cond ((equal event-typ "note-on")                               (* 100 (second params)))                              ((equal event-typ "pitch-bend")                                (cadr (pb-2bit->val params)))                              (t                                (second params)))                        (third params)                        (if (equal event-typ "note-on")                           (round (get-dur date params score))  ;ar change 4/4/96                          50)) L))))    new-score))(defun get-dur (date1 params events)   ; modifs ar 4/4/96 : ajout nbits->tpos  (let ((param-aux (list (first params)                         (second params) 0)))    (if (endp events) '(50)        (let ( dur)          (until dur            (cond ((null events) (setf dur 50))                  ((< (car (first events )) date1)                   (pop events))                  ((equal param-aux (cdadr (first events)))                   (setf dur (- (nbits->tpos(car (first events))) (nbits->tpos date1))))                  (t                    (pop events))))          dur))))#|(defvar *texte* ());texte lecture(defun read-text-event ( instream)  (multiple-value-bind (length length-o-length) (get-var-length-quantity instream)   ;(format t "text ~%")     (read-text-aux length instream)    (+ 2 length-o-length length)))(defun read-text-aux (garbage-length instream)     (push (list *current-time* (n-bytes-to-string length instream)) *texte*))|#