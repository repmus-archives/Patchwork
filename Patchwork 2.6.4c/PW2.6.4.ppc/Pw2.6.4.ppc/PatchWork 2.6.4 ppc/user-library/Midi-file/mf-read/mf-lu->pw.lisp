(in-package "PW");(setf coin (read-mf));(get-events (car coin))(defunp read-mf (&optional (filename list ( :value  '() :type-list '(string)))) list        "permet d'aller lire un fichier MIDI-FILEet retourne une liste d'objets correspondant chacun à une piste du fichier MIDI-FILEattention, suivant le format MIDI-FILE:format 0 = tous les évènements sont sur une même pisteformat 1 = les pistes sont séparées et la premièrene contient que des infos générales (tempo etc...)"  (unless filename     (setf filename (CCL:choose-file-dialog :directory *lastfile-mid* :mac-file-type "Midi" :button-string "MidiFile")))  (when  filename    (setf *lastfile-mid* filename)    (read-midi-file filename)))                                        ;   ** donne la liste des evts si liste est un score, nil sinon;defmethod ???(defun get-events+bk (liste)         (if liste (get-events liste)));   ** fonction qui extrait d'une liste d'évènements ceux dont le type correspond à event-typ(defun if-event-xtrait (event-data event-typ)   "event-typ : note-on, note-off, ctrl etc ...  en string   permet d'extraire tout évènement MIDI avec sa date à partir d'un evt (0 (\"note-on\" 0 60 100))"  (cond ((equal (caadr event-data) event-typ)         (cons (/ (* (/ (car event-data)(get-bits-per-beat *current-score*)) 6000) *tempo*)               (cond  ((or (equal event-typ "note-on")                           (equal event-typ "note-off"))                       (midievt->midicsevt (cdadr event-data)))                      ((equal event-typ "pitch-bend")                       (pb-2bit->val (cdadr event-data)))                      ((equal event-typ "sysex")                       (cdadr event-data))                      (t                       (cons (1+ (cadadr event-data))                             (cddadr event-data))))))        (t ())));(if-event-xtrait (nth 2 (get-events+bk (nth 0 (read-midi-file)))) "note-on");(if-event-xtrait '(37679 ("note-on" 0 61 53)) "note-on");(get-events+bk (car coin)));**********************************************************(defun pb-2bit->pb-1bit (coin) (+ 0 (floor (* (/ (+ 8128 coin) 16256) 128))));(pb-2bit->pb-1bit -8128)(defun pb-2bit->val (coin)     (list (pop coin) (+ (pop coin)(* (- (pop coin) 64) 128))));(pb-2bit->val '(0 0 0))-> (0 -8192)(defun val->pb-2bit (coin)  (multiple-value-bind (dizain unit)(floor (/ (cadr coin) 128))    (list (car coin) (* unit 128) (+ dizain 64))));(val->pb-2bit '(0 -8192));**********************************************************(defun sco->evts (scores event-typ n-track)  "event-typ : note-on, note-off, ctrl etc..en string,    n-track = numero de la piste du fichier"  (let ((events ()) event (track (get-events+bk (nth n-track scores))))(while track  (setf event (if-event-xtrait (pop track) event-typ))      (if event        (push event events)))(reverse events))); (sco->evts (read-midi-file) "note-on" 0) ; trop lent 11/7/93 !?? pas sur;************************************************************************;** params = '(0 67 64) = '(ch note vel)->'(1 6700 64)(defun midievt->midicsevt (params)     (list (1+ (pop params)) (* 100 (pop params)) (pop params)));(midievt->midicsevt '(0 64 64))-->(1 6400 64);*******************************************(defun sco->ctrl (scores n-trk)  "donne la liste des controleurs avec leurs dates"(sco->evts scores "ctrl" n-trk))(defun sco->pitchb (scores n-trk)  "donne la liste des valeurs de pitchbend avec leurs dates"(sco->evts scores "pitch-bend" n-trk));****************************************************(defun get-dur2 (date1 params events)  (let ((param-aux (list (first params)                         (second params) 0)))    (if (endp events) '(50)        (let ( dur)          (until dur            (cond ((null events) (setf dur 50))                  ((< (car (first events  )) date1)                   (pop events))                  ((equal param-aux (cdadr (first events)))                   (setf dur (- (car (first events)) date1)))                  (t                    (pop events))))          dur))));(get-dur2 0 '(0 61 64) '((1680 ("note-off" 0 61 0))));************************************************************(defmethod mf->pw-sco ((self lp-score))  (let ((score (get-events+bk self))        (L ()) (new-score (make-instance 'lp-score))        date params event-typ event)    (dotimes (n (length score)(setf (events new-score) (reverse L)))   ;don't remove nil ???      (setf event (pop score)            date (car event)            event-typ (car (cadr event))            params (cdr (cadr event)))      (if (equal event-typ "note-off") nil          (if (equal event-typ "sysex")              (push  (list (/ (* (/ date (get-bits-per-beat *current-score*)) 6000) *tempo*)                     (cadr event)) L)                        (push (list (round (/ (* (/ date (get-bits-per-beat *current-score*)) 6000) *tempo*))                        (if (equal event-typ "note-on") "note" event-typ)                        (1+ (first params))                        (cond ((equal event-typ "note-on")                               (* 100 (second params)))                              ((equal event-typ "pitch-bend")                                (cadr (pb-2bit->val params)))                              (t                                (second params)))                        (third params)                        (if (equal event-typ "note-on")                          (round (/ (* (/ (get-dur2 date params score) (get-bits-per-beat *current-score*)) 6000) *tempo*))  ;lp change 9/1/95                          50)) L))))    new-score));(setf coin (mf->pw-sco (cadr (read-midi-file))));(events coin);(read-midi-file-f);**************************************************************(defmethod pwscore->events ((self lp-score) &optional types)  "si type: filtrage des evnts sinon rien de plus"  (let ((L ())        ;;;;;;;;;flat-event        )    (format t "recherche des evnts ~a" types)    (if types (dolist (event (get-events self)(reverse L))                (progn  (if (atom types)(setf types (list types))())                        (if (member (cadr event) types :test #'equal)  ;modif 11/7/93: caadr au lieu de second                          (push event L)())))        (dolist (event (get-events self) (reverse L))(push (flat event) L);         (setf flat-event (flat event));          (push (list (car flat-event);                      (second flat-event);                      (third flat-event)  ; change lp 17/2/95;                      (fourth flat-event);                      (fifth flat-event);                      (sixth flat-event)) L)))));(pwscore->events (mf->pw-sco (car (read-midi-file))) "ctrl");(get-events (car (read-midi-file)));(caadr '(0 ("note-on" 0 60 100)))(defunp sco->Levents ((scores list)(n-trck fix/float)                      &optional (typs list)) list        "input:a list of scores, output: a list of events (50 \"note\" 1 6000 64 1000) = (date (100e sec) typ ch midic vel dur (100e sec))"  (if typs    (pwscore->events (mf->pw-sco (nth n-trck scores)) typs)    (pwscore->events (mf->pw-sco (nth n-trck scores)))));(pwscore->events (mf->pw-sco (nth n-trck scores)) types);(pwscore->events coin "note");**************** objets ********************;redéfinition de sco->notes(defun sco->notes (scores n-track)  (let ((score (pwscore->events (mf->pw-sco (nth n-track scores)) "note")))    (mapcar #'(lambda(elt)(cons (car elt)(cddr elt))) score))); (sco->notes (read-midi-file) 1);  ** fournit la liste des pistes comme autant d'objets ch-lines(defun sco->ch-lines (scores)   "founit un objet chord-lines"  (let ((n-trks (length scores))        (events ())        (chord-line ())        (L ()))    (if (= n-trks 1)      (progn (setf events (sco->notes scores 0)                   chord-line (make-instance 'C-Chord-line :chords (events->chords events)))             (push chord-line L))      (dotimes (n n-trks (cdr (reverse L)))        (setf events (sco->notes scores n)              chord-line (make-instance 'C-Chord-line :chords (events->chords events)))        (push chord-line L))))); (chords (car (sco->ch-lines coin)))  ;  ** fournit la liste des chords de la piste n(defun sco->chds (scores n-trk)   "founit un objet chord-lines"  (events->chords (sco->notes scores n-trk)));  ** fabrique un objet 'C-note à partir d'une liste (50 0 6200 64 50)(defun event->note (event)  (make-instance 'C-note :midic (third event)                 :dur (nth 4 event)                 :vel (nth 3 event)                 :chan (second event)));  ** fabrique une liste de chords à partir d'une liste d'évents(defun events->chords (events)  (let ((date "depart")        (actual-chd ())        (L ()))    (dolist (event events (reverse (push actual-chd L)))      (if (eq date (car event))        (add-new-note actual-chd (event->note event))        (progn (if actual-chd (push actual-chd L)                   ())               (setf date (car event))               (setf actual-chd (make-c-chord date (list (event->note event)))))        ))))#|(setf couin (events->chords '((1050 0 6000 64 75)                              (1050 0 6200 64 50)                              (1050 0 6400 64 50)                              (1150 0 6500 64 25)                              (1175 0 6700 64 25))))(midic (nth 1 (notes (nth 1 couin))))|#;**************** utilitaire ************************(defunp nth-relist ((nieme fix/float)(nots-durs list))        list    "recupere les niemes elts de la liste <not-durs>   et met chaque elt entre parenthèses "  (if (atom (car nots-durs))(mapcar #'list  nots-durs)      (mapcar #'list (nth nieme nots-durs))))(defunp set-tempo ((tempo integer)) nil"you can write the value of the tempo and eval the modul in order to give the tempo to the midi-file you want to save (cf Alex for more information)"  (setf *tempo* tempo))  ;lp change 9/1/95;**************** menus *****************************(defparameter *MIDI-FILE*  (pw::new-menu "MIDI-FILE"))(pw::add-menu-items PW::*pw-menu-patch* *MIDI-FILE*)(PW::PW-addmenu-fun  *MIDI-FILE* 'read-mf)(add-menu-items *MIDI-FILE* (new-leafmenu "-" ()))(pw::pw-addmenu-fun *midi-file* 'sco->Levents)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->evts)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->notes)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->ctrl)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->pitchb)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->chds)(PW::PW-addmenu-fun  *MIDI-FILE* 'sco->ch-lines)(add-menu-items *MIDI-FILE* (new-leafmenu "-" ()));;(PW::PW-addmenu-fun  *MIDI-FILE* 'nth-relist);;(PW::PW-addmenu-fun  *MIDI-FILE* 'set-tempo)