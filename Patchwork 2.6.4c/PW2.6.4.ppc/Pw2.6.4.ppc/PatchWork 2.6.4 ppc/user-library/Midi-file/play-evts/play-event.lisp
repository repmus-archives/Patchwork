(in-package "PW")(in-package "C-PW-SEND-MIDI-NOTE")(defunp play-events ((evtyp string)(mi-nber midic) (vel-val (midic (:value 100)))                        (chan (approx (:type-list (fixnum list))))                        (durs (fix>=0 (:value 100 :type-list (fixnum list))))                        (at-time (fix>=0 (:type-list (fixnum list))))) list"Constructs and sends a event, list of event, or list of lists of event with thegiven parameters to MIDI, result for ex.: (snd-midievent \"note\" 6000 64 1 100 0)tutorial : \"midi-file:play-events:make-seq->comp\""  (snd-midievent evtyp  mi-nber  vel-val chan durs at-time));(snd-midievent "note" 6000 64 1 100 0);(play-events  '("note" "note") '(6000 6700)'(64 64) '(1 1) '(100 100) 0);(play-chords   '(6000 6700)'(64 64) '(1 1) '(100 100))#|(defunp snd-midievent ((evtyp string)(mi-nber midic) (vel-val (midic (:value 100)))                        (chan (approx (:type-list (fixnum list))))                        (durs (fix>=0 (:type-list (fixnum list))))                        (at-time (fix>=0 (:type-list (fixnum list))))) list"<snd-midievent> formats and plays MIDI events.  If <mi-nber> is a list, then the result will be a chord.  Event will be played with a channel <chan> velocity  <vels>  and duration <durs> as determined by the inputs.   If midics is a list of lists then snd-midievent will produce a sequence of chords.  at-time determines the start time (in 100ths of a second relative to time zero)for each chord.  If the  input <at-time> is a single value, chords will be equally spaced in time by that value.  A list for <at-time> will give each chord in the list its own start time.  Note: if any of the argument lists is shorter than <midics>, the last value of those lists will be used to play the remaining notes."  (let ((eventtype (list! evtyp))        (midic-or-no (list! mi-nber))        (vel-val (list! vel-val))        (channel (list! chan))        (durs (list! durs))        (t-times (list! at-time))        (acum-t 0)        events-form)    (while (or midic-or-no vel-val channel durs t-times)      (setq events-form            (append              (set-event-forms (cond ((null eventtype) (list "note"))                                   ((consp (car eventtype))  (pop eventtype))                                   (t (prog1 eventtype (setq eventtype nil))))                              (cond ((null midic-or-no) (list 6000))                                   ((consp (car midic-or-no))  (pop midic-or-no))                                   (t (prog1 midic-or-no (setq midic-or-no nil))))                             (cond ((null channel) (list 1))                                   ((consp (car channel)) (pop channel))                                   (t (prog1 channel (setq channel nil))))                              (cond ((null vel-val) (list 100))                                   ((consp (car vel-val)) (pop vel-val))                                   (t (prog1 vel-val (setq vel-val nil))))                             (cond ((null durs) (list 75))                                   ((consp (car durs)) (pop durs))                                   (t (prog1 durs (setq durs nil))))                             (setq acum-t                                    (if t-times (pop t-times) (+ acum-t 50))))             events-form)))    (setq events-form (sort (copy-list events-form) '< :key #'car))    ;;(start (apdfuncall 80 (priority) 82     ;;                  'keep-playing-fun-forms2 events-form (caar events-form)))    ;;nil    ))|#(defunp snd-midievent ((evtyp string)(mi-nber midic) (vel-val (midic (:value 100)))                        (chan (approx (:type-list (fixnum list))))                        (durs (fix>=0 (:type-list (fixnum list))))                        (at-time (fix>=0 (:type-list (fixnum list))))) list"<snd-midievent> formats and plays MIDI events.  If <mi-nber> is a list, then the result will be a chord.  Event will be played with a channel <chan> velocity  <vels>  and duration <durs> as determined by the inputs.   If midics is a list of lists then snd-midievent will produce a sequence of chords.  at-time determines the start time (in 100ths of a second relative to time zero)for each chord.  If the  input <at-time> is a single value, chords will be equally spaced in time by that value.  A list for <at-time> will give each chord in the list its own start time.  Note: if any of the argument lists is shorter than <midics>, the last value of those lists will be used to play the remaining notes."  (let ((eventtype (list! evtyp))        (midic-or-no (list! mi-nber))        (vel-val (list! vel-val))        (channel (list! chan))        (durs (list! durs))        (t-times (list! at-time))        (acum-t 0)        events-form)    (while (or midic-or-no vel-val channel durs t-times)      (setq events-form            (cons              (set-event-forms (or (pop eventtype) "note")                              (or (pop midic-or-no) 6000)                              (or (pop channel) 1)                              (or (pop vel-val) 100)                              (or (pop durs) 75)                              (setq acum-t (or (pop t-times) (+ acum-t 50))))             events-form)))    (setq events-form (sort (copy-list events-form) '< :key #'car))    (start (apdfuncall 80 (priority) 82                       'keep-playing-fun-forms2 events-form (caar events-form)))    nil    )); (snd-midievent "note" 6000 64 1 100 0); (snd-midinote 6000 64 1 100); (snd-midievent '("pb" "ctrl") '(6000 7)'(64 127) '(1 1) '(100 100) '(10 5)); (snd-midinote  '(6000 6700)'(64 64) '(1 1) '(100 100))(defun set-event-forms (evtyp mi-nber channel vel-val durs t-time)  (list t-time durs channel mi-nber vel-val evtyp))#|(defun set-event-forms (evtyp mi-nber channel vel-val durs t-time) (let ((eventtype evtyp)        (midic-or-no mi-nber)        (vel-val vel-val)        (channel channel)        (durs durs)        event-forms)    (while (or midic-or-no vel-val channel durs)      (push (list t-time                  (or (pop durs) 75) (or (pop channel) 1) (or (pop midic-or-no) 6000)                  (or (pop vel-val) 100)(or (pop eventtype) "note")) event-forms))    (nreverse event-forms)))|#; (set-event-forms '("note") '(6000) '(64) '(1) '(100) 0); (set-note-forms '(6000) '(64) '(1) '(100) '(0) 0)(defmethod keep-playing-fun-forms2 (event-forms prev-delay)  (play-event-form (cdr (pop event-forms)))  (while (and event-forms (= prev-delay (caar event-forms)))    (play-event-form (cdr (pop event-forms))))  (if event-forms    (re-dfuncall (- (caar event-forms) prev-delay)  event-forms (caar event-forms))));suivant le type d'event (5e elt de event form) appel de diffŽrentes fcts;pourra tre Žtendu ˆ autre evnt MIDI;(defun play-event-form (event-form);  (cond ((equal (nth 4 event-form) "note");         (write-midi-note (first event-form) (second event-form) (truncate (third event-form) 100);                          (fourth event-form)));        ((equal (nth 4 event-form) "ctrl");         (PW::write-controller-value (second event-form) (third event-form);                                 (fourth event-form)));        ((equal (nth 4 event-form) "pitch-bend");         (PW::write-pitch-bend-value ;(second event-form) (pw::pb-2bit->pb-1bit  (third event-form))));))(defun play-event-form (event-form)  (cond ((equal (nth 4 event-form) "note")         (write-midi-note (first event-form) (second event-form) (truncate (third event-form) 100)                          (fourth event-form)))        ((equal (nth 4 event-form) "ctrl")         (PW::write-controller-value (second event-form) (third event-form)                                     (fourth event-form)))        ((equal (nth 4 event-form) "prg-chg")         (PW::write-program-change-value (second event-form) (third event-form)))        ((equal (nth 4 event-form) "pitch-bend")         (PW::write-pitch-bend-value           (second event-form) (pw::pb-2bit->pb-1bit  (third event-form))))        ));(defun play-event-form (event-form);  (case (nth 4 event-form);    ("note";     (write-midi-note (first event-form) (second event-form) (truncate (third event-form) 100);                      (fourth event-form)));    ("ctrl";     (PW::write-controller-value (second event-form) (third event-form);                                 (fourth event-form)));    ("prg-chg";     (PW::write-program-change-value (second event-form) (third event-form)));    ("pitch-bend";     (PW::write-pitch-bend-value ;      (second event-form) (pw::pb-2bit->pb-1bit  (third event-form))));    ));******************************************************************;******************************************************************(pw::pw-addmenu-fun pw::*pw-Midi-menu* 'C-pw-send-midi-note::play-events)