(in-package :PW);=================================================================(defvar *current-playing-midi-chord* ())(defvar *current-playing-midi-note* ())(defvar *current-playing-midi-port* ());=================================================================; from MN-note-chord-chord-line(defmethod play-chord ((self C-chord))  (setf *current-playing-midi-chord* self)  (tell (notes self) 'play-note));=================================================================(defun interpol5-fix (time t1 t2 v1 v2)  (let ((t-diff (- t2 t1)))    (if (zerop t-diff)       v1      (+ v1 (truncate (* (- time t1) (truncate (* (- v2 v1) 100) (- t2 t1))) 100) ))))#|;(setf scheduler::*print-on-late?* nil)(defun sample-bpf-to-lst (bpf count)  (let* ((times (GIVE-X-POINTS bpf))         (incr (/ (- (car (last times))(car times)) (1- count)))         res)     (for (i (car times) incr (car (last times)))        (push (round (bpf-out bpf i times t)) res))     (nreverse res)));(defun interpol5 (time t1 t2 v1 v2);   (+ v1 (* (- time t1) (/ (- v2 v1) (- t2 t1)))) );(setf g (make-array  '(30) :element-type '(unsigned-byte 8)));(setf (aref g 1) 0);(time (repeat 1000 (make-list 30)));(time (repeat 1000 (make-array  '(30) :element-type '(unsigned-byte 8))));(time (repeat 10000 (truncate (interpol5 7 4 90 10 40))));(time (repeat 10000 (interpol5-fix 7 4 90 10 40)));(time (repeat 10000 (interpol5 7 4 90 10 40)));(time (interpol 100 10 100))(defun sample-bpf-out-fix (bpf count low high)  (let* ((values (give-y-points bpf))         (times (give-x-points bpf))         (time-incr (/ (- (car (last times)) (car times)) (1- count)))          (current-t1 (car times))         (current-t2 (second times))         (current-v1 (car values))         (current-v2 (second values))         res);         (print (list current-t1 time-incr (car (last times))))    (for (time current-t1 time-incr (car (last times)));         (print (list 'res res  current-t1 time current-t2))         (unless (<= time current-t2)           (pop times)(pop values)           (setq  current-t1 (car times)                  current-t2 (second times)                  current-v1 (car values)                  current-v2 (second values)))            (push (interpol5-fix time current-t1 current-t2 current-v1 current-v2) res))           (print 'scale)          (scale-low-high (nreverse res) low high t)))   ;(time (length (sample-bpf-out-fix bpf1 30 0 100)));(time (length (sample-bpf-out-fix-vect bpf1 60 0 100)));(time (repeat 100 (sample-bpf-out-fix bpf1 30 0 100)));(time (repeat 100 (sample-bpf-out-fix-vect bpf1 30 0 100)));(time (repeat 100 (scale-low-high  (sample-bpf-to-lst bpf1 30)  0  100 t)))|#(defun sample-bpf-out-fix-vect (bpf count low high)  (setq count (1- count))  (let* ((values (give-y-points bpf))         (times (give-x-points bpf))         (time-incr (/ (- (car (last times)) (car times)) count))          (max-v (apply #'max values))         (min-v (apply #'min values))         (scfc (truncate (* (- high low) 100) (- max-v min-v)))         (current-t1 (car times))         (current-t2 (second times))         (current-v1 (car values))         (current-v2 (second values))         (res (make-array  (list (1+ count)) :element-type '(unsigned-byte 8)))         (index 0))     (for (time current-t1 time-incr (car (last times)))         (unless (<= time current-t2)           (pop times)(pop values)           (setq  current-t1 (car times)                  current-t2 (second times)                  current-v1 (car values)                  current-v2 (second values)))            (setf (aref res index)               (+               (truncate                 (* scfc                   (-                       (interpol5-fix time current-t1 current-t2 current-v1 current-v2)                       min-v))  100)                    low))            (incf index))       res));=================================================================(defmethod play-instrument ((self C-pw-window) note)  (let ((port (ask (controls self) 'connect-inputs-if-instrument-port-p)))    (when port        (play-instrument port note))))(defmethod play-instrument ((self C-chant-abstract-ins) note)  (let ((port (connect-inputs-if-instrument-port-p self)))    (when port        (play-instrument port note))));==============(defmethod give-structured-begin-time ((self C-patch-chant-port))   (t-time *current-playing-midi-chord*))(defmethod clock ((self C-patch-chant-port)) 0)(defmethod play-instrument ((self C-patch-chant-port) note)  (setf *current-playing-midi-note* note)  (setf *current-playing-midi-port* self)  (let ((midi-ins (patch-value self ())))     (tell midi-ins #'patch-value self))      (write-midicent-note (dur note) (chan note) (midic note) (vel note)));;(write-midi-note (dur note) (chan note) (/ (midic note) 100) (vel note))) or ??   ;====================================================================(add-pw-input-type 'midi-instrument-status-mbox-value-type 'C-menubox-val                   (list :view-size (make-point 36 14)                         :menu-box-list '(("paftr" . #xA0) ("contr". #xB0) ("prog" . #xC0) ("maftr" . #xD0) ("ptchb" . #xE0))                         :type-list '(fix) :value 0))(add-pw-input-type 'midi-instrument-status-mbox-bpf-type 'C-menubox-val                   (list :view-size (make-point 36 14)                         :menu-box-list '(("paftr" . #xA0) ("contr". #xB0) ("maftr" . #xD0) ("ptchb" . #xE0))                         :type-list '(fix) :value 0));====================================================================(defun write-mono-pressure-value (chan value)  (setq chan (1- chan))   (midi-write (make-midievent #xD chan value)))(defmethod play-midi-bpf-continue-contr ((self C-patch-chant-port) delay chan contr vect len ind)   (write-controller-value chan contr (aref vect ind))    (incf ind)   (when (< ind len) (re-dfuncall delay self delay chan contr vect len ind)))(defmethod play-midi-bpf-continue-pressure ((self C-patch-chant-port) delay chan key vect len ind)   (write-pressure-value  chan key (aref vect ind))   (incf ind)   (when (< ind len) (re-dfuncall delay self delay chan key vect len ind)))(defmethod play-midi-bpf-continue-mono-pressure ((self C-patch-chant-port) delay chan vect len ind)   (write-mono-pressure-value chan (aref vect ind))   (incf ind)   (when (< ind len) (re-dfuncall delay self delay chan vect len ind)))(defmethod play-midi-bpf-continue-pitch-bend ((self C-patch-chant-port) delay chan vect len ind)   (write-pitch-bend-value chan (aref vect ind))   (incf ind)   (when (< ind len) (re-dfuncall delay self delay chan vect len ind)));====================================================================(add-output-type 'midi-synth '(midi-synth))(defunp midi-bpf ((quant fix/float (:value 1 :min-val 1))                   (bpf bpf-view-small-pw-type)                  (status midi-instrument-status-mbox-bpf-type)                  (contr fix/float (:value 0 :min-val 0 :max-val 127))                  (low fix/float (:value 0 :min-val 0 :max-val 127))                  (high fix/float (:value 127 :min-val 0 :max-val 127)))        midi-synth        "midi bpf"  (let* ((bpf-vect            (sample-bpf-out-fix-vect bpf (truncate (dur *current-playing-midi-note*) quant) low high))         (port  *current-playing-midi-port*)          (chan  (chan *current-playing-midi-note*))        (ind 0)(len (length bpf-vect))) ;    (print bpf-vect)    (when bpf-vect        (case status            (#xA0 (apdfuncall 20 (priority) 15 #'play-midi-bpf-continue-pressure port quant chan (truncate (midic *current-playing-midi-note*) 100) bpf-vect len ind))           (#xB0 (apdfuncall 20 (priority) 15 #'play-midi-bpf-continue-contr port quant chan contr bpf-vect len ind))            (#xD0 (apdfuncall 20 (priority) 15 #'play-midi-bpf-continue-mono-pressure port quant chan bpf-vect len ind))            (#xE0 (apdfuncall 20 (priority) 15 #'play-midi-bpf-continue-pitch-bend port quant chan bpf-vect len ind)))))) (defunp midi-val ((status midi-instrument-status-mbox-value-type)                  (contr fix/float (:value 0 :min-val 0 :max-val 127))                  (val fix/float (:value 0 :min-val 0 :max-val 127)))        midi-synth        "midi val"        (let ((chan  (chan *current-playing-midi-note*)))         (case status            (#xA0 (write-pressure-value chan (truncate (midic *current-playing-midi-note*) 100) val))            (#xB0 (write-controller-value chan contr val))            (#xC0 (write-program-change-value chan val))            (#xD0 (write-mono-pressure-value chan val))            (#xE0 (write-pitch-bend-value chan val))))) ;===========================================================; for midi-istrument;;new !!! 22.4.93 ML(defmethod view-draw-contents ((self C-mini-bpf-view-chant)) (with-focused-view self   (draw-rect (point-h (view-scroll-position self)) (point-v (view-scroll-position self))(w self)(h self))    (if (open-state self)     (when (break-point-function self)       (draw-bpf-function             (break-point-function self) self nil (h-view-scaler self)(v-view-scaler self)))       (draw-string 3 9 (doc-string self)))))(defmethod display-only-points ((self c-patch-with-mini-bpf)) ())(defmethod display-only-points ((self C-abstract-M)) ())(defmethod display-only-points ((self C-chant-abstract-ins)) ());=============================================================================; menu;=============================================================================(defparameter *pw-midi-instrument-menu-item* (new-menu "midi instrument"))(add-menu-items *pw-menu-Music* *pw-midi-instrument-menu-item*)(defunp midi-supernote () () "Returns the pointer to the current super-note beeing played"  *current-playing-midi-note*)(pw-addmenu-fun *pw-midi-instrument-menu-item* 'midi-bpf 'C-patch-with-mini-bpf) (pw-addmenu *pw-midi-instrument-menu-item* '(midi-val midi-supernote))