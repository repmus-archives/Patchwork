;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;===============================================;          Counterpoint rules;===============================================(defun no-parallel-maj-thirds? (?1 ?2)"tritone in parallel thirds f-a g-h or g-h f-a"  (let ((?x (car (hc ?2)))         ?prev hdiff1 hdiff2)     (if (and ?x              (setq ?prev (prev-item ?x))              (setq hdiff2 (abs (- (m ?2) (m ?x))))             (or (= hdiff2 4) (= hdiff2 8))             (setq hdiff1 (abs (- (m ?1) (m ?prev)))))      (/= hdiff1 hdiff2)      t)))(defun  ballistic? (midi1 midi2 midi3)" midi1, midi2 and midi3 should form a 'ballistic' melodic movement.A ballistic movement allows two jumps in the same direction, but the larger jump has to be below the smaller one."  (let* ((up (< midi1 midi2 midi3))         (down (> midi1 midi2 midi3))         (mel-diff1 (abs (- midi1 midi2)))         (mel-diff2 (abs (- midi2 midi3)))         (jump-case? (or (> mel-diff1 2) (> mel-diff2 2)))         (same-direction? (or up down)))    (if (and jump-case? same-direction?)       (if up            (>=  mel-diff1 mel-diff2)           (<=  mel-diff1 mel-diff2))        t)))(defun no-same-direction-jumps? (?1 ?2)" applied only if if ?2 and ?item are both attack-items"  (let ((jump1 (- (m ?2) (m ?1)))        (fl t) ?prev jump2 (hslice (hslice ?2)))    (if (>= (abs jump1) 2)      (dolist (?item (hc ?2) fl)           (when (and (attack-item? hslice ?item)                    (setq ?prev (prev-item ?item))                   (setq jump2 (- (m ?item) (m ?prev)))                   (or (and (plusp jump1) (plusp jump2))                       (and (minusp jump1) (minusp jump2)))                   (>= (abs jump2) 2))          (setq fl nil) (return)))      fl)));================================================; voiceleading;================================================(defun one-stepwise-chord-movem? (?1)"two adjacent chords  should have at least one stepwise movementonly  attack-items are tested, at least 2 attack-items are required for the test"  (let* ((compl-chord (cons ?1 (hc ?1)))        compl-chord-with-prev) (if (and (complete-chord? ?1)          (setq compl-chord-with-prev                 (remove-if #'(lambda (?x) (or (not (prev-item ?x))                                               (not (attack-item? (hslice ?1) ?x))))                              compl-chord))          (> (length compl-chord-with-prev) 1))  ;; all prev-item+attack-items   (find-if #'(lambda (?X)                (stepwise? (m (prev-item ?x)) (m ?x)))           compl-chord-with-prev)    t)))(defun check-parallels? (?11 ?12 ?21 ?22 pc-int-pairs)  "   ?11       <-     ?12          ?21       <-     ?22checks whether the melodic movement in ?11-?12 in one voiceand ?21-?22 in another voice forms a parallel movement.PC-int-pairs (given as pitch-class interval pairs) defines the harmonic parallel movementswe are interested in. For instance if PC-int-pairs is as follows:((0 0) (7 7))it means that we want to check for parallel octaves or fifths."   (let ((harm-diff1 (mod (abs (- (m ?11) (m ?21))) 12))        (harm-diff2 (mod (abs (- (m ?12) (m ?22))) 12)))    (find-if #'(lambda (int-pair)                  (and (= harm-diff1 (first int-pair))                       (= harm-diff2 (second int-pair))))             pc-int-pairs)))#|; parallels allowed for three voices or more for fifths if the higher movement is stepwise!; pc-int-pairs should include fifths if stepwsise? is t !!(defun check-parallels? (?11 ?12 ?21 ?22 pc-int-pairs &optional (stepwise? ()))  "   ?11       <-     ?12          ?21       <-     ?22"   (let ((harm-diff1 (mod (abs (- (m ?11) (m ?21))) 12))        (harm-diff2 (mod (abs (- (m ?12) (m ?22))) 12))        high-note1 high-note2)    (if  (> (m ?12) (m ?22))  ;; soprano case?       (progn         (setq high-note1 (m ?11))         (setq high-note2 (m ?12)))       (progn         (setq high-note1 (m ?21))         (setq high-note2 (m ?22))))      ;(print (list high-note1 high-note2))         (find-if #'(lambda (int-pair)                       (and (= harm-diff1 (first int-pair))                            (= harm-diff2 (second int-pair))  ; parallels case                           (if stepwise?                       ; stepwise? flag t                              (if (member int-pair '((7 7) (6 7) (7 6)) :test #'equal) ; fifths case                                 (not (stepwise?  high-note1 high-note2))  ; no paralles if high-notes stepwise                                  t) ; octaves case                             t)))                  pc-int-pairs)))(defun parallels-no-stepwise-fifths? (?1 ?2)"   ?1            <-      ?2        prev-item     <-    (hc ?2)"   (find-if     #'(lambda (?x)       (and (attack-item? (hslice ?2) ?x)            (prev-item ?x)            (check-parallels? ?1 ?2  (prev-item ?x) ?x                               '((0 0) (7 7) (6 7)) t)))     (hc ?2)))(* ?1 ?2 (?if (if (pwcs::parallels-no-stepwise-fifths? ?1 ?2) nil t))    "no parallels only octaves, only (higher voice) stepwise p. fifths allowed ")                   ;================================================================(defun beat-parallels-no-stepwise-fifths? (?1 ?2 &key (dist 1))  "   ?1            <-      ?2        mel-pair      <-     (hc2)"   (let (mel-pair)    (find-if       #'(lambda (?x)         (and (attack-item? (hslice ?2) ?x)              (setq mel-pair (if (= dist 1)                                 (prev-item-on-downbeat ?x)                               (prev-item-on-downbeat-2 ?x)))               (check-parallels? ?1 ?2  mel-pair ?x                                 '((0 0) (7 7) (6 7)) t)))     (hc ?2))))(* ?1 ?2 (?if (if (pwcs::beat-parallels-no-stepwise-fifths? ?1 ?2) nil t))    "no beat-parallels only octaves, only (higher voice) stepwise p. fifths allowed ")                   |#(defun open-parallels? (?1 ?2 &optional (fifths? t))"   ?1            <-      ?2        prev-item     <-      ?xchecks if there are open parallels among the harmonic-context of ?2.Parallel octaves, parallel 5ths and tritones proceeding to perfect 5ths are disallowed. If the optional argument fifths? flag is nil then only parallel octaves are disallowed."   (find-if     #'(lambda (?x)       (and (attack-item? (hslice ?2) ?x)            (prev-item ?x)            (check-parallels? ?1 ?2  (prev-item ?x) ?x                               (if fifths? '((0 0) (7 7) (6 7)) '((0 0))))))     (hc ?2)))(defun downbeat-parallels? (?1 ?2 &key (dist 1) (fifths? t))"   ?1            <-      ?2        mel-pair      <-     (hc2)similar to the function open-parallels?, except all notes should bedownbeat notes"   (let (mel-pair)    (find-if       #'(lambda (?x)         (and (attack-item? (hslice ?2) ?x)              (setq mel-pair (if (= dist 1)                                 (prev-item-on-downbeat ?x)                               (prev-item-on-downbeat-2 ?x)))               (check-parallels? ?1 ?2  mel-pair ?x                                 (if fifths? '((0 0) (7 7) (6 7)) '((0 0))))))     (hc ?2))))(defun hidden-parallels? (?1 ?2 &optional (fifths? t))"   ?1            <-      ?2       mel-pair         <-     (hc2)checks if there are hidden parallels among the harmonic-context of ?2.Hidden octaves and 5ths are disallowed. If the optional argument fifths? flag is nil then only hidden octaves are disallowed."   (let ((hslice (hslice ?2))                (mel-diff1 (- (m ?2) (m ?1)))        mel-pair mel-diff2 harm-diff2)    (find-if       #'(lambda (?x)         (and (attack-item? hslice ?x)              (setq harm-diff2 (mod (abs (- (m ?x) (m ?2))) 12))              (setq mel-pair (prev-item ?x))              (setq mel-diff2 (- (m ?x) (m mel-pair)))              (or (and (plusp mel-diff1) (plusp mel-diff2))     ;; same direction                   (and (minusp mel-diff1) (minusp mel-diff2)))              (if fifths?                (or (= harm-diff2 0) (= harm-diff2 7))                 (= harm-diff2 0))))     (hc ?2))));================================================; harmonic;================================================(defun dissonant-bass-int? (int)"returns true if modulo 12 of int is a minor or major 2nd, a perfect 4th, a tritone, or a minor or major 7th."    (member (mod int 12) '(1 2 5 6 10 11)));(dissonant-bass-int? 17) (defun dissonant-upper-int? (int)"returns true if modulo 12 of int is a minor or major 2nd, or a minor or major 7th."    (member (mod int 12) '(1 2 10 11)));(dissonant-upper-int? (- 72 59)); typ3 1. q 2. q 3. q 4. q -> 2. or 4. dissonant; typ2      (2 ((?1 1))) + (2 (1.0 (?2 1)));;  (3/4)   (3 ((?1 3) (?2 1) 2)) (defun match-upbeat-rtm? (?1 ?2)"returns true if ?2 is an upbeat note, i.e. ?2 is on the unstressed part of the beat."  (or (match-rtm? (1 ((?1 1) (?2 1))))      (match-rtm? (2 ((?1 1) (?2 1) 1 1)))      (match-rtm? (2 (1 1 (?1 1) (?2 1))))      (match-rtm? (2 ((?1 3) (?2 1))))      ;; dotted cases      (and (match-rtm? (1 ((?1 1))))        ;; slured case           (match-rtm? (1 (1.0 (?2 1)))))))(defun cambiata-ints? (?1 ?2 ?3 ?4)"checks whether the four notes in the argument list form a cambiata succession of intervals"    (let ((int1 (- (m ?2) (m ?1)))         (int2 (- (m ?3) (m ?2)))        (int3 (- (m ?4) (m ?3))))    (and (or (= int1 -1) (= int1 -2))         (or (= int2 -3) (= int2 -4))         (or (= int3 1) (= int3 2)))))#|(defun cambiata-rtm? (?1 ?2 ?3 ?4)  (and (or (and (match-rtm? (1 ((?1 1)))) (match-rtm? (1 (1.0 (?2 1)))))  ;;slured           (match-rtm? (2 ((?1 3) (?2 1)))) ;; dotted        (or (and (match-rtm? (1 ((?3 1))))); (match-rtm? (1 ((?4 1))))) ;; 2 1/4s           (match-rtm? (1 ((?3 1) (?4 1))))))))  ;; 2 1/8s|#(defun cambiata-rtm? (?1 ?2 ?3 ?4)"checks whether the four notes in the argument list form a cambiata rtm-pattern"  (and (or (and (match-rtm? (1 ((?1 1)))) (match-rtm? (1 (1.0 (?2 1)))))  ;;slured           (match-rtm? (2 ((?1 3) (?2 1))))) ;; dotted        (or (match-rtm? (1 ((?3 1))))           (match-rtm? (1 ((?3 1) (?4 1))))))) ;; 2 1/8s;assumes that the lowest staff has always lowest pitch !!;; 1. match-rtm  2. dissonant  3. passing or side note 4. cambiata(defun harmonic-dissonance? (?1 &optional hc)"returns a dissonance s-variable if ?1 forms a harmonic dissonance or otherwise nil.Assumes that the lowest part has always the lowest pitch!"  (let ((ref-midi (m ?1))        (ref=bass-note (bass-item? ?1))        item=bass-note int)    (find-if       #'(lambda (?x)         (setq item=bass-note (bass-item? ?x))         (setq int (abs (- (m ?x) ref-midi)))         (if (or ref=bass-note item=bass-note)            (dissonant-bass-int? int)            (dissonant-upper-int? int)))     (or hc (hc ?1)))))   ;================================================; upbeat neighboring notes, passing notes and cambiata;================================================(defun upbeat-dissonance? (?1 ?2 ?3 ?4 &optional (only-down nil))"checks whether ?2 is an upbeat dissonanceThe optional argument, only-down, is a flag indicating if only downward neighbor notes are allowed"  (if (match-upbeat-rtm? ?1 ?2)                 ; 1    (let ((n1 (m ?1)) (n2 (m ?2)) (n3 (m ?3)))      (if (harmonic-dissonance? ?2)             ; 2        (or (and (cambiata-rtm? ?1 ?2 ?3 ?4)    ; 3                 (cambiata-ints? ?1 ?2 ?3 ?4))            (scale-movem? n1 n2 n3)             ; 4             (side-movem?  n1 n2 n3 only-down))  ; 5        t))    t))     ;(* ?1 ?2 ?3 ?4 (?if (upbeat-dissonance? ?1 ?2 ?3 ?4)) "upbeat neighboring notes, passing notes and cambiata");================================================; suspension;================================================;  dissonant voice (?1 = diss) :;;           slured   or  syncopated or  dotted;   (or  (1 (1.0 (?1 1)))  (2 ((?1 1))) (3 ((?1 1))) + (or (2 ((?2 1))) (1 ((?2 1) 1.0)); faster version ;   (2 ((?1 3) (?2 1)))  or (1 ((?1 1)) + (1 (1.0 (?2 1)));  consonant voice:;;   (2 (?i 1))       (defun suspension-rtm-match? (?1 ?2 ?D)"?1           ?2       ?Dmatches the possible suspension rtm-patterns  "  (and   (downbeat? ?D)                                                   ; 1.   (< (startt ?1) (startt ?D) (startt ?2))                         ; 2.   (or    (and                                                           ; fast version     (or  (match-rtm? (2 ((?1 3) (?2 1))))                         ; 3.           (and (match-rtm? (1 ((?1 1)))) (match-rtm? (1 (1.0 (?2 1))))))  ; 4.        (match-rtm? (1 ((?D 1)))))                                    ; 5.    (and                                                           ; slow version     (and (or (match-rtm3? ?1 (1 ((?1 1))) (1 (1.0)))              ; 6.                (match-rtm? (2 ((?1 1))))               (match-rtm? (3 ((?1 1)))))           (match-rtm? (1 ((?2 1))))                                ; 7.           (match-rtm? (2 ((?D 1)))))))))                           ; 8.#|(defun harmonic-dissonance2? (?1 ?2)  (let ((int (abs (- (m ?1) (m ?2)))))    (if (or (bass-item? ?1) (bass-item? ?2))       (dissonant-bass-int? int)       (dissonant-upper-int? int))))|#; should be mod 12 !! check(defun harmonic-dissonance2? (?1 ?2)"returns true if ?1 and ?2 form a harmonic dissonance"  (let ((int (mod (abs (- (m ?1) (m ?2))) 12)))    (if (or (bass-item? ?1) (bass-item? ?2))       (dissonant-bass-int? int)       (dissonant-upper-int? int))))(defun suspension-part1? (?D &optional (stepwise nil))  "?1             ?2?prev   ?Dchecks whether ?D is consonant or a potential suspension dissonance"  (if (downbeat? ?D)    (let ((?prev (prev-item ?D)) ?2 harmonic-dist)      (not        (find-if-not         #'(lambda (?1)             (if (harmonic-dissonance2? ?D ?1)              (and (setq ?2 (next-item ?1))                   (suspension-rtm-match? ?1 ?2 ?D)                   (if (and ?prev stepwise)                     (member (abs (- (m ?prev) (m ?1))) '(1 2)) t) ; stepwise                   (setq harmonic-dist (- (m ?1) (m ?D)))                   (if (plusp harmonic-dist) ; upper suspension?                     (member (mod harmonic-dist 12) '(5 10 11))                                 (member (mod (abs harmonic-dist) 12) '(1 2))))              t))               (hc ?D))))    t))(defun suspension-part2? (?1 ?2)  "?1             ?2?prev   ?D          checks that ?2 resolves the suspension when ?D is a suspension dissonance"  (if (downbeat? ?1)    (not      (find-if-not       #'(lambda (?D)           (if (and (downbeat? ?D)                    (suspension-rtm-match? ?1 ?2 ?D) ;; miksi pitŠŠ olla mukana ??                     (harmonic-dissonance2? ?1 ?D))            (member (- (m ?2) (m ?1)) '(-1 -2))            t))      (hc ?2)))    t))#|(* ?D (?if (suspension-part1? ?D)) "suspension 1.  rule")(* ?1 ?2 (?if (suspension-part2? ?1 ?2)) "suspension 2.  rule")|##|(mapcar #'(lambda (n) (read-from-string (first n))) (ccl::list-definitions (front-window)))))|#