;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;================================================;        Cartesian Product;================================================(PMC  '((a b c) (a b c) (a b c))       ()        :sols-mode :all);================================================;         Subset Indexes;================================================(PMC '((0 1 2 3 4) (0 1 2 3 4) (0 1 2 3 4))      '((* (?if (apply #'< l)) "Result in ascending order"))       :sols-mode :all);================================================;        All Permutations;================================================(PMC '((0 1 4 6) (0 1 4 6) (0 1 4 6) (0 1 4 6))      '((* ?1 (?if (not (member ?1 (rest rl)))) "No duplicates"))           :sols-mode :all) ;================================================;         Constraining Chords;================================================(PMC  (make-note-ranges 24 '(5 6) 12)       '((* ?1 (?if (not (member (mod ?1 12) (rest rl)                         :key #'(lambda (n) (mod n 12)))))             "No pitch class duplicates")         (* ?1 ?2 (?if (member (- ?2 ?1) '(5 6))) "Interval rule"))       :sols-mode :all);================================================;                Chains;================================================; with 4-1 (PMC         (make-list 24 :initial-element '(0 1 2 3 4 5 6 7 8 9 10 11))   '((* ?1 (?if (check-chain? l 6 '#.(all-subs '(6-z3a 6-5a 6-5b 6-z6 6-z11b 6-z12a 6-z12b                                      6-z17a 6-z17b 6-18a 6-18b 6-z36a 6-z38 6-z41a 6-z41b 6-z43a 6-z43b))))         "chain rule")     (* ?1 ?2 ?3 (?if (not (eq-SC? '(3-9 3-11a 3-11b) ?1 ?2 ?3)))          "Disallowed 3-member set-classes")     (i1 i2 i4 i8 (?if (eq-SC? '(4-1) i1 i2 i4 i8)) "index rule1")      (i3 i5 i7 i9 (?if (eq-SC? '(4-1) i3 i5 i7 i9)) "index rule2")     (i6 i10 i11 i13 (?if (eq-SC? '(4-1) i6 i10 i11 i13)) "index rule3")      (i12 i14 i17 i18 (?if (eq-SC? '(4-1) i12 i14 i17 i18)) "index rule4")     (i15 i16 i19 i20 (?if (eq-SC? '(4-1) i15 i16 i19 i20)) "index rule5")      (i21 i22 i23 i24 (?if (eq-SC? '(4-1) i21 i22 i23 i24)) "index rule6"))    :fwc-rules    '((i1 i2 i4 i8 (?if (eq-SC? '(4-1) i1 i2 i4 i8)) "index rule1")      (i3 i5 i7 i9 (?if (eq-SC? '(4-1) i3 i5 i7 i9)) "index rule2")     (i6 i10 i11 i13 (?if (eq-SC? '(4-1) i6 i10 i11 i13)) "index rule3")      (i12 i14 i17 i18 (?if (eq-SC? '(4-1) i12 i14 i17 i18)) "index rule4")     (i15 i16 i19 i20 (?if (eq-SC? '(4-1) i15 i16 i19 i20)) "index rule5")      (i21 i22 i23 i24 (?if (eq-SC? '(4-1) i21 i22 i23 i24)) "index rule6"))     :rnd? t :print-fl t) ;(0 3 5 1 6 7 4 2 3 9 8 11 6 0 7 9 1 2 6 8 0 1 11 2); with 4-7 and automatic index-rules(PMC      (make-list 24 :initial-element '(0 1 2 3 4 5 6 7 8 9 10 11)) (append    '((* ?1 (?if (check-chain? l 6 '#.(all-subs '(6-z3a 6-5a 6-5b 6-z6 6-z11b 6-z12a 6-z12b                                      6-z17a 6-z17b 6-18a 6-18b 6-z36a 6-z38 6-z41a 6-z41b 6-z43a 6-z43b))))         "chain rule")     (* ?1 ?2 ?3 (?if (not (eq-SC? '(3-9 3-11a 3-11b) ?1 ?2 ?3)))        "Disallowed 3-member set-classes"))   (mk-chain-index-rules '((1 2 4 8) (3 5 7 9) (6 10 11 13) (12 14 17 18)                      (15 16 19 20)  (21 22 23 24)) '(4-7))) :fwc-rules  (mk-chain-index-rules '((1 2 4 8) (3 5 7 9) (6 10 11 13) (12 14 17 18)                     (15 16 19 20)  (21 22 23 24)) '(4-7)) :rnd? t :print-fl t) ;(mk-chain-index-rules '((1 2 5 6) (4 7 8 10)) '((4-2a) (4-z15a 4-z15b 4-16a 4-16b)));(8 4 2 7 1 0 5 3 6 8 9 10 1 3 7 8 11 2 3 4 9 6 10 5); with 4-27a and automatic index-rules(PMC      (make-list 24 :initial-element '(0 1 2 3 4 5 6 7 8 9 10 11)) (append    '((* ?1 (?if (check-chain? l 6 '#.(all-subs '(6-z3a 6-5a 6-5b 6-z6 6-z11b 6-z12a 6-z12b                                      6-z17a 6-z17b 6-18a 6-18b 6-z36a 6-z38 6-z41a 6-z41b 6-z43a 6-z43b))))         "chain rule")    (* ?1 ?2 ?3 (?if (not (eq-SC? '(3-9 3-11a 3-11b) ?1 ?2 ?3)))        "Disallowed 3-member set-classes"))   (mk-chain-index-rules '((1 2 4 8) (3 5 7 9) (6 10 11 13) (12 14 17 18)                      (15 16 19 20)  (21 22 23 24)) '(4-27a))) :fwc-rules  (mk-chain-index-rules '((1 2 4 8) (3 5 7 9) (6 10 11 13) (12 14 17 18)                     (15 16 19 20)  (21 22 23 24)) '(4-27a)) :rnd? t :print-fl t) ;(0 2 1 5 11 6 7 8 4 3 9 10 1 2 8 3 4 7 5 11 10 3 0 6);================================================;                Subsets;================================================(defparameter *pitches*  '(68 69 79 70 76 51 78 67 77 49 48 81 50 80 63 64 82 83 66 65 62 60 71 61))(PMC  (make-list 4 :initial-element              '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23))           '((* ?1 (?if (apply #'< l)) "Result in ascending order")             (* ?1 ?2 (?if (<= (- ?2 ?1) 3)) "largest gap 3")             (* ?1 ?2 (?if (<= (count 3 (mapcar #'- (cdr l) l)) 1))                   "maximally one distance of 3")             (* ?1 (?if (let ((pitches (inds->vals  rl *pitches*)))                          (and (not (member (mod (car pitches) 12) (rest pitches)                                         :key #'(lambda (n) (mod n 12))))                                (member (SC-name pitches) '#.(all-subs '(4-z15a 4-z15b))))))                    "no PC-duplicates and given SC"))         :sols-mode :all) ;================================================; Automatic Rules and Statistical Distribution;================================================(PMC   (make-list 45 :initial-element    '(60 61 62 63 64 65 66 67 68 69 70 71      72 73 74 75 76 77 78 79 80 81 82 83))  '((* ?1 ?2       (?if        (let ((int (- ?2 ?1)))          (check-stats? int                        (count int (mapcar #'- (cdr l) l))                        '((7 -1) (5 3) (5 -5) (5 11) (4 -4)                          (3 -13) (3 -8) (2 -9) (1 8) (1 -11)                          (1 15) (1 20) (1 14) (1 -6) (1 9)                          (1 -2) (1 5) (1 6))                        1))) "Interval statistics")    (* ?1 ?2 ?3       (?if        (let* ((SCs (SC-distribution 3 l))                (SC (car (last SCs))))          (check-stats? SC                        (count SC SCs)                        '((7 3-3b) (6 3-1) (5 3-5b) (4 3-3a)                          (3 3-10) (3 3-2a) (3 3-2b) (3 3-4b)                          (2 3-4a)(2 3-5a) (1 3-12) (1 3-7b)                          (1 3-8a) (1 3-11b) (1 3-9))                        1))) "3-member set-class statistics")    (* ?1 ?2 ?3 ?4       (?if         (let* ((SCs (SC-distribution 4 l))                 (SC (car (last SCs))))          (check-stats? SC                        (count SC SCs)                        '((5 4-1) (4 4-3) (3 4-12b) (3 4-6)                          (2 4-19b) (2 4-12a) (2 4-27b) (2 4-2a)                           (2 4-8) (2 4-5b) (2 4-9) (1 4-7)                          (1 4-4a) (1 3-3b) (1 4-2b) (1 4-11a)                          (1 4-16b) (1 4-z15a) (1 4-4b) (1 3-2b)                          (1 4-z29b) (1 4-14b) (1 4-16a) (1 4-z15b))                        2))) "4-member set-class statistics")    (* ?1 ?2 ?3 ?4       (?if        (let* ((+-lists (+-distribution 3 l))                (+-list-ref (car (last +-lists))))          (check-stats? +-list-ref                        (count +-list-ref +-lists :test #'equal)                        '((13 (- + -)) (9 (- - +)) (9 (+ - -))                          (5 (+ - +)) (2 (- - -)) (2 (+ + -))                          (2 (- + +)))                        2))) "+- statistics"))    :rnd? t :print-fl t) ;================================================;           Atleast property;================================================(PMC (make-list  6 :initial-element '(0 1 2 3))  '((* ?1 (?if (atleast-cnt-check l (cur-slen) '((3 0) (2 1))))      "atleast check")    (* ?1 ?2 (?if (/= ?1 ?2)) "no adjacent dups")) :sols-mode :all)  ;================================================;                 Splitter;================================================(defparameter *pcs* '(0 1 2 3 6 7 0 1 8 2 3 9 0 7 8 1 2 5 0 6 11 1                     4 7 2 3 8 1 7 10 0 5 6 7 8 11))(defparameter *subs* (all-subs '(4-16b 4-16a 4-14a 4-8 4-6 4-5b))) ;================; 2 part splitter(PMC     (mapcar #'(lambda (n) (list (list 1 n) (list 2 n))) *pcs*)   '((* ?1 (?if          (let ((pcs (data-group-of-part rl 4 (sp-partnum ?1))))                 (if PCs                 (and (setp PCs) (member (SC-name PCs) *subs*))                    t))) "splitter rule")     (* ?1 (?if (let ((max-cnt 3))                  (if (>= (length rl) (1+ max-cnt))                    (<=  (count-adjacent-items rl                             #'(lambda (a b) (= (sp-partnum a) (sp-partnum b)))) max-cnt)                    t))) "max 3 adjacent notes in same part"))   :rnd? t);================; 3 part splitter(PMC    (mapcar #'(lambda (n) (list (list 1 n) (list 2 n) (list 3 n))) *pcs*) '((* ?1 (?if           (let ((PCs (data-group-of-part rl 4 (sp-partnum ?1))))               (if PCs              (and (setp PCs) (member (SC-name PCs) *subs*))                t))) "splitter rule")   (* ?1 (?if (let ((max-cnt 3))                (if (>= (length rl) (1+ max-cnt))                  (<=  (count-adjacent-items rl                          #'(lambda (a b) (= (sp-partnum a) (sp-partnum b)))) max-cnt)                  t))) "max 3 adjacent notes in same part")   (* ?1 (?if (let ((win 5))                (if (>= (length rl) win)                  (and (>= (count 1 rl :key #'sp-partnum :end win) 1)                       (>= (count 2 rl :key #'sp-partnum :end win) 1)                       (>= (count 3 rl :key #'sp-partnum :end win) 1))                  t))) "atleast one instance of each part inside 5 PCs")) :rnd? t)