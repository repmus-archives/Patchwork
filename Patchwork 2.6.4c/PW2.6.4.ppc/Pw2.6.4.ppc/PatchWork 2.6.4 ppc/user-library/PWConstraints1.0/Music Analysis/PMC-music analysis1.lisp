;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;========================; score-search-engine;========================(defclass analysis-search-engine (score-search-engine) ()) ;failed at: info maybe all s-vars?; currently prints the value of the last candidate !!(defmethod apply-rules-loop ((self analysis-search-engine) s-variable)  (let* ((prev-items-rev (read-key s-variable :prev-staff-items-rev))         (prev-items (read-key s-variable :svars-list))           (end-sitems-list (read-key s-variable :end-svars-list))         (candidates (domain s-variable))         (fns (rules self))         (no-attack-fns (no-attack-rules self))         (sindex (sindex s-variable))          (len sindex)          (rule-cnt 1))    (if (read-key s-variable :no-attack-s-item);; ??         (progn        (dolist (fn no-attack-fns)           (unless (funcall fn prev-items prev-items-rev len)            (terpri)            (format t "No-attack Rule no ~A '~A' failed at:                          staff ~A, measure ~A, beat ~A."                    rule-cnt (documentation fn 'function)                     (partnum s-variable) (measurenum s-variable)  (beatnum s-variable))))        t)      (progn (setf (nthcdr sindex prev-items) nil)             (dolist (fn fns)               (setf (value s-variable) (car candidates))               (unless (funcall fn prev-items prev-items-rev len) ;; 3 args len !!                  (terpri)                 (format t  "Rule no ~A '~A' failed at: part ~A, measure ~A, beat ~A, note ~A (~A)."                         rule-cnt (documentation fn 'function)                          (partnum s-variable) (measurenum s-variable) (beatnum s-variable)                          (car candidates) (pw::mc->n (* (car candidates) 100)))))             (setf (nthcdr sindex prev-items) end-sitems-list)))    t))(defmethod apply-rules ((self analysis-search-engine) s-variable)  (apply-rules-loop self s-variable)  (write-value-to-partial-sols-list self s-variable (first (domain s-variable)))  t);=======================================================(defun get-score-pitches (m-lines)  (mapcar #'(lambda (l)               (mapcar  #'(lambda (ch)                            (let ((midi (/ (pw::midic (first (pw::notes ch))) 100)))                             (list midi midi)))                        l))          (mapcar #'pw::get-rchords m-lines)))(defun score-MA-PMC (m-lines rules                                     &key (prepare-fns+args nil)                                   (class 'analysis-search-engine) )  (when (atom m-lines) (setq m-lines (list m-lines)))  (assert   (eq (type-of (first m-lines)) 'pw::c-measure-line) ()             "****1st input should be a list of pw::c-measure-lines !  ****" ())  (assert   (listp  rules) ()            "**** 2nd input should be a list of rules !! ****" ())  (setf *measure-lines* m-lines)  (let* ((ranges (get-score-pitches m-lines))         (staff-coll (polif-score->search m-lines ranges () ()))         (engine (make-score-engine                   staff-coll                  (mk-PMC-fns rules)                       :prepare-fns+args prepare-fns+args                  :class class))         (rule-cnt 1))    (terpri)    (format t  "===============================") (terpri)    (format t  "Analysis information for rules:")    (terpri)(terpri)      (dolist (fn (rules engine))      (format t  "~A. ~A" rule-cnt (documentation fn 'function))      (incf rule-cnt)      (terpri))     (format t  "===============================") (terpri)    (terpri)(terpri)    (start engine)    (terpri)    (values)));=======================================================