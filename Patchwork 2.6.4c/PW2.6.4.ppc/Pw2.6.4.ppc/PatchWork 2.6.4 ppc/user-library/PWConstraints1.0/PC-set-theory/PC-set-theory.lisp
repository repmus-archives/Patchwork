;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================(defparameter *SC-data-file* "PWConstraints:PC-set-theory;SCs-data.lisp")#|;===============================================; create data-PCS-file;===============================================(defparameter *all-sets*(let ((all-subsets (remove nil (all-subsets '(0 1 2 3 4 5 6 7 8 9 10 11))))      (res (list (list () '(0-1 0)))))  (dolist (set all-subsets)    (push (list set (pcs::set-name+off-from-points set)) res)) res));(length *all-sets*);(find '(0 1 4 6 8 9) *all-sets* :key #'first :test #'equal);(find '(6-31b 0) *all-sets* :key #'second :test #'equal)(progn  (setf *print-pretty* nil)    (with-open-file (out *SC-data-file* :direction :output :if-exists :supersede)      (prin1 `',*all-sets* out))    (in-package :cl-user)  (setf *print-pretty* t))|#(defvar *all-possible-chroma-subsets-hash* (make-hash-table :test #'equal))(defun fill-possible-chroma-subsets-hash ()  (let (sets-list)     (with-open-file (in *SC-data-file* :direction :input)      (setq sets-list (eval (read in))))    ;(in-package :cl-user)    (clrhash *all-possible-chroma-subsets-hash*)    (dolist (set sets-list)       (setf (gethash (first set) *all-possible-chroma-subsets-hash*)              (second set)))    (dolist (set sets-list)       (when (zerop (second (second set)))      (setf (get  (first (second set)) :prime) (first set))))))  (fill-possible-chroma-subsets-hash);===========================;===========================(defun prime (SC)"returns the prime form of SC"  (read-key SC :prime));(time (repeat 10000 (prime '4-17)));(prime '0-1);==============(defun calc-6vect (SC)  (let ((res (make-list 6 :initial-element 0))        (prime (prime SC))        temp int ref)    (while (cdr prime)      (setq ref (pop prime))      (setq temp prime)      (while temp        (setq int (- (first temp) ref))        (when (> int 6) (setq int (- 12 int)))        (setf (nth (1- int) res) (1+ (nth (1- int) res)))        (pop temp)))    res));(calc-6vect '3-1) ;(calc-6vect '0-1)           (defun store-SC-icvectors ()  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (setf (get SC :icv) (calc-6vect SC)))))(store-SC-icvectors);==============(defun card (SC)"returns the cardinality of SC"  (length (read-key SC :prime)));(time (repeat 10000 (card '12-1)))(defun ICV (SC)"returns the interval-class vector (ICV) of SC"  (read-key SC :icv));(time (repeat 10000 (ICV '4-17)));===========================;===========================(defun make-set (l)  (let (lst)    (while l (push (mod (pop l) 12) lst))    (sort (delete-duplicates  lst) #'<)))(defun SC-name-from-points (midis)  (car (gethash  (make-set midis) *all-possible-chroma-subsets-hash*)))(defun SC-name-from-pcs (pcs)"pcs has to be a list of  pitch classes (only numbers from 0 to 11)and should not include duplicates !!!"  (car (gethash (sort (copy-list pcs) #'<) *all-possible-chroma-subsets-hash*)))(defun SC-name+off-from-points (midis)  (gethash  (make-set midis) *all-possible-chroma-subsets-hash*))(defun SC-name+off-from-pcs (pcs)  (gethash  (sort (copy-list pcs) #'<) *all-possible-chroma-subsets-hash*))(defun SC-name (midis) "returns the SC-name of midis (a list of midi-values),midis can also be a list of lists of midis in which case SC-name returns the SC-names for each midi-value sublist"  (if (atom (car midis))    (car (gethash  (make-set midis) *all-possible-chroma-subsets-hash*))    (let (res)      (dolist (midis-l midis)        (push (car (gethash  (make-set midis-l) *all-possible-chroma-subsets-hash*)) res))      (nreverse res))));(SC-name '(62 66 69))(defun SC+off (midis)   "returns a list containing the SC-name and the offset (i.e. the transposition relative to the prime form of the SC)of midis (a list of midi-values),midis can also be a list of lists of midis in which case SC+off returns the SCs with offsets for each midi-value sublist"  (if (atom (car midis))    (gethash  (make-set midis) *all-possible-chroma-subsets-hash*)    (let (res)      (dolist (midis-l midis)        (push (gethash  (make-set midis-l) *all-possible-chroma-subsets-hash*) res))      (nreverse res))));(SC+off '(62 66 69));(SC+off '((62 66 69) (61 66 69)));===========================; subsets(defun indexi (x y fn)  (cond ((null x) y)          (t (funcall fn                 (car x)                 (indexi (cdr x) y fn)))))(defun all-subsets (x)  (cond ((null x) (list ()))        (t (indexi            (all-subsets (cdr x))            nil            (function (lambda (u v)                        (cons (cons (car x) u)                              (cons u v))))))));(all-subsets '(a b c))(defun all-subs (SCs)"returns all subset classes of SCs (a single SC or a list of SCs)" (if (atom SCs)    (remove-duplicates (mapcar #'(lambda (set) (SC-name-from-pcs set)) (all-subsets (prime SCs))))     (remove-duplicates      (apply #'append             (mapcar #'(lambda (SC)                         (remove-duplicates (mapcar #'(lambda (set) (SC-name-from-pcs set))                                                    (all-subsets (prime SC)))))                    SCs)))));(time (all-subs '6-z6)) ;(time (all-subs '10-1)) ;(time (all-subs '8-1)) ;(time (intersection card4 (all-subs '6-z6))) ;(time (intersection card4 (all-subs '8-6))) ;(time (intersection card6 (all-subs '10-1))) ;(time (all-subs '(6-z3a 6-5a 6-5b 6-z6 6-z11b 6-z12a 6-z12b 6-z17a 6-z17b 6-18a 6-18b 6-z36a 6-z38 6-z41a 6-z41b 6-z43a 6-z43b)))#|(defun store-SC-all-subs ()  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (all-subs SC))));      (setf (get SC :all-subs) (all-subs SC))))); too slow (109.628 seconds);(time (store-SC-all-subs)) |#;===========================(defun subsets (SC card)"returns all subset classes of cardinality card of SC"  (remove-duplicates   (mapcar #'SC-name-from-pcs           (PMC (make-list card :initial-element (prime SC))                '((* ?1 ?2 (?if (< ?1 ?2)))                  (* ?1 ?2 (?if (not (member ?2 (rest rl))))))                :sols-mode :all))));(time (subsets '8-6 4)) ;(time (subsets '6-z3a 4)) (defun supersets (SC card)"returns all superset classes of cardinality card of SC" (let* ((prime (prime SC))        (set-diff (nreverse (set-difference '(0 1 2 3 4 5 6 7 8 9 10 11) prime)))        (s-space (make-list (- card (card SC)) :initial-element set-diff)))  (remove-duplicates   (mapcar #'(lambda (l) (SC-name-from-pcs (append prime l)))            (PMC s-space                '((* ?1 ?2 (?if (< ?1 ?2)))                  (* ?1 ?2 (?if (not (member ?2 (rest rl))))))                :sols-mode :all)))));(time (supersets '4-z15a 9)) (defun sub/supersets (SC card)"returns all subset classes of SC (when card is less than the cardinality of SC)or superset classes (when card is greater than the cardinality of SC) of cardinality card."  (if (= (card SC) card)    SC    (if (> (card SC) card)      (subsets SC card)      (supersets SC card))));(sub/supersets '4-z15a 9);(sub/supersets '4-z15a 2)#|; for testing(defun normal-order (SC) (let (set)  (maphash      #'(lambda (key data)        (when (and (eq (first data) SC) (= (second data) 0))          (setq set key)))   *all-possible-chroma-subsets-hash*)  set)) (defun test-setns () (let ((lst (all-subsets '(0 1 2 3 4 5 6 7 8 9 10 11)))       (fl t))  (while (and fl lst)   (when (car lst)    (when (not (eq (first (gethash (car lst) *all-possible-chroma-subsets-hash*))                   (pcs::set-name-from-points (car lst))))       (setq fl nil)))     (pop lst))  fl));(test-setns)  (defun test-primes () (let (false)  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (unless (equal (pcs::prime (symbol-value SC)) (get SC :prime))        (print (list SC (pcs::prime (symbol-value SC)) (get SC :prime)))        (push SC false))))  false));(test-primes)(defun test-icvs () (let (false)  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (unless (equal (coerce (pcs::icv (symbol-value SC)) 'list) (get SC :icv))        (print (list SC (coerce (pcs::icv (symbol-value SC)) 'list) (get SC :icv)))        (push SC false))))  false));(test-icvs)(defun eq-lists (l1 l2) (let (c)  (while (and l1 l2)    (setq c (car l1))    (setq l1 (remove c l1))    (setq l2 (remove c l2)))  (list l1 l2)))|#