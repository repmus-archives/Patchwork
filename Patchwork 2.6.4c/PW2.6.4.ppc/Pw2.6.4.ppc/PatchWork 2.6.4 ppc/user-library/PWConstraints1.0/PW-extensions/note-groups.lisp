(in-package :pw);========================================(defvar *beat-x-cordinate* ());========================================; problems:; monophonic drawing when staff count >1 OK??; decompile measure -> (unless *decompile-chords-mode* ...) = risky; MN info flag !!; user definable constraint character?(defclass C-beat ()  ((rtm-list :initform nil :initarg :rtm-list :accessor rtm-list)   (unit-length :initform 1 :initarg :unit-length :accessor unit-length)   (beat-chord :initform nil :initarg :beat-chord :accessor beat-chord)   (super-beat :initform nil :accessor super-beat)   (beat-hash-table :initform nil :initarg :beat-hash-table :accessor beat-hash-table)   (temp-hash-table :initform nil :initarg :beat-hash-table :accessor temp-hash-table))) ;; !!;===========================================================; for temporary (not saved) information of PW-beat(defmethod make-chord-hash ((self pw::C-beat))  (setf (temp-hash-table self)(make-hash-table :test #'equal))) ;??? to deal with strings(defmethod write-key ((self pw::C-beat) key data)  (unless (temp-hash-table self) (make-chord-hash self))  (pwcs::write-key (temp-hash-table self) key data))(defmethod read-key ((self pw::C-beat) key)  (pwcs::read-key (temp-hash-table self) key))(defmethod clear-keys ((self pw::C-beat))  (clrhash  (temp-hash-table self)));===========================================================(defmethod calc-beat-x-cord-continue ((self C-beat) beats beat-unit-ticks x-now beat)  (when beats     (setq x-now (calc-beat-x-cord (pop beats) beat-unit-ticks x-now beat))    (calc-beat-x-cord-continue self beats beat-unit-ticks x-now beat))) (defmethod calc-beat-x-cord ((self C-beat) beat-unit-ticks x-now beat) (setq beat-unit-ticks (* (unit-length self) beat-unit-ticks)) (let ((first-x x-now))  (if (beat-leaf? self)     (when (eq self beat)          (setf *beat-x-cordinate* (truncate x-now)))            (let* ((rtm-list (rtm-list self))            (rtm-sum (apply #'+ (mapcar #'abs (ask-all (rtm-list self) 'unit-length))))            (ticks-incr (/ beat-unit-ticks rtm-sum)))       (calc-beat-x-cord-continue self rtm-list ticks-incr x-now beat)       (setq x-now (+ x-now ticks-incr))))    (+ first-x (abs beat-unit-ticks)))) (defmethod calc-beat-x-cord-measure ((self C-measure) t-scfactor x-now beat) (let* ((measure-length (calc-measure-length self t-scfactor ()))  ;midiflag         (first-x x-now)        (beats (beat-objects self))        (beat-unit-ticks (/ measure-length (calc-high-value self))))  (while (and (not *beat-x-cordinate*) beats)     (setq x-now (calc-beat-x-cord (car beats) beat-unit-ticks x-now beat))    (pop beats))  (+ first-x measure-length *rtm-editor-measure-x-offset*)))(defmethod calc-beat-x-cord-measure-line ((self C-measure-line) t-scfactor beat first-measure beg-x)  (setf  *beat-x-cordinate* ())  (let ((x-now beg-x) (measures (nthcdr first-measure (measures self))))    (while (and (not *beat-x-cordinate*) measures)       (setq x-now (calc-beat-x-cord-measure (pop measures) t-scfactor x-now beat)))    *beat-x-cordinate*));========================================(defmethod make-beat-hash ((self C-beat))  (setf (beat-hash-table self)(make-hash-table :test #'equal))) ;??? to deal with strings(defmethod write-beat-hash ((self C-beat) key data)  (unless (beat-hash-table self) (make-beat-hash self))  (setf (gethash key (beat-hash-table self)) data)) (defmethod read-beat-hash ((self C-beat) key)  (when (beat-hash-table self)      (gethash key (beat-hash-table self))))(defmethod remove-beat-hash ((self C-beat) key)   (remhash key (beat-hash-table self)));========================================;========================================; :first-note ? (inside last chord! of a group) is a list of pointers+group-names to the first beat! of groups(defun write-group-info (beats group-name)  (write-beat-hash (car beats) group-name beats)  (when (> (length beats) 1)    (write-key (car (last beats)) :first-note                   (adjoin (list (car beats) group-name) (read-key (car (last beats)) :first-note) :test #'equal))))(defun clr-group-info (beats group-name)  (let ((cur-beats (read-beat-hash (car beats) group-name)))    (when cur-beats       (write-beat-hash (car cur-beats) group-name ())      (write-key (car (last cur-beats)) :first-note         (remove (list (car cur-beats) group-name)                (read-key (car (last cur-beats)) :first-note) :test #'equal)))));========================================(defun write-beat-group (group-name &optional clear-grouping)  (let* ((win *active-rtm-window*)         (beats (give-rtm-range-chords (editor-collection-object win) nil)))    (if (and beats); (> (length beats) 1))      (progn (unless (listp clear-grouping) (setq clear-grouping (list clear-grouping)))             (when (beat-hash-table (car beats))               (while clear-grouping                 (when (read-beat-hash (car beats) (car clear-grouping))                   (clr-group-info  beats (car clear-grouping)))                 (pop clear-grouping)))             (write-group-info beats group-name)             (invalidate-corners win (make-point 0 0) (view-size win))             (event-dispatch)             (window-update-event-handler win))      (ed-beep))))  (defun clear-beat-group (clear-grouping) (let* ((win *active-rtm-window*)        (beats (give-rtm-range-chords (editor-collection-object win) nil)))    (if beats        (progn (unless (listp clear-grouping) (setq clear-grouping (list clear-grouping)))               (while clear-grouping                  (clr-group-info beats (pop clear-grouping)))             (invalidate-corners win (make-point 0 0) (view-size win))             (event-dispatch)             (window-update-event-handler win))        (ed-beep))))  (defun make-beat-named-group ()  (write-beat-group (get-string-from-user "Group name"  :initial-string "group")))(defun clear-beat-named-group ()  (clear-beat-group (get-string-from-user "Group name"  :initial-string "group")));========================================================================================================================(defun clear-all-selected-beat-group () (let ((beats (give-rtm-range-chords (editor-collection-object *active-rtm-window*) nil)))   (dolist (beat beats)       (delete-group-info beat)       (setf (beat-hash-table beat) nil))   (erase+view-draw-contents *active-rtm-window*)));; clear m-line??(defun clear-all-groups+expressions ()  (when (eq  t (y-or-n-dialog "Clear all groups, are you sure?"))    (let ((m-lines (ask-all (beat-editors (editor-collection-object *active-rtm-window*)) #'measure-line))          beats)      (while m-lines        (setq beats (collect-all-chord-beat-leafs (pop m-lines)))        (while beats           (when (beat-hash-table (car beats))            (delete-group-info (car beats))             (setf (beat-hash-table (car beats)) nil))           (pop beats)))      (erase+view-draw-contents *active-rtm-window*))));========================================================================================================================(defun constrain-selected-beat-group ()  (let* ((win *active-rtm-window*)         (beats (give-rtm-range-chords (editor-collection-object win) nil)))    (if beats      (progn (dolist (beat beats)               (write-beat-hash beat  "." (list beat)))      (pw::erase+view-draw-contents win))      (ed-beep))))  (defun unconstrain-selected-beat-group ()  (let* ((win *active-rtm-window*)         (beats (give-rtm-range-chords (editor-collection-object win) nil)))    (if beats      (progn (dolist (beat beats)               (remove-beat-hash beat ".")               (remove-beat-hash beat 'pw::note-staccato))      (pw::erase+view-draw-contents win))      (ed-beep))));========================================================================================================================;========================================================================================================================#|(defun test-groups (m-line)  (let ((beats (collect-all-chord-beat-leafs m-line))        (fl t) group)    (dolist (beat beats)      (let (info )        (when (beat-hash-table beat) (maphash #'(lambda (key val) (push (list key val) info)) (beat-hash-table beat) ))        (dolist (gr info)          (setq group (second gr))          (unless (subsetp  group beats)            (setq fl ())))))    fl))(mapcar #'test-groups pwcs::ml)   |#;========================================================================================================================;;from rtm-paging+kill.list(defmethod replace-old-beat ((self C-beat) old-beat new-beat)   (setf (rtm-list self) (substitute new-beat old-beat (rtm-list self) :test 'eq))  (update-all-beat-groupings))(defmethod replace-old-beat ((self C-measure) old-beat new-beat)   (setf (beat-objects self) (substitute new-beat old-beat (beat-objects self) :test 'eq))  (update-all-beat-groupings))(defmethod delete-group-info ((self C-beat))   (let (info group group-name)    (when (beat-hash-table self) (maphash #'(lambda (key val) (push (list key val) info)) (beat-hash-table self) ))    (while info       (setq group-name (first (car info)))      (setq group (second (car info)))      (unless  (or (null group) (= (length group) 1))        (write-key  (car (last group)) :first-note                     (remove (list (car group) group-name)                            (read-key (car (last group)) :first-note) :test #'equal )))      (pop info))))(defmethod kill-chords ((self C-beat))   (setf *beat-leaf-objs* ())  (let ((beats (collect-all-chord-beat-leafs self)))    (mapc #'delete-group-info beats)    (tell (ask-all beats #'beat-chord) #'kill-notes)))(defmethod kill-chords ((self C-measure))   (setf *beat-leaf-objs* ())  (let ((beats (collect-all-chord-beat-leafs self)))     (mapc #'delete-group-info beats)     (tell (ask-all beats #'beat-chord) #'kill-notes)))(defmethod kill-chords ((self C-measure-line))   (setf *beat-leaf-objs* ())  (let ((beats (collect-all-chord-beat-leafs self)))     (mapc #'delete-group-info beats)     (tell (ask-all beats #'beat-chord) #'kill-notes)));========================================================================================================================; draw;; from rtm-editor.lisp(defmethod draw-beat-extra-stuff  ((self C-beat) x C5 t-scfactor)   (draw-beat-extra-stuff-groups self x C5 t-scfactor))(defparameter *cmpos* ())(defparameter *y-line-extra* 0)(defparameter *note-group-draw-count* 0)(defmethod view-draw-contents ((self C-beat-editor-panel))  (let* ((draw-info (ask-all (rtm-radio-ctrls (view-container self)) 'check-box-checked-p))           (*mn-view-dyn-flag* (first draw-info))         (*mn-view-dur-flag* (second draw-info))         (*mn-view-offset-flag* (third draw-info))         (*mn-view-ins-flag* (fourth draw-info))         (monof? (= (length (beat-editors (view-container self))) 1))          (staff-incr 0)(staff-count 1)         measures (first-time? t))    (when monof?      (setq staff-count (visible-staffs-count (view-container self)))      (setq staff-incr (truncate (/ (- (h self) 0) staff-count))))    (setf *MN-global-ins-y* (+ 60 (give-C5-value self)))    ; GA 12/4/94 causes crash ?    (setf *current-MN-editor* self)    (add-to-free-buttons-pool *selection-buttons-pool* (selection-buttons self))     (setf (selection-buttons self) nil)    (incf *note-group-draw-count*)    (with-focused-view self      (view-draw-contents (selection-button self))      (draw-string 2 40 (format () "~A" (1+ (position  self (beat-editors (view-container self))))))      (set-view-font  (view-container (view-container  self)) '("MusNot-j"  18  :srcor))      (init-rtm-draw self)      (for (i 0 1 (1- staff-count))        (setf *y-line-extra* 0) ;; ML        (tell (symbol-value (nth (1- (staff-number self)) *global-staff-list*)) 'draw-staff             (- (x self) 15) (if monof? (+ (* i staff-incr) (give-C5-value-staff-count  self staff-count)) (give-C5-value self)))         (when (or measures first-time?)          (setq *cmpos* (if measures (position (first measures) (measures (measure-line self ) )) (first-beat-num self))) ;; from rtm-editor.lisp          (setq measures                (draw-measures-  (measure-line self) self                                  (if monof? (+ (* i staff-incr) (give-C5-value-staff-count  self staff-count)) (give-C5-value self))                                  (beat-zoom self)(first-beat-num self)                                 28 (w self)                                 (+ (* i staff-incr) 37) (+ (* i staff-incr) (- 57 (rtm-y-pixel self))) t measures))          (setq first-time? ())))      (tell (selection-buttons self) #'draw-view-contents** (view-container self))      (set-view-font  (view-container (view-container  self)) '("Monaco"  9  :srcor)))      measures))(defparameter *show-RTM-groupings-flag* t)(defparameter *show-2nd-group-name-flag* t);(setf *show-2nd-group-name-flag* nil)(defparameter *show-single-info-up-flag* nil);(setf *show-single-info-up-flag* t)(defparameter *constant-line-drawing-flag* t);(setf *constant-line-drawing-flag* ())(defmethod draw-beat-extra-stuff-groups  ((self C-beat) x C5 t-scfactor)  (declare (ignore t-scfactor))  (when (and *show-RTM-groupings-flag* (or (beat-hash-table self)                                            (read-key self :first-note)))    (let (info)      (when (beat-hash-table self) (maphash #'(lambda (key val) (push (list key val) info)) (beat-hash-table self) ))      (let* ((staff-count (visible-staffs-count (view-container *current-MN-editor*)))             (staff-incr (truncate (/ (- (h *current-MN-editor*) 0) staff-count)))             (monof? (= (length (beat-editors (view-container *current-MN-editor*))) 1))               (y-low (if monof?                      (- (* staff-incr (1+ (truncate C5 staff-incr))) 2)                      (- (h *current-MN-editor*) 5)))             (y-high 9)             key last-beat x2 group line-y)        (set-view-font (view-container (view-container *current-MN-editor*)) '("Courier" 9 :srcor))        (while info ;(print (first (car info)))          (setq key (first (car info)))          (setq group (second (car info)))          (unless (null group)            (when (and (listp group)                        (and (stringp key) (not (string= "." key))))              (if (= (length group) 1)                (if *show-single-info-up-flag*                   (progn (draw-string (- x 3) y-high key)                         (incf y-high 9))                   (progn (draw-string (- x 3) y-low key)                         (decf y-low 9)))                 (progn                   (write-key self :cur-draw-count *note-group-draw-count*) ;; mark that the group has been drawn !!                    (setq last-beat (car (last group)))                              (setf x2 (+ 10                      (calc-beat-x-cord-measure-line                         (measure-line *current-MN-editor*) (beat-zoom *current-MN-editor*) last-beat *cmpos* 28)));;(first-beat-num *current-MN-editor*) 28)))              ;;;;;; (first-beat-num *current-MN-editor*) ??? when monof? t !!!                  (draw-string (- x 3) y-low key)                    (setq line-y (+ (- (mod *y-line-extra* 5)) y-low))                  ;(setq line-y y-low)                  (set-pen-pattern *current-MN-editor* *light-gray-pattern*)                  (draw-line (+ x (* (length key) 5)) line-y (1- x2) line-y)                  (pen-normal *current-MN-editor*)                  (draw-line (1- x2) line-y (1- x2) (- line-y 2))                  (when *show-2nd-group-name-flag* (draw-string (- x2 3 (* (length key) 5)) (1- line-y) key))                    (unless *constant-line-drawing-flag* (incf *y-line-extra* 2))                 (decf y-low 9)))))          (when (or (eq key 'pw::note-staccato)                    (and (stringp key) (string= "." key)))            (set-view-font (view-container (view-container *current-MN-editor*)) '("MusNot-j"  18  :srcor))            (draw-string (- x 3) y-high ".") ;; monophonic case!            (set-view-font (view-container (view-container *current-MN-editor*)) '("Courier" 9 :srcor))            (incf y-high 9))          (pop info))        (when (read-key self :first-note)          (let (draw-count (bx 20)); ((bx (- x 12))             (dolist (first-note-info (read-key self :first-note))              (when (and (setq draw-count (read-key (first first-note-info) :cur-draw-count))                         (< draw-count *note-group-draw-count*))              ;(print first-note-info)              (setq line-y (+ (- (mod *y-line-extra* 5)) y-low))              (draw-string (- bx 10) (+ line-y 3) ">")               (draw-string (- bx 3) line-y (second first-note-info))               (set-pen-pattern *current-MN-editor* *light-gray-pattern*)              (draw-line (+ bx (* (length (read-key self :first-note)) 5)) line-y (+ x 5) line-y)              (pen-normal *current-MN-editor*)              (draw-line (+ x 5) line-y (+ x 5) (- line-y 2))              (when *show-2nd-group-name-flag*                   (draw-string (- (+ x 5) 2 (* (length (second first-note-info)) 5)) (1- line-y) (second first-note-info)))                (unless *constant-line-drawing-flag* (incf *y-line-extra* 2))              (decf y-low 9)))))        (set-view-font (view-container (view-container *current-MN-editor*)) '("MusNot-j"  18  :srcor))))))               ;========================================================================================================================; menus(defvar *RTM-group-menu* (new-menu "Groups"));===================; options(defparameter *show-RTM-groupings-menu*   (make-instance 'menu-item       :menu-item-title "Show groups" :menu-item-action 'set-show-RTM-groupings-flag))(set-menu-item-check-mark *show-RTM-groupings-menu* *show-RTM-groupings-flag*)(defun set-show-RTM-groupings-flag ()  (setf *show-RTM-groupings-flag* (not *show-RTM-groupings-flag*))  (set-menu-item-check-mark *show-RTM-groupings-menu* *show-RTM-groupings-flag*)  (erase+view-draw-contents (front-window)));;;(defparameter *draw-group-options-menu*   (new-menu "Draw options"))(defparameter *show-2nd-group-name-flag-menu*   (make-instance 'menu-item       :menu-item-title "Show two group names" :menu-item-action 'set-show-2nd-group-name-flag))(set-menu-item-check-mark *show-2nd-group-name-flag-menu* *show-2nd-group-name-flag*)(defun set-show-2nd-group-name-flag ()  (setf *show-2nd-group-name-flag* (not *show-2nd-group-name-flag*))  (set-menu-item-check-mark *show-2nd-group-name-flag-menu* *show-2nd-group-name-flag*)  (erase+view-draw-contents (front-window)));;;(defparameter *constant-line-drawing-flag-menu*   (make-instance 'menu-item       :menu-item-title "Constant line drawing" :menu-item-action 'set-constant-line-drawing-flag))(set-menu-item-check-mark *constant-line-drawing-flag-menu* *constant-line-drawing-flag*)(defun set-constant-line-drawing-flag ()  (setf *constant-line-drawing-flag* (not *constant-line-drawing-flag*))  (set-menu-item-check-mark *constant-line-drawing-flag-menu* *constant-line-drawing-flag*)  (erase+view-draw-contents (front-window)))(add-menu-items *draw-group-options-menu*  *show-2nd-group-name-flag-menu*  *constant-line-drawing-flag-menu*);;;;(add-menu-items  *RTM-group-menu*   *show-RTM-groupings-menu*  *draw-group-options-menu*  (new-leafmenu "-" nil));===================;Clear selected Unconstrain ?? (add-menu-items  *RTM-group-menu*   (new-leafmenu "Make group"   #'(lambda () (make-beat-named-group)))  (new-leafmenu "Clear group"  #'(lambda () (clear-beat-named-group)))  (new-leafmenu "-" nil)  (new-leafmenu "Clear selected"   #'(lambda () (clear-all-selected-beat-group)))  (new-leafmenu "Clear all groups"   #'(lambda () (clear-all-groups+expressions))) )       (nconc  *RTM-menu-root*(list  *RTM-group-menu* ));;(defvar *RTM-group-menu* (new-menu "Groups"))(add-menu-items  *RTM-group-menu*   (new-leafmenu "-" nil)  (new-leafmenu "Constrain"   #'(lambda () (constrain-selected-beat-group)))  (new-leafmenu "Unconstrain"   #'(lambda () (unconstrain-selected-beat-group)))  );==================================================; saving cut paste delete etc.; correcting the groupings       (defun update-all-beat-groupings ()  ;; heavy, probably needed  (when (current-rtm-editor (editor-collection-object *active-rtm-window*))    (let* ((m-line (measure-line (current-rtm-editor (editor-collection-object *active-rtm-window*))))           (beats (collect-all-chord-beat-leafs m-line))           (beats2 beats)           info pos1 pos2           group key)      (while beats2        (when (beat-hash-table (car beats2))          (maphash #'(lambda (key val) (push (list key val) info)) (beat-hash-table (car beats2)) )          (while info            (setq group (second (car info)))            (setq key  (first (car info)))            (if (and (listp group)                     key                     (setq pos1 (position (car group) beats))                     (setq pos2 (position (car (last group)) beats)))              (if (and pos1 pos2 (setq pos2 (1+ pos2)) ;; both end-points must be found !                        ;(or (= (length group) 1)                        ;    (= (length group) (- pos2 pos1)))                       )                (write-group-info (subseq beats pos1 pos2) key)                (clr-group-info beats2 key)) ;;;erase group as its end-points are not found !                (clr-group-info beats2 key))                        (pop info)))        (when (and (read-key (car beats2) :first-note)                    (not (find-if #'(lambda (b) (member (first b) beats )) (read-key (car beats2) :first-note))))          (write-key (car beats2) :first-note ()))        (pop beats2)))))                    (defun make-note-groups (note key ch1-pos ch2-pos chords)  (declare (ignore note key ch1-pos ch2-pos chords)))(defun make-beat-groups (beat key ch1-pos ch2-pos beats)  beat  (let ((cur-beats (subseq beats ch1-pos (1+ ch2-pos))))   (write-group-info cur-beats key)))(defun make-beat-expr (beat key)  (write-beat-hash beat key (list beat)))#|(defun make-beat-expr (beat key)  (write-beat-hash beat key key)) |#(defmethod decompile-beat-info ((self C-beat) beats)  (when (beat-hash-table self)    (let (info res pos1 pos2)      (maphash #'(lambda (key val) (push (list key val) info)) (beat-hash-table self) )      (while info        (if (and (listp (second (car info)))                   (first (car info))                   (setq pos1 (position (car (second (car info))) beats))                   (setq pos2 (position (car (last (second (car info)))) beats)))          (push            `(,(first (car info))             ,pos1             ,pos2)             res)          (when (second (car info))            (push               (first (car info))              res)))        (pop info))      (nreverse res))))       #|; still missing(defmethod decompile  ((self C-beat))    (setq *rec-rtm-chs-list* ()) `(beat-constructor ,(unit-length self) ',(decompile-rtm self ()) (list ,.(nreverse *rec-rtm-chs-list*))))(defmethod decompile ((self C-measure))  `(make-instance 'C-measure :low ,(low self) ;:rtm-list ,(rtm-list self)                              :metronome ,(metronome self)                             :metronome-unit ,(metronome-unit self)                             :beat-objects (list ,.(ask-all (beat-objects self) 'decompile))))|#(defmethod decompile ((self C-measure-line))  `(let* ((m-line (make-instance ',(class-name (class-of self))                   :measures (list ,@(ask-all (measures self) 'decompile))))           (beats-info                  ',(ask-all (collect-all-chord-beat-leafs self)                                              'decompile-beat-info (collect-all-chord-beat-leafs self)))           (beats (collect-all-chord-beat-leafs m-line))           (beats2 beats)           temp) ;;    (print beats-info)     (while (and beats-info beats2)        (setq temp (pop beats-info))        (while temp          (if (and (listp (car temp)) (first (car temp))(second (car temp))(third (car temp)))             (make-beat-groups (car beats2) (first (car temp))(second (car temp))(third (car temp)) beats)             (make-beat-expr (car beats2) (car temp)))          (pop temp))        (pop beats2))      m-line));==================================================#|(defmethod key-pressed-extra :before ((self C-rtm-editor-window) char)  (case char    (#\g  (make-beat-named-group))))|#(defmethod beat-chord ((self t)) nil)(defparameter *current-rtm-click-point* ())(defmethod view-click-event-handler :before ((self C-beat-editor-panel) where)  (setf *current-rtm-click-point* where))(defmethod erase+view-draw-inside-clip ((self C-beat-editor-panel) where)    (let* ((xc (- (point-h where) 20)) (yc (+ 0 (point-v where))) (wc 50) (hc 200)           (pos (make-point xc yc))           (end (add-points pos (make-point wc hc))))      (with-focused-view self        (clip-rect self pos end)        (erase+view-draw-contents self)))) (defun map-to-tranpose-cents ()  (cond ((shift-key-p) 1200)        ((option-key-p) 50)        (t 100)))  ; added UpArrow DownArrow O(defmethod key-pressed-extra ((self C-rtm-editor-window) char)  (case char     (#\UpArrow     (when (beat-chord (rtm-selection-1 (editor-collection-object self)))           (transpose-chord (beat-chord (rtm-selection-1 (editor-collection-object self))) (map-to-tranpose-cents))          (erase+view-draw-inside-clip (current-rtm-editor (editor-collection-object self)) *current-rtm-click-point*)))     (#\DownArrow     (when (beat-chord (rtm-selection-1 (editor-collection-object self)))           (transpose-chord  (beat-chord (rtm-selection-1 (editor-collection-object self))) (- (map-to-tranpose-cents)))           (erase+view-draw-inside-clip (current-rtm-editor (editor-collection-object self)) *current-rtm-click-point*)))     (#\O (when (beat-chord (rtm-selection-1 (editor-collection-object self)))           (open-instrument-editor  (first (notes  (beat-chord (rtm-selection-1 (editor-collection-object self)))))             self 120 120)))    (#\ForwardArrow  (calc-next-rtm-page+scroll self ()))    (#\BackArrow  (calc-prev-rtm-page+scroll self ()))    (#\+  (set-dialog-item-text-from-dialog              (beat-number-ctrl (editor-collection-object self))              (format nil "~5D" (1+ (value (beat-number-ctrl (editor-collection-object self))))))         (scroll-beat (editor-collection-object self)(beat-number-ctrl (editor-collection-object self))))     (#\-  (set-dialog-item-text-from-dialog              (beat-number-ctrl (editor-collection-object self))              (format nil "~5D" (max 1 (1- (value (beat-number-ctrl (editor-collection-object self)))))))         (scroll-beat (editor-collection-object self)(beat-number-ctrl (editor-collection-object self))))     (#\H  (set-dialog-item-text-from-dialog              (beat-number-ctrl (editor-collection-object self)) (format nil "~5D" 1))         (scroll-beat (editor-collection-object self)(beat-number-ctrl (editor-collection-object self))))     (#\L  (set-dialog-item-text-from-dialog              (beat-number-ctrl (editor-collection-object self))                  (format nil "~5D" (max 1 (length (measures (measure-line (car (beat-editors (editor-collection-object self)))))))))         (scroll-beat (editor-collection-object self)(beat-number-ctrl (editor-collection-object self))))     (#\p (when (rtm-selection-1 (editor-collection-object self))            (let* ((nth-measure (position (rtm-selection-1 (editor-collection-object self))                                         (measures (measure-line (current-rtm-editor (editor-collection-object self))))))                   measures)             (when nth-measure                 (setq measures                     (mapcar #'nth (cirlist nth-measure)                       (ask-all (ask-all (give-selected-editors (editor-collection-object self)) #'measure-line) #'measures)))                (setq measures (remove nil measures))                (setf *mn-view-offset-flag* (check-box-checked-p (third (rtm-radio-ctrls (editor-collection-object self)))))                (start                  (apdfuncall  100 (priority) 15                     #'(lambda ()                          (tell measures #'play-measure (get-play-speed (editor-collection-object self))))))))))    (#\P (when (eq 'C-measure (class-name (class-of (rtm-selection-1 (editor-collection-object self)))))           (start             (setf *mn-view-offset-flag* (check-box-checked-p (third (rtm-radio-ctrls (editor-collection-object self)))))             (apdfuncall 100 (priority) 15                #'(lambda ()                     (play-measure (rtm-selection-1 (editor-collection-object self)) (get-play-speed (editor-collection-object self))))))))    (#\a (when (rtm-selection-1 (editor-collection-object self))           (if (eq 'C-measure-line (class-name (class-of (rtm-selection-1 (editor-collection-object self)))))              (if (measures (measure-line (current-rtm-editor (editor-collection-object self))))                  (add-beat-after (car (last (measures (measure-line (current-rtm-editor (editor-collection-object self)))))))                  (add-beat-after-myself (rtm-selection-1 (editor-collection-object self)) ()))              (add-beat-after (rtm-selection-1 (editor-collection-object self))))           (update-all-beat-groupings)           (erase+view-draw-contents (current-rtm-editor (editor-collection-object self)))))    (#\b (when (rtm-selection-1 (editor-collection-object self))              (unless (eq 'C-measure-line (class-name (class-of (rtm-selection-1 (editor-collection-object self)))))               (add-beat-before (rtm-selection-1 (editor-collection-object self)))               (update-all-beat-groupings)               (erase+view-draw-contents (current-rtm-editor (editor-collection-object self))))))    (#\r (when (rtm-selection-1 (editor-collection-object self))        (record-rtm-chords-from-midi (give-rtm-range-chords (editor-collection-object self) nil))           (erase+view-draw-contents (current-rtm-editor (editor-collection-object self)))))    (#\k (read-from-midi))     (#\K         (tell (ask-all (beat-editors (editor-collection-object self)) 'measure-line) 'kill-all-measures)       (erase+view-draw-contents self))    (#\Backspace        (let (m-line?)         (if (not (eq 'C-measure-line (class-name (class-of (setq m-line? (rtm-selection-1 (editor-collection-object self)))))))           (when (rtm-selection-1 (editor-collection-object self))                (remove-beat-from-measure (rtm-selection-1 (editor-collection-object self)))               (update-all-beat-groupings)               (erase+view-draw-contents (current-rtm-editor (editor-collection-object self))))           (progn               (kill-chords m-line?)(setf (measures m-line?) ())               (erase+view-draw-contents (current-rtm-editor (editor-collection-object self)))))))    (#\S  (tell (beat-editors (editor-collection-object self)) 'set-selection-button t))    (#\U  (tell (beat-editors (editor-collection-object self)) 'set-selection-button nil))    (#\D  (erase+view-draw-contents self))    (#\e  (let ((e-ctrl (beat-edit-ctrl (editor-collection-object self))))            (if (check-box-checked-p e-ctrl)               (check-box-uncheck  e-ctrl) (check-box-check  e-ctrl))          (set-edit-mode (editor-collection-object self) e-ctrl))) ;   (t (ed-beep));;;;;;))(push `(#\g ,#'(lambda (char) char (make-beat-named-group)))      *rtm-window-key-fns*);(setf (rtm-selection-1 (view-container view)) (cdr (selection-button-function self)))(defun make-beat-named-group ()  (write-beat-group (get-string-from-user "Group name"  :initial-string "group")))#|(setf b1 (beat-constructor 1 '(1 1 1)))(write-beat-hash b1 'ghj 78987)(read-beat-hash b1 'ghj)(write-beat-hash b1 'mnb 'jkl)(read-beat-hash b1 'mnb); sl ; 2 note sustain(defun fff (pat) (let* ((win *active-rtm-window*)        (beats (give-rtm-range-chords (editor-collection-object win) nil))        note)        ;(beats-c beats))  (while (and beats pat)     (when (eq (car pat) :sl)            (write-beat-hash (car beats) "sl" (list (car beats)))) ; should be 2 notes?     (when (and (second beats) (eq (car pat) :s))            (write-beat-hash (car beats) "s" (list (car beats)(second beats))))     (when (and (eq (car pat) :-d))           (setq note (car (notes (beat-chord (car beats)))))            (setf (vel note)  (- (vel note) 6)))     (when (and (or (eq (car pat) :up) (eq (car pat) :dn)))            (if (eq (car pat) :up)              (write-beat-hash (car beats) "up" (list (car beats)))              (write-beat-hash (car beats) "dn" (list (car beats)))));  ......  (pop pat) (pop beats))));(fff '(:sl ()()()));(fff '(:s () :s ()   :s () :s ()   :s () :s ()));(fff '(:sl () :sl ()   :s :s :sl ()   :s :s :sl ()));(fff '(:s :s :s :s   :s :s :s :s   :s :s :s :s   :s :s :s :s   :s :s :s :s   :s :s :s :s  :s :s :s :s   :s :s :s :s   :s :s :s :s));(fff '(:up :dn :up   :up :dn :up  :up :dn :up ));(fff '(:dn :up :up   :dn :up :up));(fff '(:up :dn :up :dn));(fff '(() :-d  () :-d  () :-d   () :-d  () :-d   () :-d  ))(defun add-dim-cresc-to-vels (min max) (let* ((win *active-rtm-window*)        (beats (give-rtm-range-chords (editor-collection-object win) nil))        (bpf (make-break-point-function (list (t-time (beat-chord (first beats))) (t-time (beat-chord (first (last beats))))) (list min max)))          note)  (while (and beats)    (setf note (first (notes (beat-chord (car beats)))))    (setf (vel note) (+ (vel note) (truncate (bpf-out bpf (t-time (beat-chord (car beats))) (x-points bpf)))))    (pop beats))));(defparameter bpf* (make-break-point-function '(5495 6109) (list 0 20)));(truncate (bpf-out bpf* 5769 (x-points bpf*) t));(add-dim-cresc-to-vels 0 20);(add-dim-cresc-to-vels -4 -4)|#