;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================(defconstant ? '?)(defun attack-count (rtm-list) (let (res rtm-list-now)   (while rtm-list     (setq rtm-list-now (pop rtm-list))     (push         (if (listp rtm-list-now)          (attack-count (second rtm-list-now))          (if (and (integerp rtm-list-now) (plusp rtm-list-now)) 1 0))          res))   (apply #'+ (pw::flat (nreverse res)))))(defun count-rtms (l)  (apply #'+ (mapcar #'(lambda (n) (attack-count (second n))) l)));(attack-count '(1 1 1)) ;(attack-count '(2 2 2 (7 (3 2 1)))) ;(attack-count '(1 1 (1 (1 1 1)) 1 1));(attack-count '((1 (1 1 1 1 1)) (1 (1 1 1 1 1)) (1 (1 1 1 1 1))));(attack-count '(1 1 (1 (1 1 1)))) ;(attack-count '(2 2 2 (7 (3 2 1)))) ;(attack-count '(2.0 2 2 (3 (1 1 1 1)))) (defun map-rtm-list-to-s-variables2 (orig-l rtm-list s-variables &optional (poses (list 1)))  (let (rtm-list-now s-variable)    (for (pos 0 1 (1- (length rtm-list)))      (setq rtm-list-now (nth pos rtm-list))      (if (listp rtm-list-now)        (setq s-variables (map-rtm-list-to-s-variables2 orig-l (second rtm-list-now)                                                         s-variables (cons pos (cons 1 poses))))        (when (and (integerp rtm-list-now) (plusp rtm-list-now))           (setq s-variable (pop s-variables))          (write-key s-variable :rtm-pattern orig-l)          (write-key s-variable :rtm-pos (reverse (cons pos poses)))))))     s-variables)(defun map-rtm-list-to-s-variables (unit rtm-list s-variables)  (map-rtm-list-to-s-variables2 (list unit rtm-list)  rtm-list s-variables)) (defun replace-?s (l &optional (res nil))   (cond ((null l) res)         ((atom l) l)         ((or (variable-p (first l)) (symbolp (first l)))  (second l))         (t (cons (replace-?s (car l) res)                  (replace-?s (cdr l) res)))));(replace-?s '(2 ((s-variable 1.0))));(replace-?s '(2 ((?s-variable 1.0))));============================================================================;(rtm-match = (equal rtm-pattern) + (equal poses) ;(* ?1 (?if (if (match-rtm? (1 (1 (?i 1) 1)))  (and test1 test2 ...) t)));============================================================================(let (res)  (defun get-rtm-pattern-poses (rtm-list &optional (poses (list 1)))    (when (equal poses '(1)) (setq res nil))    (let (rtm-list-now)      (for (pos 0 1 (1- (length rtm-list)))        (setq rtm-list-now (nth pos rtm-list))        (if (and (listp rtm-list-now) (numberp (first rtm-list-now)))          (get-rtm-pattern-poses (second rtm-list-now) (cons pos (cons 1 poses)))          (when (and (listp rtm-list-now) (symbolp (car rtm-list-now)))             ;(print (list (car rtm-list-now) res))            (push (list (car rtm-list-now) (reverse (cons pos poses))) res)))))    (reverse res)))#|;(get-rtm-pattern-poses '(2 (1 (1 2 (?i 9)))));(get-rtm-pattern-poses '(2 (1 ((?c 1) (?h 2) (?i 2)))));(get-rtm-pattern-poses '(2 (1 (1 2 (?i 9)))));(replace-?s '(2 (1 (1 2 (?i 9)))));(get-rtm-pattern-poses '(1 (?i 1) 1));(replace-?s '(1 (?i 1) 1))(defun map-nth (l ns)  (dolist (n ns l)    (setq l (nth n l))))(defun r-rtm (s-variable) (list (read-key s-variable :rtm-pattern) (read-key s-variable :rtm-pos)))(map-rtm-list-to-s-variables 1 '(1 1 1 1) '(i1 i2 i3 i4))(mapcar #'r-rtm '(i1 i2 i3 i4))(map-rtm-list-to-s-variables  1 '(1 -1 1.0 3 1) '(i1 i2 i3))(mapcar #'r-rtm '(i1 i2 i3))(map-rtm-list-to-s-variables 3 '(1 (1 (2 3 4)) 5) '(i1 i2 i3 i4 i5))(mapcar #'r-rtm '(i1 i2 i3 i4 i5))(map-nth '(1 (1 (1 (2 3 4)) 5)) '(1 2))|#;=======================================================================;(* ?1 (?if (if (match-rtm?* '(1 (1 (?i 1) 1)))  (and test1 test2 ...) t)));'(1 (1 (?i 1) 1))#|(defparameter ?1 '?1) (defparameter ?2 '?2) (write-key ?1 :rtm-pattern '(1 (1 1 1)))(write-key ?2 :rtm-pattern '(1 (1 1 1)))(write-key ?1 :rtm-pos '(1 1))(write-key ?2 :rtm-pos '(1 2))(read-key ?1 :rtm-pos)(read-key ?2 :rtm-pos)  (macroexpand-1 '(match-rtm?  (1 (1 (?1 1) (?2 1))))) (macroexpand-1 '(match-rtm?  (1 (1 1 1)))) (time (repeat 10000 (match-rtm?  (1 (1 (?1 1) (?2 1)))))) (match-rtm?  (1 (1 (?1 1) (?2 1))))|#;=======================================================================;  User PWCs-RTM functions;=======================================================================(defmacro match-rtm? (rtm-pat+vars);"rtm-pat+vars should not be quoted ! and should be a valid rtm-list""match-rtm? returns true if all variables mentioned in rtm-pat+vars share the same rtm-patternand the rtm-positions of the variables match the positions given by rtm-pat+vars.For instance a rtm-pat+vars like (1 ((?1 1) (?2 1))) would match all caseswhere ?1 and ?2 form the rtm-pattern (1 (1 1))."  (let* ((rtm (list (car rtm-pat+vars) (replace-?s (second rtm-pat+vars))))         (poses (get-rtm-pattern-poses (second rtm-pat+vars)))           (and-clause1 (mapcar #'(lambda (n) `(equal (read-key ,(car n) :rtm-pattern) ',rtm)) poses))         (and-clause2 (mapcar #'(lambda (n) `(equal (read-key ,(car n) :rtm-pos) ',(second n))) poses))         (add-clause (append and-clause1 and-clause2)))   `(and ,.add-clause)));(macroexpand-1 '(match-rtm?   (1 (1 (?i 1) 1)))) ;(macroexpand-1 '(match-rtm?  (1 (1 (1 ((?1 1) 1 (?2 1))) (?3 1))))) (defmacro match-rtm3? (?1 rtm-pat1 rtm-pat2)"?1 s-variable rtm-pat1 contains ?1 and rtm-pat2 a plain rtm-pat (no variables)for ex:  ?1  (1 ((?1 1))) (1 (1.0))"  `(let ((next-beat (next-item (read-key ,?1 :beat))))    (and      (match-rtm? ,rtm-pat1)     next-beat     (equal (read-key next-beat :rtm-pattern) ',rtm-pat2)))) ;(macroexpand-1 '(match-rtm3?  ?1  (1 ((?1 1))) (1 (1.0))))