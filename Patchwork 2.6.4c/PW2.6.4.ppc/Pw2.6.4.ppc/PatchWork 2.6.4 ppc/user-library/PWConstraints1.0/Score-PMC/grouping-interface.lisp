(in-package :PWCS);=================================================; lk-items know about: prev next PW-note ; the 1st lk-item knows about: time+dur, group-name;=================================================(defclass linked-list-key-item (linked-list-item key-item) ())(defun mk-linked-key-item ()   (make-instance 'linked-list-key-item))(defun map-to-chords-group (chords group-name)  (let (res lk note)    (dolist (chord chords)       (setq lk (mk-linked-key-item))       (setq note (first (pw::notes chord)))       (write-key lk :PW-note note)       (write-key  note :lks (cons lk (read-key note :lks)))       (push lk res))    (setq res (nreverse res))    (link-list res)    (write-key (first res) :group-name group-name)    (write-key (first res) :time+dur                (list (pw::t-time (first chords))                     (+ (pw::t-time (first (last chords)))                        (pw::dur (first (pw::notes (first (last chords))))))))    (first res)))(defun init-chord-groups (chord)  (write-key  (first (pw::notes chord)) :lks ()))  ;=================================================; group-lk knows about the first item of its group;=================================================(defun build-chord-groups (m-lines)  (when (atom m-lines) (setq m-lines (list m-lines)))  (let (part-groups-list)    (dolist (m-line m-lines)      (let ((beats (pw::collect-all-chord-beat-leafs m-line))            info key group 1st-item groups-list chords group-lk)        (mapc #'init-chord-groups (mapcar #'pw::beat-chord beats))         (dolist (beat beats)          (when (pw::beat-hash-table beat)            (maphash #'(lambda (key val) (push (list key val) info))                      (pw::beat-hash-table beat))            (while info ;(print info)              (setq key (first (car info)))              (setq group (second (car info)))              (unless (null group)                (setq chords (mapcar #'pw::beat-chord group))                (setq 1st-item (map-to-chords-group chords key))                  (setq group-lk (mk-linked-key-item))                (write-key group-lk :1st-group-item 1st-item)                (write-key 1st-item :group-lk group-lk)                (push group-lk groups-list))              (pop info))))        (link-list (setq groups-list (nreverse groups-list)))        (push (first groups-list) part-groups-list)))    (nreverse part-groups-list)))(defun pwcs-build-chord-groups (beat-leafs-ls-ls)  (let (part-groups-list)    (dolist (beats beat-leafs-ls-ls)      (let (info key group 1st-item groups-list chords group-lk)        (mapc #'init-chord-groups (mapcar #'pw::beat-chord beats))         (dolist (beat beats)          (when (pw::beat-hash-table beat)            (maphash #'(lambda (key val) (push (list key val) info))                      (pw::beat-hash-table beat))            (while info ;(print info)              (setq key (first (car info)))              (setq group (second (car info)))              (unless (null group)                (setq chords (mapcar #'pw::beat-chord group))                (setq 1st-item (map-to-chords-group chords key))                  (setq group-lk (mk-linked-key-item))                (write-key group-lk :1st-group-item 1st-item)                (write-key 1st-item :group-lk group-lk)                (push group-lk groups-list))              (pop info))))        (link-list (setq groups-list (nreverse groups-list)))        (push (first groups-list) part-groups-list)))    (nreverse part-groups-list)));============================================;============================================(defclass linked-group-collection (linked-list-key-item) ())(defparameter *linked-group-coll* ())(defun mk-linked-group-collection (lks)   (let ((linked-group-collection (make-instance 'linked-group-collection)))     (write-key linked-group-collection :lks lks)     (setf *linked-group-coll* linked-group-collection)     linked-group-collection))(defun linked-group-coll () *linked-group-coll*) (defmethod group-names ((self linked-group-collection))  (let ((glks (read-key self :lks)))    (mapcar #'(lambda (glk)       (mapcar #'(lambda (lk) (read-key (read-key lk :1st-group-item) :group-name))             (cons glk (all-next-items glk))))       glks)))(defmethod nth-part-groups ((self linked-group-collection) partnum)  (nth (1- partnum) (read-key self :lks)))       #|(defparameter  *groups-list* (build-chord-groups ccl::ml))(read-key (read-key (first *groups-list*) :1st-group-item) :group-name)(read-key (read-key (next-item (first *groups-list*)) :1st-group-item) :group-name)(mk-linked-group-collection (build-chord-groups ccl::ml))(group-names (linked-group-coll)) |#(defmethod first-item-in-group ((self linked-list-item))  (if (prev-item self)    (let (res (prev-item self))      (while (setq prev-item (prev-item prev-item))        (setq res prev-item))      res)    self))(defmethod belong-to-group? ((self linked-list-item) group-name)  (string= (read-key (first-item-in-group self) :group-name)           group-name))(defmethod belong-to-group? ((self t) group-name)   (declare (ignore group-name))  nil)(defmethod pos-in-group? ((self t) group-name)   (declare (ignore group-name))  nil)(defmethod pos-in-group? ((self linked-list-item) group-name)  (when (belong-to-group? self group-name)    (if (prev-item self)      (let ((cur-pos 1)            (next-item (first-item-in-group self)))        (while (not (eq (setq next-item (next-item next-item)) self))          (incf cur-pos))        cur-pos)      0))) ;============================; PW-note(defmethod belong-to-group? ((self pw::C-note) group-name)  (find-if #'(lambda (lk) (belong-to-group? lk group-name))  (read-key self :lks)))(defmethod pos-in-group? ((self pw::C-note) group-name)  (pos-in-group? (find-if #'(lambda (lk) (pos-in-group? lk group-name)) (read-key self :lks)) group-name))(defmethod group-lk ((self pw::C-note) group-name)  (let ((lk (belong-to-group? self group-name)))    (when lk       (read-key (first-item-in-group lk) :group-lk))))(defmethod prev-group-lk ((self pw::C-note) group-name)  (let ((glk (group-lk self group-name)))    (when glk       (let* ((glks (all-prev-items glk))) ; finds the prev group with the same group-name       (find-if #'(lambda (glk) (belong-to-group?  (read-key glk :1st-group-item) group-name)) glks)))))(defmethod previous-group-svars ((self pw::C-note) group-name) (let ((prev-glk (prev-group-lk self group-name))        1st)    (when prev-glk      (setq 1st (read-key prev-glk :1st-group-item))        (mapcar          #'(lambda (lk)             (read-key *note-s-var-association-htable* (read-key lk :PW-note)))          (cons 1st (all-next-items 1st)))))) (defmethod previous-group-midis ((self pw::C-note) group-name)  (l->ms (previous-group-svars self group-name)))(defmethod at-nth-group3? ((self pw::C-note) partnum pos group-name) ; group pos starting from 1 !!  (when (belong-to-group? self group-name)    (let ((cur-gritem (nth-part-groups (linked-group-coll) partnum))          (loop-fl t) (gr-cnt 0) (found-fl ())          (group (group-lk self group-name)))      (while (and loop-fl cur-gritem)           (when (string= (read-key (read-key cur-gritem :1st-group-item) :group-name) group-name)          (incf gr-cnt))        (if (and (eq group cur-gritem) (= gr-cnt pos))          (progn (setq loop-fl ())                 (setq found-fl t))          (when (eq group cur-gritem)            (setq loop-fl ())))        (setq cur-gritem (next-item cur-gritem)))      found-fl)))          ;;;(defmethod group-at-pos ((self pw::C-note) partnum pos group-name)  (let ((cur-gritem (nth-part-groups (linked-group-coll) partnum))        (gr-cnt 0) (loop-fl t))    (while (and loop-fl cur-gritem)         (when (string= (read-key (read-key cur-gritem :1st-group-item) :group-name) group-name)        (incf gr-cnt))      (when  (= gr-cnt pos) (setq loop-fl ()))      ;(print (list gr-cnt (=  gr-cnt pos)))      (when loop-fl (setq cur-gritem (next-item cur-gritem))))    cur-gritem))(defmethod group-at-position-svars ((self pw::C-note) partnum pos group-name)  (let ((group (group-at-pos self partnum pos group-name)) 1st)    (when group      (setq 1st (read-key group :1st-group-item))       (mapcar        #'(lambda (lk)            (read-key *note-s-var-association-htable* (read-key lk :PW-note)))       (cons 1st (all-next-items 1st)))))) (defmethod group-at-position-midis ((self pw::C-note) partnum pos group-name)  (l->ms (group-at-position-svars self partnum pos group-name)))#|(read-key (first (pw::notes (pw::beat-chord (nth 5 (pw::collect-all-chord-beat-leafs (first ccl::ml)))))) :lks)(belong-to-group? (first (pw::notes (pw::beat-chord (nth 5 (pw::collect-all-chord-beat-leafs (first ccl::ml)))))) "g1")(pos-in-group? (first (pw::notes (pw::beat-chord (nth 4 (pw::collect-all-chord-beat-leafs (first ccl::ml)))))) "g2")(pos-in-group? (first (pw::notes (pw::beat-chord (nth 5 (pw::collect-all-chord-beat-leafs (first ccl::ml)))))) "g2")(setq *n* (first (pw::notes (pw::beat-chord (nth 10 (pw::collect-all-chord-beat-leafs (first ccl::ml)))))))(mapcar #'(lambda (n) (mindex n)) (previous-group-svars *n* "g"))(previous-group-midis *n* "g")(at-nth-group3? *n* 2 2 "g")(at-nth-group3? *n* 2 1 "f")(group-at-pos *n* 2 1 "f")(group-at-position-svars *n* 2 1 "f")(group-at-position-midis *n* 1 1 "g")|#;======================================================================;======================================================================; user group PWCS methods and functions;======================================================================;======================================================================;; returns t if a s-variable belongs to a group with group-name(defmethod belong-to-group? ((self search-variable) group-name)  (belong-to-group? (read-key self :PW-note) group-name)); returns the position of s-variable in group with group-name; if s-variable does not belong to a group with group-name pos-in-group? returns nil  (defmethod pos-in-group? ((self search-variable) group-name)  (pos-in-group? (read-key self :PW-note) group-name))(defun note-in-group-at-pos? (s-variable pos group-name) ; pos starting from 1 !!"returns t if a s-variable belongs to a group with group-name and is found at the position pos within that group (counting from 1)"  (setq pos (1- pos))  (let (npos)    (and (setq npos (pos-in-group? s-variable group-name))         (= pos npos))))(defun note-found-in-nth-group? (s-variable group-pos group-name) ; group pos starting from 1 !!"returns t if a s-variable belongs to a group with group-name and the group is at the position group-pos (counting from 1) within the groups of s-variable's part."   (at-nth-group3? (read-key s-variable :PW-note) (partnum s-variable) group-pos group-name));================================================================;access previous group with group-name found in the same part(defmethod prev-group ((self search-variable) group-name)  (prev-group-lk (read-key self :PW-note) group-name))(defun prev-group-svars (s-variable group-name)"access previous group-s-variables with group-name found in s-variable's part."  (previous-group-svars (read-key s-variable :PW-note) group-name))(defun prev-group-midis (s-variable group-name)"access previous group-midis with group-name found in s-variable's part."  (previous-group-midis (read-key s-variable :PW-note) group-name));================================================================;access any group (indexed by partnum and group-pos) with group-name in the score(defmethod group-at-pos ((self search-variable) partnum group-pos group-name)  (group-at-pos (read-key self :PW-note) partnum group-pos group-name))(defun group-at-pos-svars (s-variable partnum group-pos group-name)"access group-s-variables (indexed by partnum and group-pos) with group-name"  (group-at-position-svars (read-key s-variable :PW-note) partnum group-pos group-name))(defun group-at-pos-midis (s-variable partnum group-pos group-name)"access group-midis (indexed by partnum and group-pos) with group-name"  (group-at-position-midis (read-key s-variable :PW-note) partnum group-pos group-name))#|; PWCs rule examples; ex1(* ?1 ?2  (?if (setp (list  (m ?2) (m ?1) :key #'(lambda (n) (mod n 12))))))(* ?1 ?2 ?3  (?if (setp (list (m ?3)  (m ?2) (m ?1) :key #'(lambda (n) (mod n 12))))))(* ?1 ?2 ?3  ?4 (?if (setp (list (m ?4) (m ?3)  (m ?2) (m ?1) :key #'(lambda (n) (mod n 12))))))(* ?1 ?2 ?3  ?4 ?5 (?if (setp (list (m ?5)(m ?4) (m ?3)  (m ?2) (m ?1) :key #'(lambda (n) (mod n 12))))))(* ?1 ?2  (?if    (if (note-in-group-at-pos? ?1 1 "g")     (member (- (m ?2) (m ?1)) '(3 4 5))     t)) "interval betw 1st and 2nd note in group 'g' = 1")(* ?1 ?2  (?if    (if (note-in-group-at-pos? ?1 2 "g")     (> (- (m ?2) (m ?1)) 12)     (< (- (m ?2) (m ?1)) 12)))    "ascending interval betw 1st and 2nd note > than 12 in group 'g'")(* ?1 ?2 ?3 (?if  (if (> (- (m ?2) (m ?1)) 12)      (< -7 (- (m ?3) (m ?2)) 0) t))  "if interval betw ?1-?2 is > than 12 then interval between ?2-?3 is betw 0 int -7" )(* ?1 ?2 ?3 (?if    (if (note-in-group-at-pos? ?1 1 "g")     (eq-SC? '(3-9 3-10 3-12) (m ?1) (m ?2) (m ?3))     t)) "SC of the group 'g' = 3-5a")(* ?1 ?2 ?3 (?if    (if (or (note-in-group-at-pos? ?1 1 "r")           (note-in-group-at-pos? ?1 1 "h"))     (eq-SC? '(3-1) (m ?1) (m ?2) (m ?3))     t)) "SC of the group 'r' = 3-9 3-10 3-12")(* ?1 (?if (let ((hc-midis (hc-midis ?1)))     (if hc-midis        (eq-SC? '(2-5) (cons (m ?1)  hc-midis))        t)))) (* ?1 ?2  (?if           (if (= (partnum ?1) 1)             (let ((hc-midi1-pc (mod (first (hc-midis ?1)) 12))                   (hc-midi2-pc (mod (first (hc-midis ?2)) 12)))               (and (/=  (mod (m ?1) 12) hc-midi2-pc)                    (/=  (mod (m ?2) 12) hc-midi1-pc)))             t)) "no cross relations");;Ex2(* ?1 ?2 ?3 ?4 (?if    (if (note-in-group-at-pos? ?1 1 "g")     (eq-SC? '(4-27a) (m ?1) (m ?2) (m ?3)  (m ?4))     t)) "SC of the group 'g' = 4-27a");;;;; (* ?1 ?2 (?if    (if (note-in-group-at-pos? ?1 1 "z")       (let ((ms (list (m ?1) (m ?2))))         (and (setp ms :key #'(lambda (n) (mod n 12)))              (member (SC-name ms) '#.(all-subs  '(4-1)))))       t)) "SC of the group 'z' subclass of 4-1")(* ?1 ?2 (?if   (let (pmidis)   (if (and (note-in-group-at-pos? ?1 1 "z")            (setq pmidis (prev-group-midis ?1 "z")))       (let ((ms (append (list (m ?1) (m ?2))  pmidis)))         (and (setp ms :key #'(lambda (n) (mod n 12)))              (eq-SC? '(4-1) ms)))       t))) "SC of the group 'z' = 4-1")|#