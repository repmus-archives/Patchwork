;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;========================;  general;========================(defmethod map-result ((self part-collection) res1)  (let (res temp (sorted-variables (read-key self :sorted-s-variables)))    (dolist (variables (read-key self :part-s-variables-ls-ls))      (dolist (variable variables)         (push (nth (position variable sorted-variables) res1) temp))      (push (nreverse temp) res)      (setq temp nil))    (nreverse res)))(defun result->mlines (res mlines)  (when res    (setq res (pw::flat res))    (dolist (chords (mapcar #'pw::get-rchords mlines))      (dolist (chord chords)        (setf (pw::midic (car (pw::notes chord))) (* 100 (pop res)))        (mapc #'(lambda (n) (pw::update-note n)) (pw::notes chord))        (pw::update-chord chord)))    (when (and pw::*current-score-PMC-RTM-window*              (wptr pw::*current-score-PMC-RTM-window*))      (pw::erase+view-draw-contents pw::*current-score-PMC-RTM-window*)))) (defun call-all-prepare-fns (fns+args-list)  (mapcar #'(lambda (l) (apply #'funcall (car l) (rest l))) fns+args-list)) ;========================; score-search-engine;========================(defclass score-search-engine (search-engine)   ((no-attack-rules :initform nil :initarg :no-attack-rules :accessor no-attack-rules)));========================; forward-checking;========================(defmethod prune-last-arc-domain ((self score-search-engine) variable candidate)  (let ((arcs (arcs variable))         next-domain-temp)    (when arcs      (setf (value variable) candidate)      (dolist (arc arcs)        (let* ((fn (fn arc))               (next-s-variable (next-s-variable arc))               (s-variables (prev-s-variables arc))               (next-variable-domain (domain next-s-variable)) next)          (setq next-domain-temp nil)           (while next-variable-domain            (setq next (pop next-variable-domain))            (setf (value next-s-variable) next)            (when (apply #'funcall fn s-variables)                (push next next-domain-temp)))          (setf (domain next-s-variable) (nreverse next-domain-temp))          (setf (value next-s-variable) nil)))      ;(setf (value variable) candidate)      )))   (defmethod forward-check ((self score-search-engine) variable candidates)  (let ((arcs (arcs variable)) fl arcs-c arc res)    (if arcs      (progn        (dolist (candidate candidates)          (setf (value variable) candidate)          (setq arcs-c arcs)          (setq fl t)          (while (and fl arcs-c)            (setq fl nil) ;; each arc has to be true            (setq arc (pop arcs-c))            (let* ((fn (fn arc))                    (next-s-variable (next-s-variable arc))                   (s-variables (prev-s-variables arc))                   (next-variable-domain (domain next-s-variable)))              (while (and (null fl) next-variable-domain)                (setf (value next-s-variable) (pop next-variable-domain))                (when (apply #'funcall fn s-variables) ; at least one item is supported                  (setq fl t)))              (setf (value next-s-variable) ())))          (when fl (push candidate res)))        ;;(setf (value next-s-variable) ())        (nreverse res))      candidates)));========================;   heuristic rules;========================(defmethod apply-heuristic-rules ((self score-search-engine) s-variable candidates)  (if (heuristic-rules self)    (let* ((prev-items-rev (read-key s-variable :prev-staff-items-rev))           (prev-items (read-key s-variable :svars-list))             (end-sitems-list (read-key s-variable :end-svars-list))           (fns (heuristic-rules self))           (sindex (sindex s-variable))            (len sindex)            score score+cand-pairs heuristic-rules-applied? res)      (setf (nthcdr sindex prev-items) nil)      (dolist (candidate candidates)        (setq score 0)        (setf (value s-variable) candidate)        (dolist (fn fns)          (setq res (funcall fn prev-items prev-items-rev len))          (when (numberp res)             (setq heuristic-rules-applied? t)            (incf score res)))          (push (list score candidate) score+cand-pairs))      (setq candidates (if heuristic-rules-applied?                         (mapcar #'second (sort score+cand-pairs #'> :key #'first))                         candidates))      (setf (value s-variable) nil)      (setf (nthcdr sindex prev-items) end-sitems-list)      candidates)    candidates));========================; apply-rules;========================(defmethod jumpback ((self score-search-engine) variable)"if the rule returns instead of nil :jumpback then jump-back jumps directly to the previous melodic s-variable"   (let ((target-item (prev-item variable))) ;; prev melodic item     (when target-item      (let ((target-item-index (1+ (position target-item (search-variables self)))))        ;;1+ ->  stop one too early because backtrack will backtrack to the target-item;;        (while (not (= (variable-pos self) target-item-index))           (let ((current-variable (get-current-variable self)))            (set-init-state current-variable)            (step-backwards self)))))))(defmethod apply-rules-loop ((self score-search-engine) s-variable)  (let* ((prev-items-rev (read-key s-variable :prev-staff-items-rev))         (prev-items (read-key s-variable :svars-list))           (end-sitems-list (read-key s-variable :end-svars-list))         (candidates (domain s-variable))         (fns (rules self))         (no-attack-fns (no-attack-rules self))         (sindex (sindex s-variable))          (len sindex)          jumpback-fl         temp res)    (if (read-key s-variable :no-attack-s-item)         (let ((fl t)) ;(print 'no-attack)        (while (and fl no-attack-fns)           ;(unless (funcall (print (car no-attack-fns)) prev-items prev-items-rev 0); ???          (unless (funcall (car no-attack-fns) (list s-variable) (list s-variable) 1)            (write-diagnostics (car no-attack-fns))            (setq fl nil))          (pop no-attack-fns))        (setq candidates fl))      (progn (setf (nthcdr sindex prev-items) nil)             (dolist (fn fns)               (setq temp nil)               (setq jumpback-fl nil)               (while candidates                 (setf (value s-variable) (car candidates))                 (when (setq res (funcall fn prev-items prev-items-rev len)) ;; 3 args len !!                    (if (eq res :jumpback)                     (setq jumpback-fl t)                     (push (car candidates) temp)))                 (pop candidates))               (setf (value s-variable) nil)               (unless temp                 (write-diagnostics fn)                 (when jumpback-fl (jumpback self s-variable))                 (return nil))                          (setq candidates (nreverse temp)))             (setf (nthcdr sindex prev-items) end-sitems-list)))    candidates))(defmethod apply-rules ((self score-search-engine) search-variable)  (let (candidates)    (when (setq candidates (apply-rules-loop self search-variable))      (if (eq t candidates)         t        (progn          (setq candidates                 (apply-heuristic-rules self search-variable                                       (forward-check self search-variable candidates)))          (when candidates (prune-last-arc-domain self search-variable (first candidates)))                       (if (and candidates (listp candidates))            (progn               (update-values search-variable candidates)              (write-value-to-partial-sols-list self search-variable (first candidates))              t)            nil))))))(defmethod write-value-to-partial-sols-list ((self score-search-engine) s-variable candidate)  (declare (ignore s-variable candidate)));=======================================================(defmethod backtrack ((self score-search-engine))  (if (fail-case? self)    (fail self)    (let ((search-variable (get-current-variable self)))      (update-domains self search-variable)       (if (set-new-forward-state- search-variable)        (forward self)        (progn (set-init-state search-variable) (step-backwards self) (backtrack self))))));=======================================================;     optimize - avoid consing with l and rl;=======================================================(defun optimize-search-items-lists (s-variables)  (let*  ((orig-list (copy-list s-variables))          (rev-items (reverse s-variables))          (rev-items-c rev-items))     (for (i 1 1 (length s-variables))      (write-key (nth (1- i) s-variables) :svars-list orig-list)       (write-key (nth (1- i) s-variables) :write-pos (nthcdr (1- i) orig-list)) ;; (setf (first write-pos ..)      (write-key (nth (1- i) s-variables) :end-svars-list (nthcdr i orig-list)))     (for (i 0 1 (1- (length rev-items)))      (write-key (pop rev-items-c) :prev-staff-items-rev (nthcdr i rev-items)))));=======================================================;    make-score-search-engine;=======================================================(defun make-score-engine (staff-coll rules                           &key (no-attack-rules ()) (fwc-rules ()) (heuristic-rules ())                          (prepare-fns+args nil) (class 'score-search-engine)                          (sols-mode :once) (print-fl nil))  (let* ((engine          (make-instance class            :search-variables (apply #'vector (read-key staff-coll :sorted-s-variables))               :rules rules             :heuristic-rules heuristic-rules              :no-attack-rules no-attack-rules              :sols-mode sols-mode            :print-fl print-fl))         search-variables-list sitems)    (setq *current-SE* engine)    (setf (search-variables-list engine) (coerce (search-variables engine) 'list))    (setq search-variables-list (search-variables-list engine))    (when fwc-rules (convert-score-rules-to-arcs fwc-rules))    (dolist (staff-variables (read-key staff-coll :part-s-variables-ls-ls)) ;; optimize staff-item reading      (setq sitems (cons (first staff-variables) (all-next-items (first staff-variables)))) ;;;???      (optimize-search-items-lists sitems))     (dolist (item search-variables-list)      (write-key item :note-index (position item search-variables-list)))      (call-all-prepare-fns prepare-fns+args)      engine))(defun score-PMC (m-lines ranges rules                            &key (no-attack-rules ()) (fwc-rules ()) (heuristic-rules ())                          (prepare-fns+args nil)                          (sols-mode :once) (rnd? nil) (print-fl nil)  ;(update-fl t)                           (class 'score-search-engine) (allowed-pcs ()))  (when (atom m-lines) (setq m-lines (list m-lines)))  (assert   (eq (type-of (first m-lines)) 'pw::c-measure-line) ()      "****1st input should be a list of pw::c-measure-lines !  ****" ())  (assert   (or (eq (type-of (first ranges)) 'pw::c-measure-line)                (listp  ranges)) ()     "**** 2nd input should be a list of pw::c-measure-lines or a list      of ranges, or a list of lists of ranges !! ****" ())  (assert   (listp  rules) ()     "**** 3rd input should be a list of rules !! ****" ())  (unless (listp (car rules)) (setq rules (list rules)))   (setf *measure-lines* m-lines)  (let* ((staff-coll (polif-score->search m-lines ranges rnd? allowed-pcs))         (engine (make-score-engine                   staff-coll (mk-PMC-fns rules)                       :no-attack-rules (mk-PMC-fns no-attack-rules)                  :fwc-rules (remove-package-expression fwc-rules)                  :heuristic-rules (mk-PMC-fns heuristic-rules)                   :prepare-fns+args prepare-fns+args                  :sols-mode sols-mode :class class :print-fl print-fl))         res)    (start-diagnostics (rules engine))    (time (start engine))    (setq res (mapcar #'(lambda (l) (map-result staff-coll l)) (all-sols engine)))    (result->mlines res m-lines)  ;;(when update-fl (result->mlines res m-lines))    (when *constraint-diagnostics*          (terpri) (format t "Rule diagnostics:") (read-diagnostics (rules engine)))    res))