;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;=====================================================; linked-beat measure staff part-coll;=====================================================;=====================================================;  Read-key info; search-variable:     :beat :measure :part :part-num :mel-index;                      :time+dur :harmonic-context :harmonic-slice;                      :no-attack-s-item; linked-beat:         :s-variables :measure :b-num :rtm-pattern;=====================================================(defclass linked-beat (key-item linked-list-item) ())(defun make-linked-beat (measure b-num rtm-list s-variables)  (let ((linked-beat (make-instance 'linked-beat)))    (write-key linked-beat :s-variables s-variables)    (write-key linked-beat :measure measure)    (write-key linked-beat :b-num b-num)    (write-key linked-beat :rtm-pattern rtm-list)    (map-rtm-list-to-s-variables (first rtm-list) (second rtm-list) s-variables)    (mapc #'(lambda (s-variable)               (write-key s-variable :beat linked-beat)              (write-key s-variable :measure measure)              (write-key s-variable :part (read-key measure :part))              (write-key s-variable :part-num (read-key (read-key measure :part) :part-num)))          s-variables)    linked-beat));=====================================================;  Read-key info; linked-measure:         :part :m-num :beats :sign :time;=====================================================(defclass linked-measure (key-item linked-list-item) ())(defun make-linked-measure (staff m-num sign time)  (let ((linked-measure (make-instance 'linked-measure)))    (write-key linked-measure :part staff)    (write-key linked-measure :m-num m-num)    (write-key linked-measure :sign sign)    (write-key linked-measure :time time)    linked-measure));=====================================================;  Read-key info; linked-staff:         :part-num :measures;=====================================================(defclass linked-staff (key-item linked-list-item) ())(defun make-linked-staff (staff-num)  (let ((linked-staff (make-instance 'linked-staff)))    (write-key linked-staff :part-num staff-num)    linked-staff));=====================================================;  Read-key info; part-collection:    :parts :harmonic-slices ;                      :part-s-variables-ls-ls :s-variables-vects;                      :sorted-s-variables (after score-sort);=====================================================(defclass part-collection (key-item) ())(defun make-part-collection (staffs s-variables-ls-ls)  (let ((ind 1))    (mapc #'(lambda (s-variables-ls)              (setq ind 1)  ;; count from 1              (mapc #'(lambda (s-variable)                        (write-key s-variable :mel-index ind) ;; write staff-index (sindex)                        (incf ind))                    s-variables-ls))          s-variables-ls-ls))  (let ((part-collection (make-instance 'part-collection)))    (write-key part-collection :parts staffs)    (write-key part-collection :part-s-variables-ls-ls s-variables-ls-ls) ; s-vars for each-staff    (write-key part-collection :s-variables-vects (mapcar #'(lambda (l) (apply #'vector l)) s-variables-ls-ls))     part-collection));=====================================================; attack-times, measure-times, note-constraints;=====================================================; truncate?(defun get-attack-ts+durs (m-lines)  (let ((pw::*rtm-duration-scaler* 1.))    (mapc #'pw::calc-t-time-measure-line  m-lines (pw::cirlist 1.0))    (mapcar #'(lambda (chs)                 (mapcar #'(lambda (ch)                             (list (pw::t-time ch) (pw::dur (car (pw::notes ch))))) chs))                (mapcar #'(lambda (m-line) (mapcar #'pw::beat-chord (pw::collect-all-chord-beat-leafs m-line)))                  m-lines))));(get-attack-ts+durs *measure-lines*)    #|(defun get-measure-times (measures)  (let ((time 0) (res (list 0)))    (while measures       (push (setq time (pw::calc-t-time-measure    (pop measures) 1. time)) res))    (nreverse res))) |#(defun get-measure-times (measures)  (let ((time 0) (res (list 0)))    (while measures     ;(print (list (pw::calc-measure-length   (car measures) 1.) (pw::calc-t-time-measure   (car measures) 1. time)))       (push (setq time (+ time (pw::calc-measure-length   (pop measures) 1.))) res))    (nreverse res)))(defun chord-midis (ch)  (mapcar #'(lambda (n) (/ (pw::midic n) 100)) (pw::notes ch)))#|(defun get-score-constraints (m-lines)  (let (res)    (dolist (m-line m-lines)      (let ((beats (pw::collect-all-chord-beat-leafs m-line)) temp)        (dolist (beat beats)          (if (read-key (pw::beat-hash-table beat) 'pw::note-staccato)            (push  (chord-midis (pw::beat-chord beat)) temp)                (push  () temp)))        (push (nreverse temp) res)))    (nreverse res)))|#   (defun get-score-constraints (m-lines)  (let (res)    (dolist (m-line m-lines)      (let ((beats (pw::collect-all-chord-beat-leafs m-line)) temp)        (dolist (beat beats)          (if (or (read-key (pw::beat-hash-table beat) 'pw::note-staccato)                  (read-key (pw::beat-hash-table beat) "."))            (push  (chord-midis (pw::beat-chord beat)) temp)                (push  () temp)))        (push (nreverse temp) res)))    (nreverse res)));(get-score-constraints ml)    ;===============================================================;                 score->part-collection;===============================================================; all linked: staffs measures beats harmonic-slices;===============================================================(defun score->part-collection (signs-list rtm-lists t-times+durs measure-times)  (setq measure-times (pw::flat measure-times))  (let (linked-staffs linked-staff attack-count s-variables linked-measure linked-measures t-time+dur         m-num beat-num beat-sum m-beats rtm-l  (staff-num 1) beats s-variables-ls s-variables-ls-ls)    (dolist (signs signs-list)      (setq linked-staff (make-linked-staff staff-num))      (push linked-staff linked-staffs)      (setq rtm-l (pop rtm-lists))      (setq t-time+dur (pop t-times+durs))      (setq m-num 1)      (dolist (sign signs)        (setq beat-num 1)        (setq beat-sum 0)        (setq m-beats ())          (setq linked-measure (make-linked-measure linked-staff m-num sign (pop measure-times)))        (while (> (car sign) beat-sum)           (setq attack-count (attack-count (second (car rtm-l))))           (setq s-variables ())           (repeat attack-count              (push (make-instance 'search-variable) s-variables)              (write-key (car s-variables) :time+dur (pop t-time+dur)))             (setq s-variables (nreverse s-variables))           (push (make-linked-beat linked-measure beat-num (car rtm-l) s-variables) m-beats)          (incf beat-sum (first (car rtm-l)))          (incf beat-num)          (pop rtm-l))        (write-key linked-measure :beats (nreverse m-beats))        (push linked-measure linked-measures)                (incf m-num))      (setq linked-measures (nreverse linked-measures))      (link-list linked-measures)   ;; link staff measures       (link-list (setq beats (pw::flat (mapcar #'(lambda (m) (read-key m :beats)) linked-measures))))  ;; link staff beats        (link-list (setq s-variables-ls (remove nil (pw::flat (mapcar #'(lambda (b) (read-key b :s-variables)) beats)))))  ;; link staff s-variables       (push s-variables-ls s-variables-ls-ls)      (write-key linked-staff :measures linked-measures)      (setq linked-measures ())      (incf staff-num))    (setq linked-staffs (nreverse linked-staffs))    (link-list linked-staffs)  ;; link staffs     (make-part-collection linked-staffs (nreverse s-variables-ls-ls))))(defun score->part-coll (m-lines) (assert (pw::measures (car m-lines)) () "**** No measures in m-mlines! ****" ())   (let ((signs-list (pw::rtm-signs m-lines))         (rtm-lists (pw::rtm-tree m-lines))         (t-times+durs (get-attack-ts+durs m-lines))        (measure-times (mapcar #'(lambda (ml) (get-measure-times  (pw::measures ml))) m-lines)))    (score->part-collection signs-list rtm-lists t-times+durs measure-times)));(time (score->part-collection ml));===============================================;   harmonic-slices;===============================================;=====================================================;  Read-key info; harmonic-slice:    (:time) :s-variables :time+dur;=====================================================(defclass harmonic-slice (key-item linked-list-item) ())(defun make-harmonic-slice (clock s-variables)  (let ((harmonic-slice (make-instance 'harmonic-slice)))    (write-key harmonic-slice :time clock)    (write-key harmonic-slice :s-variables s-variables)    harmonic-slice))(defun make-harmonic-slices (part-coll) (let* ((l (pw::flat (read-key part-coll :part-s-variables-ls-ls)))        (endts (mapcar #'endt l))        (starts (mapcar #'startt l))        (start+end (sort (remove-duplicates (append  starts endts)) #'<)))   (let (harmonic-slices temp)      (dolist (clock start+end)       (dolist (item l)         (when (and (<= (startt item) clock)                    (< clock (endt item)))            (push item temp)))       (setq temp (nreverse temp))       (when (and harmonic-slices (not (read-key (car harmonic-slices) :time+dur)))          (write-key (car harmonic-slices) :time+dur                      (list (read-key (car harmonic-slices) :time)                           (- clock (read-key (car harmonic-slices) :time)))))        (when temp         (push (make-harmonic-slice clock temp) harmonic-slices))       (setq temp ()))   (setq harmonic-slices (nreverse harmonic-slices))   (link-list harmonic-slices)   (write-key part-coll :harmonic-slices harmonic-slices))))#|;(time (length (make-harmonic-slices sc)))(all-next-items (nth 5 (read-key sc :harmonic-slices)))(mapcar #'(lambda (n) (read-key n :time+dur)) (all-prev-items (nth 5 (read-key sc :harmonic-slices))))(mapcar #'(lambda (n) (read-key n :time+dur)) (read-key sc :harmonic-slices))(mapcar #'(lambda (n) (read-key n :time)) (read-key sc :harmonic-slices))(collect-only-attacks (nth 9 (read-key sc :harmonic-slices)))|#;==========================================================================================; harmonic-context order?;(setf *search-order* :from-sop)(defun sort-search-items+write-harmonic-context (part-coll)  (let ((harmonic-slices (read-key part-coll :harmonic-slices))        sounding-items only-attacks rev-only-attacks no-attack-s-item res)    (while harmonic-slices       (setq only-attacks (sort (collect-only-attacks (car harmonic-slices)) #'>                                :key #'(lambda (item) (+ (endt item)                                                         (case *search-order*                                                           (:from-bass (/ (read-key (read-key item :part) :part-num) 1000))                                                           (:from-sop (- (/ (read-key (read-key item :part) :part-num) 1000)))                                                           (t 0))))))       (mapc #'(lambda (s-variable) (write-key s-variable :harmonic-slice (car harmonic-slices))) only-attacks)       (setq sounding-items (set-difference (read-key (car harmonic-slices) :s-variables) only-attacks))       (setq rev-only-attacks (reverse only-attacks))       (while rev-only-attacks          (write-key (car rev-only-attacks) :harmonic-context (append sounding-items (cdr rev-only-attacks)))          (pop rev-only-attacks))       (if only-attacks          (push only-attacks res)         (progn (setq no-attack-s-item (make-instance 'search-variable))                (setf (domain no-attack-s-item) (list 0)) ;?                (write-key no-attack-s-item :harmonic-context (read-key (car harmonic-slices) :s-variables))                (write-key no-attack-s-item :harmonic-slice (car harmonic-slices))                (write-key no-attack-s-item :no-attack-s-item t)                (write-key no-attack-s-item :time+dur (read-key (car harmonic-slices) :time+dur))                (push (list no-attack-s-item) res)))       (pop harmonic-slices))    (write-key part-coll :sorted-s-variables (apply #'append (nreverse res)))));==========================================================================================(in-package :PW)#|(defun rtm-dels-no-calc (measure-lines)  (mapcar #'(lambda (m-line)              ;(pw::calc-t-time-measure-line m-line 1.0)              (x->dx (ask-all                      (ask-all (collect-all-chord-beat-leafs m-line) #'beat-chord)                      #'t-time)))          measure-lines))|#(defun give-rtm-contours (m-lines &optional full-chord-fl)   (when (listp m-lines)    ;(rtm-dels-no-calc m-lines) ??    (let ((b-leafs (ask-all  m-lines #'collect-all-chord-beat-leafs))          b-leafs-now note-time-list note-time-lists chord-midis)      (while b-leafs        (setq b-leafs-now (pop b-leafs))        (setq note-time-list ())        (while b-leafs-now          (setq chord-midis (pwcs::chord-midis (beat-chord (car b-leafs-now))))          (push (list (t-time (beat-chord (car b-leafs-now))) (if full-chord-fl chord-midis (car chord-midis))) note-time-list)          (pop b-leafs-now))        (push (nreverse note-time-list) note-time-lists))      (nreverse note-time-lists)))) ;==========================================================================================(in-package "PWCS"); ranges atom, list , list of ranges , MLs; if ranges (in lists) longer than 2 two then they are not ranges but absolute values !! (what about absolute-vs of length = 2(defparameter *note-s-var-association-htable* ())#|(defun link-PW-notes+s-vars (m-lines)  (setf *note-s-var-association-htable* (make-hash-table))  (let ((chords (pw::rtm-chords m-lines))         (s-vars (read-key *part-collection* :part-s-variables-ls-ls)) )   (mapc #'(lambda (ch-l sv-l)              (mapc #'(lambda (ch sv)                   (write-key sv :PW-chord ch)                  (write-key sv :PW-note (car (pw::notes ch)))                  (write-key  *note-s-var-association-htable* (car (pw::notes ch)) sv))                 ch-l sv-l))      chords s-vars)))|#;===============================================;; PW interface; svar   knows about PW-note PW-chord PW-beat; PW-note and PW-chord know about svar;===============================================(defun link-PW-notes+s-vars (m-lines)  (setf *note-s-var-association-htable* (make-hash-table))  (let ((pwbeats (mapcar #'pw::collect-all-chord-beat-leafs m-lines))         (s-vars (read-key *part-collection* :part-s-variables-ls-ls))        ch)    (mk-linked-group-collection (pwcs-build-chord-groups pwbeats))    (mapc #'(lambda (pwbeats-l sv-l)              (mapc #'(lambda (pwbeat sv)                         (setq ch (pw::beat-chord pwbeat))                        (write-key sv :PW-beat pwbeat)                        (write-key sv :PW-chord ch)                        (write-key sv :PW-note (car (pw::notes ch)))                        (write-key  *note-s-var-association-htable* ch sv) ;; back-pointers                        (write-key  *note-s-var-association-htable* (car (pw::notes ch)) sv))                    pwbeats-l sv-l))          pwbeats s-vars))) ;==========================================================================================(defun polif-score->search (m-lines ranges &optional (rnd? nil) (allowed-pcs ()))   (let ((sc (score->part-coll m-lines))        (constraints (get-score-constraints m-lines)))    (make-harmonic-slices sc)     (sort-search-items+write-harmonic-context sc)    (cond ((numberp (car ranges))             (mapc #'(lambda (item constraint)                        (setf (domain item)                                     (if constraint                                         constraint                                         (let* ((rng (pw::arithm-ser (car ranges) 1 (second ranges)))                                               (final-rng (if allowed-pcs (intersection rng allowed-pcs :key #'(lambda (n) (mod n 12))) rng)))                                           (if rnd? (pw::permut-random final-rng) final-rng))))                       (setf (domain-copy item) (domain item)))                   (pw::flat (read-key sc :part-s-variables-ls-ls)) (apply #'append constraints)))          ((eq (type-of (car ranges)) 'pw::c-measure-line)              (mapc #'(lambda (items range constraintl)                  (let* ((time-chord-list (car (pw::give-rtm-contours (list range) t)))                        (times (mapcar #'first time-chord-list))                          (bpf-low (pw::make-break-point-function  times (mapcar #'first (mapcar #'second time-chord-list))))                        (bpf-high (pw::make-break-point-function  times (mapcar #'second (mapcar #'second time-chord-list)))))               (mapc #'(lambda (item constraint)                      (let ((low (pw::bpf-out  bpf-low (startt item) times nil))                           (high (pw::bpf-out bpf-high (startt item) times nil)))                         (setf (domain item)                                     (if constraint                                         constraint                                         (let* ((rng (pw::arithm-ser low 1 high))                                               (final-rng (if allowed-pcs (intersection rng allowed-pcs :key #'(lambda (n) (mod n 12))) rng)))                                           (if rnd? (pw::permut-random final-rng) final-rng))))                         (setf (domain-copy item) (domain item))))                     items constraintl)))                  (read-key sc :part-s-variables-ls-ls) ranges constraints))          ((listp (caar ranges))            (mapc #'(lambda (items rangel constraintl)                (mapc #'(lambda (item range constraint)                           (setf (domain item)                                     (if constraint                                         constraint                                         (let* ((rng                                                (if (> (length range) 2)                                                  range                                                (pw::arithm-ser (car range) 1 (if (second range) (second range) (first range)))))                                               (final-rng (if allowed-pcs (intersection rng allowed-pcs :key #'(lambda (n) (mod n 12))) rng)))                                           (if rnd? (pw::permut-random final-rng) final-rng))))                         (setf (domain-copy item) (domain item)))                     items rangel constraintl))                  (read-key sc :part-s-variables-ls-ls) ranges constraints))                    ((listp (car ranges))            (mapc #'(lambda (items range constraintl)                (mapc #'(lambda (item constraint)                          (setf (domain item)                                     (if constraint                                         constraint                                         (let* ((rng                                                 (if (> (length range) 2)                                                  range                                                  (pw::arithm-ser (car range) 1 (second range) )))                                               (final-rng (if allowed-pcs (intersection rng allowed-pcs :key #'(lambda (n) (mod n 12))) rng)))                                           (if rnd? (pw::permut-random final-rng) final-rng))))                         (setf (domain-copy item) (domain item)))                     items constraintl))                  (read-key sc :part-s-variables-ls-ls) ranges constraints))                    )     (setf *staff-collection* sc)    (setf *part-collection* sc)    (link-PW-notes+s-vars m-lines)    sc));(time (setq sc (polif-score->search *measure-lines* '(80 99))));(time (link-PW-notes+s-vars *measure-lines*));(time (setq sc (polif-score->search *measure-lines* '((50 89) (78 90) (80 99)))));(domain (car (first (read-key sc :part-s-variables-ls-ls))));(domain (car (second (read-key sc :part-s-variables-ls-ls))));(domain (nth 7 (third (read-key sc :part-s-variables-ls-ls))))#|(read-key(read-key *note-s-var-association-htable* (first (pw::notes (first (first (pw::rtm-chords *measure-lines*)))))):PW-note)|#