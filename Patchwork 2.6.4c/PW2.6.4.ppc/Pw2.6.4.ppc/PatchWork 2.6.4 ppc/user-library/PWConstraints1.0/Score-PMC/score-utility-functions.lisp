;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package "PWCS");===============================================;================================================================; score utilities;================================================================;================================================================;  Read-key info;================================================================; search-variable:      :beat :measure :part :part-num :mel-index;                       :time+dur :harmonic-context :harmonic-slice;                       :no-attack-s-item;; linked-beat:          :s-variables :measure :b-num :rtm-pattern;; linked-measure:       :part :m-num :beats :sign :time;; linked-staff:         :part-num :measures;; harmonic-slice:     :s-variables :time+dur (:time);; part-collection:      :parts :harmonic-slices ;                       :part-s-variables-ls-ls :s-variables-vects;                       :sorted-s-variables (after score-sort);================================================================;===============================================; basic;===============================================(defun part-collection ()"returns the current part-collection"  *part-collection*)(defmacro beat (s-variable) "returns the linked-beat of s-variable"  `(read-key ,s-variable :beat))(defmacro measure (s-variable) "returns the linked-measure of s-variable"  `(read-key ,s-variable :measure))(defmacro hc (s-variable)  "returns the harmonic-context of s-variable as a list s-variables"  `(read-key ,s-variable :harmonic-context))(defmacro hslice (s-variable)  "returns the harmonic-slice of s-variable as a list s-variables"  `(read-key ,s-variable :harmonic-slice))(defmacro partnum (s-variable)  "returns the part number of the part of s-variable   (starting from 1)"  `(read-key ,s-variable :part-num)) ; from 1; old(defmacro staffnum (s-variable)   `(read-key ,s-variable :part-num)) ; from 1(defmacro mindex (s-variable) "returns the mel-index (melodic index) of s-variable  (starting from 1)"  `(read-key ,s-variable :mel-index)) ; from 1; old(defmacro sindex (s-variable) "staff index"  `(read-key ,s-variable :mel-index)) ; from 1(defmacro beatnum (s-variable)  "returns the beat number (inside a measure) of the beat of s-variable   (starting from 1)"  `(read-key (read-key ,s-variable :beat) :b-num)) ; from 1 inside measure !(defmacro measurenum (s-variable)  "returns the measure number of the measure of s-variable   (starting from 1)"  `(read-key (read-key ,s-variable :measure) :m-num));===============================================; To get variables from the vector i.e. the variables are ordered ; according to score-sort! (defmethod all-vect-prev-s-vars ((self search-engine))"returns all previous s-variables from the score in reversed score-sort order"  (let ((variable-pos (variable-pos self))        res)    (for (i variable-pos -1 0)       (push (svref  (search-variables self) i) res))    (nreverse res)))(defmethod all-vect-prev-sols ((self search-engine))"returns all previous midis from the score in reversed score-sort order"  (let ((variable-pos (variable-pos self))        res)    (for (i variable-pos -1 0)       (push (v (svref  (search-variables self) i)) res))    (nreverse res)));===============================================; rtm;===============================================(defmacro rtm-pattern (beat) "returns the rtm-pattern of beat"  `(read-key ,beat :rtm-pattern));===============================================; chords, s-vars to midis;===============================================(defmacro hc-midis (s-variable) "returns all midi-values of the harmonic-context of s-variable"  `(mapcar #'(lambda (n) (m n)) (read-key ,s-variable :harmonic-context)))(defun l->ms (s-variables)  "returns the midi-values of s-variables"  (mapcar #'(lambda (s-variable) (value s-variable)) s-variables));===============================================; startt, endt, durt  etc.;===============================================; for s-variable and harmonic-slice(defun startt (obj)  "returns the start time (in ticks) of obj (s-variable or hslice)"  (first (read-key obj :time+dur)))(defun endt (obj)  "returns the end time (in ticks) of obj (s-variable or hslice)"  (let ((l (read-key obj :time+dur))) (+ (first l) (second l))))(defun durt (obj)  "returns the duration (in ticks) of obj (s-variable or hslice)"  (let ((l (read-key obj :time+dur))) (second l)))(defun attack-item? (hslice s-variable) "returns true if s-variable, being a member of hslice,   is an attack s-variable"  (= (startt hslice) (startt s-variable)))(defun collect-only-attacks (hslice) "returns only attack-items of hslice (harmonic-slice)"  (mapcan #'(lambda (s-variable)              (when (attack-item? hslice s-variable)                (list s-variable)))          (read-key hslice :s-variables)));===============================================; general;===============================================(defun voice-count (?1)"returns the number of (sounding) parts at ?1"   (length (read-key (hslice ?1) :s-variables)))(defun constraint? (?1)"returns true if ?1 is constrained, i.e. its domain contains only one value"  (= (length (domain ?1)) 1))(defun constraints? (&rest s-variables)"returns true if s-variables are constrained, i.e. their domains contain only one value"  (unless (atom (car s-variables)) (setq s-variables (apply #'append s-variables)))  (every #'(lambda (s-variable) (constraint? s-variable)) s-variables))  (defun one-constraint? (&rest s-variables)"returns true if atleast one s-variable of s-variables is constrained"  (some #'(lambda (s-variable) (constraint? s-variable)) s-variables))  (defun attack-items? (hslice s-variables)"returns true if all s-variables in hslice are attack-items"  (every #'(lambda (s-variable) (attack-item? hslice s-variable)) s-variables))  (defun complete-chord? (s-variable)"returns true if s-variable 'completes' the chord, i.e. is the last note in the hslice of s-variable"  (= (length (read-key (hslice s-variable) :s-variables))      (1+ (length (hc s-variable)))))  ;?? test(defun complete-chord-for-staffs? (s-variable partnums)  (let ((hslice (hslice s-variable))        (flag t))    (while (and flag partnums)      (setq flag (find  (pop partnums) hslice :key #'(lambda (n) (partnum n)))))    flag))(defun downbeat? (s-variable)"returns true is s-variable is on downbeat"  (= (car (last (read-key s-variable :rtm-pos))) 0))(defun on-main-beat? (s-variable)"returns true is s-variable is on downbeat and in the first beat of a measure"  (and (downbeat? s-variable)       (= (read-key (read-key s-variable :beat) :b-num) 1)))(defun prev-item-on-downbeat (s-variable)"returns previous downbeat s-variable off the previous beat"  (let ((prev-beat (prev-item (read-key s-variable :beat))) b-s-variable)    (when prev-beat      (setq b-s-variable (first (read-key prev-beat :s-variables)))      (when (and b-s-variable (downbeat? b-s-variable))        b-s-variable))))(defun prev-item-on-downbeat-2 (s-variable)"returns prev downbeat s-variable on (previous (previous beat))"  (let ((prev-beat (prev-item (read-key s-variable :beat))) b-s-variable)    (when prev-beat      (setq prev-beat (prev-item prev-beat))       (when prev-beat        (setq b-s-variable (first (read-key prev-beat :s-variables)))        (when (and b-s-variable (downbeat? b-s-variable))          b-s-variable)))))(defun bass-num () "returns the partnum of the lowest (bass) part"  (length (read-key *part-collection* :parts)))(defun bass-item? (?1)"returns true if ?1 is a bass-item, i.e. has thelargest partnum"  (= (partnum ?1)      (apply #'max (mapcar #'(lambda (i) (partnum i))                           (read-key (hslice ?1) :s-variables)))))(defun give-bass-item (?1)"returns the bass-item of ?1, i.e.the s-variable that has thelargest partnum"  (find      (apply #'max (mapcar #'(lambda (i) (partnum i))                           (read-key (hslice ?1) :s-variables)))     (read-key (hslice ?1) :s-variables) :key #'(lambda (sv) (partnum sv))))(defun sop-item? (?1)"returns true if ?1 belongs to the highest (soprano) part"  (= (partnum ?1) 1)) ;================; rests(defun rest-item? (?1)"returns true if ?1 is followed by a rest"  (let ((next-item (next-item ?1)))    (if next-item      (/= (endt  ?1) (startt  next-item))      t)))(defun prev-rest? (?1)"returns true if ?1 is preceded by a rest"  (let ((prev-item (prev-item ?1)))    (if prev-item      (/= (startt ?1) (endt prev-item))      t)))(defun one-prev-rests? (&rest s-variables)"returns true if one of s-variables is preceded by a rest"  (some #'(lambda (s-variable) (prev-rest? s-variable)) s-variables))  ;================; last-measure, etc.(defun last-measure? (?1) "returns true if ?1 belongs to the last measure"  (not (next-item (measure ?1))))(defun  nextto-last-measure? (?1) "returns true if ?1 belongs to the next to last measure"  (let ((next-ms (next-item (measure ?1))))     (if next-ms        (not (next-item next-ms))        t)))(defun last-item? (?1)"returns true if ?1 is the last note within a part"  (= (sindex ?1)      (length (nth (1- (partnum ?1))                   (read-key *part-collection* :s-variables-vects)))));===============================================; voice-crossings etc.;===============================================(defun no-voice-crossings? (s-var)"no voice crossings allowed"  (let ((hc (hc s-var))        sorted-s-var-list)   (if hc    (progn       (setq sorted-s-var-list             (sort (copy-list (cons s-var (hc s-var))) #'>                   :key #'(lambda (sv) (partnum sv))));; from bass to sop      (apply #'<= (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)))    t))) (defun collect-by-partnum (partnums hc-compl)"collect all s-variables that belong parts given by partnums"  (let (res)    (while partnums       (push (find (pop partnums) hc-compl :key #'(lambda (sv) (partnum sv))) res))    (nreverse res)));old(defun no-staffs-voice-crossings? (s-var partnums)  (no-parts-voice-crossings? s-var partnums))(defun no-parts-voice-crossings? (s-var partnums)"checks that parts belonging to partnums are not allowed to cross"  (if (not (member (partnum s-var) partnums))    t    (let ((hc-compl (cons s-var (hc s-var))))      (if (= (length (intersection partnums (mapcar #'(lambda (sv) (partnum sv)) hc-compl)))             (length partnums))         (let (sorted-s-var-list)           (setq sorted-s-var-list                 (sort (collect-by-partnum partnums hc-compl) #'>                       :key #'(lambda (sv) (partnum sv))));; from bass to sop          ;(print (mapcar #'(lambda (sv) (partnum sv)) sorted-s-var-list))           (apply #'<= (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)))        t))))(defun  no-bass-crossings? (s-var)"bass (= lowest part) should have the lowest midi value" (let ((hc+s-var (cons s-var (hc s-var)))       bass-s-var)  (if (setq bass-s-var (find-if #'bass-item? hc+s-var))    (not (find-if #'(lambda (s-var) (< (m s-var) (m bass-s-var)))                   (remove bass-s-var hc+s-var)))    t))) ;(not (find-if #'(lambda (item) (< item 45)) '(61 53 62 88 65 66)));(not (find-if #'(lambda (item) (< item 45)) '(61 53 22 88 65 66)))(defun  no-sop-crossings? (s-var)"sop (= highest part) should have the highest midi value" (let ((hc+s-var (cons s-var (hc s-var)))       sop-s-var)  (if (setq sop-s-var (find-if #'sop-item? hc+s-var))    (not (find-if #'(lambda (sv) (< (m sop-s-var) (m sv)))                   (remove sop-s-var hc+s-var)))    t)))(defun  no-unisons? (s-var &optional (only-downbeat? t))"unisons not allowed, if only-downbeat? is true then only downbeat cases are checked"  (let ((hc (hc s-var)))   (if (and hc (if only-downbeat? (downbeat? s-var) t))    (not (member (m s-var) hc :key #'(lambda (sv) (m sv))))    t)))(defun inside-voice-distance? (?1 tolerance)"voices above or below ?1 should have pitches that are withintolerance distance to the pitch of ?1"  (let ((fl t)         (ref-partnum (partnum ?1)))    (dolist (?item (hc ?1))         (when (and (or (= (1+ (partnum ?item)) ref-partnum)                      (= (1- (partnum ?item)) ref-partnum))                 (> (abs (- (m ?1) (m ?item))) tolerance))        (setq fl nil) (return)))    fl)) #|; new version check !!(defun inside-voice-distance? (s-item tolerance)  (not    (find-if                                                    ; 1    #'(lambda (?item)           (and (or (= (1+ (partnum ?item)) (partnum s-item))   ; 2                 (= (1- (partnum ?item)) (partnum s-item)))             (> (abs (- (m s-item) (m ?item))) tolerance)))    ; 3    (hc s-item))))(* ?1 (?if (inside-voice-distance? ?1 17)) "inside-voice-distance max 17") |#;============================================================; imitation;============================================================(defun index-note (partnum index)  "returns nth (index) note of nth (partnum) staff"  (svref     (nth (1- partnum) (read-key *part-collection* :s-variables-vects))   (1- index)))(defun imitation? (?1 ref-part start-index end-index                     imit-part  imit-start-index imit-int) "imitation rule. ?1 is the current note, ref-part is the partnum of the partto be imitated, start-index is the start position (melodic-index) and end-index the end position (counting from 1) of the melodic line to be imitated; imit-part is partnum of the part that imitates ref-part, start-index is the start positionwhere the imitation starts and imit-int gives the imitation interval (or a list of intervals).For instance if we want the first 5 notes of part 1 to be imitated one octave lowerby part 2 also starting from note 1, we write the following rule:(* ?1 (imitation? ?1 1 1 5 2 1 -12))"  (let ((sindex (sindex ?1))        (imit-end-index (+ imit-start-index (- end-index start-index)))          ref-note)    (if (and (<= start-index sindex end-index)                                            (= (partnum ?1) ref-part))      (member (+ (m ?1) imit-int)                                                         (domain (index-note imit-part                                    (+ imit-start-index (- sindex start-index)))))      (if (and (<= imit-start-index sindex imit-end-index)                (= (partnum ?1) imit-part))         (progn (setq ref-note (index-note ref-part                                           (- sindex (- imit-start-index start-index))))               (= (+ (m ref-note) imit-int) (m ?1)))        t))));============================================================;  long notes;============================================================#|(defun prev-long-note-midis (rl time-limit &optional cnt)"collects all previous midis for notes that are equal or longer than time-limit (in ticks).If cnt is given only cnt previous midis are given"  (let (res)    (while (and rl (if cnt (<= (length res) cnt) t))      (when (>= (durt (car rl)) time-limit)        (push (m (car rl)) res))      (pop rl))    (nreverse res)))|#(defun prev-long-note-midis (rl time-limit &optional cnt time-window)"collects all previous midi-values for notes whose durations are equal or longer than time-limit (in ticks). If cnt is given only cnt previous midi-values are returned. If time-window (in ticks) is given prev-long-note-midis returns only 'long-note' midi-values inside time-window"  (if (>= (durt (car rl)) time-limit)    (let (res (prev-startt (startt (car rl))))      (while (and rl                   (if cnt (<= (length res) cnt) t)                  (if time-window                     (<= (- prev-startt (startt (car rl))) time-window)                     t))        (when (>= (durt (car rl)) time-limit)          (push (m (car rl)) res))        (pop rl))      (nreverse res))    ()));============================================================; scale, up-down, parallel etc. movements;============================================================(defun up-down-movem? (n1 n2 n3)"checks whether the note succession n1 n2 n3 is strictly ascending ordescending"  (and (or (< n1 n2 n3) (> n1 n2 n3))))(defun scale-movem? (n1 n2 n3)"returns true if n1 n2 n3 are in ascending or descending order and the adjacent note intervals between them do not exceed a major 2nd"  (and (or (< n1 n2 n3) (> n1 n2 n3))       (and (< (abs (- n1 n2)) 3) (< (abs (- n2 n3)) 3))))(defun stepwise? (n1 n2)"checks whether the note succession n1 n2 is stepwise"  (let ((int (abs (- n1 n2))))    (or (= int 1)(= int 2))))(defun side-movem? (n1 n2 n3 &optional (only-down t))"returns true if n1 is equal to n3 and n2 is maximally a major 2nd higher or lower than n1. The optional argument, only-down, is a flag indicating if only downward movements are allowed."  (and (= n1 n3)      (if only-down       (or (= (- n1 n2) 1) (= (- n1 n2) 2))       (or (= (abs (- n1 n2)) 1) (= (abs (- n1 n2)) 2)))))(defun parallel-movements? (&rest sop-bass-ints)"returns true if sop-bass intervals move in parallel"  (let ((flags nil) sop-int bass-int)    (while sop-bass-ints      (setq sop-int (first (car sop-bass-ints)))      (setq bass-int (second (pop sop-bass-ints)))      (push (or (and (plusp sop-int) (plusp bass-int))                (and (minusp sop-int) (minusp bass-int)))         flags))      (every #'identity flags))) ; the list of flags should contain only t's;(parallel-movements? '(2 4) '(4 5) '(7 8));(parallel-movements? '(-2 -4) '(4 5))#|(mapcar #'(lambda (n) (read-from-string (first n))) (ccl::list-definitions (front-window)))))|#;=================================================================#|(defun no-chord-duplicates (?1 rl)    (not     (find (sort (l->ms (read-key (hslice ?1) :s-variables)) #'<)           (rest rl)           :key #'(lambda (s-v) (sort (l->ms (read-key (hslice s-v) :s-variables)) #'<))           :test #'equal)))|#(defun  no-pc-duplic-in-prev-slices (?1 pc sl-count)"checks that PC is not found among sl-count previous harmonic-slices"   (not (member pc           (remove nil                   (remove ?1                     (pw::flat (cons (hc ?1)                                     (mapcar #'(lambda (hs) (read-key hs :s-variables))                                             (n-prev-items (hslice ?1) sl-count))))))          :key #'(lambda (i) (mod (m i) 12)))))(defun no-chord-duplicates (?1 rl &optional (ch-key #'identity))  (no-chord-duplicates? ?1 rl ch-key))(defun no-chord-duplicates? (?1 rl &optional (ch-key #'identity))"checks that rl does not contain chord-duplicates with ?1"    (not     (find (funcall ch-key (sort (l->ms (read-key (hslice ?1) :s-variables)) #'<))           (rest rl)           :key #'(lambda (s-v)                     (funcall ch-key (sort (l->ms (read-key (hslice s-v) :s-variables)) #'<)))           :test #'equal)))(defun vertical-interval-range  (s-var minv maxv)  (vertical-interval-range?  s-var minv maxv))(defun vertical-interval-range?  (s-var minv maxv)"s-var and the s-variable belonging to the part below s-var's partshould have pitches within the range given by minv and maxv"  (let ((partnum (partnum s-var)))     (<= minv (- (m s-var)                 (m (find (1+ partnum) (hc s-var) :key #'(lambda (n) (partnum n)))))         maxv)     ))(defun vertical-intervals  (s-var intervals)  (vertical-intervals? s-var intervals))(defun vertical-intervals?  (s-var intervals)"s-var and the s-variable belonging to the part below s-var's partshould have pitches that form vertical intervals that belong to intervals"   (let ((partnum (partnum s-var)))     (member (- (m s-var)                (m (find (1+ partnum) (hc s-var) :key #'(lambda (n) (partnum n)))))             intervals)));??(defun map-rtm-change (rtm-l cur-ind)   (setq cur-ind (1- cur-ind))   (let ((acc 0))      (while (and rtm-l (< acc cur-ind))        (incf acc (pop rtm-l)))     (if (= acc cur-ind)         t         nil))) #|(map-rtm-change '(6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4   3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3 6 4 3)1)|#;==================================================================(defun search-n-mel-moves (n ?1)"returns n (?1 included) previous melodic pitches disregarding repetitions" (let ((res (list (m ?1)))       (curr-s-v ?1))   (while (and curr-s-v (< (length res) n))     (setq curr-s-v (prev-item curr-s-v))     (when (and curr-s-v (/=  (m curr-s-v) (car res)))        (push (m curr-s-v) res)))   res))(defun octaves? (midis)"returns true if midis contains octaves, unisons are not considered"  (let (fl ref)    (while (and (not fl) (cdr midis))      (setq ref (pop midis))      (dolist (n midis)          (when (and (/= n ref)                      (= (mod ref 12) (mod n 12)))             (setq fl t)             (return))))    fl))  ;(octaves? '(60 65 67 60 73)) ;(octaves? '(60 65 67 72 73)) ;;?? not used ??(defun two-staffs-ambitus (s-var partnums minvalue maxvalue)  (if (not (member (partnum s-var) partnums))    t    (let ((hc-compl (cons s-var (hc s-var))))      (if (= (length (intersection partnums (mapcar #'(lambda (sv) (partnum sv)) hc-compl)))             (length partnums))         (let (sorted-s-var-list)           (setq sorted-s-var-list                 (sort (collect-by-partnum partnums hc-compl) #'<                       :key #'(lambda (sv) (partnum sv))));; from bass to sop          ;(print (mapcar #'(lambda (sv) (partnum sv)) sorted-s-var-list))           (<=  minvalue (apply #'- (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)) maxvalue))        t))))(defun no-voice-octaves? (s-var)"the harmonic-context (s-var included) of s-var should not contain octaves (unisons allowed)"  (let ((hc (hc s-var)))     (if hc      (not (octaves? (mapcar #'(lambda (val) (m val)) (cons s-var (hc s-var)))))      t))) ;;; no octaves in vertical chords - unisons are allowed;;; ??? only two parts, sort,  zero-flag allows unisons ???(defun two-staffs-ambitus (s-var partnums  minvalue maxvalue &optional zero-flag)  (if (not (member (partnum s-var) partnums))    t    (let ((hc-compl (cons s-var (hc s-var))))      (if (= (length (intersection partnums (mapcar #'(lambda (sv) (partnum sv)) hc-compl)))             (length partnums)) ;; all partnums available          (let (sorted-s-var-list)           (setq sorted-s-var-list                 (sort (collect-by-partnum partnums hc-compl) #'<                       :key #'(lambda (sv) (partnum sv))));; from bass to sop          ;(print (mapcar #'(lambda (sv) (partnum sv)) sorted-s-var-list))          (if zero-flag            (or (zerop (apply #'- (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)))                (<=  minvalue (apply #'- (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)) maxvalue))            (<=  minvalue (apply #'- (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)) maxvalue)))        t))))(defun two-staffs-ints (s-var partnums  accepted-ints)  (if (not (member (partnum s-var) partnums))    t    (let ((hc-compl (cons s-var (hc s-var))))      (if (= (length (intersection partnums (mapcar #'(lambda (sv) (partnum sv)) hc-compl)))             (length partnums))         (let (sorted-s-var-list)           (setq sorted-s-var-list                 (sort (collect-by-partnum partnums hc-compl) #'<                       :key #'(lambda (sv) (partnum sv))));; from bass to sop          ;(print (mapcar #'(lambda (sv) (partnum sv)) sorted-s-var-list))          (member (apply #'- (mapcar #'(lambda (sv) (m sv)) sorted-s-var-list)) accepted-ints :test #'equal))        t))));========================================================================================;general utilities accessing data from the current s-engine and part-collection  ;========================================================================================(defun harm-slice-scs ()  (mapcar #'sc-name          (mapcar #'(lambda (hs)                       (mapcar #'(lambda (s-v) (m s-v))                              (read-key hs :s-variables)))                  (read-key *part-collection* :harmonic-slices))))(defun harm-slice-midis ()  (mapcar #'(lambda (hs)                       (mapcar #'(lambda (s-v) (m s-v))                              (read-key hs :s-variables)))                  (read-key *part-collection* :harmonic-slices)))(defun harm-slice-durs ()  (mapcar #'durt (read-key *part-collection* :harmonic-slices)))(defun get-aons ()  (mapcar #'PWCS::startt (read-key *part-collection* :harmonic-slices)))(defun get-roffs ()  (mapcar #'-          (mapcar #'endt (read-key *part-collection* :harmonic-slices))          (mapcar #'PWCS::startt (read-key *part-collection* :harmonic-slices)))) (defun staff-durs ()  (mapcar #'(lambda (l)              (mapcar #'durt l))           (read-key *part-collection* :part-s-variables-ls-ls)));;; check sindex-counts(defun sindex-counts ()  (mapcar #'length (read-key pwcs::*part-collection* :part-s-variables-ls-ls)));==========================================================================================; for debugging purposes and misc and manipulation of the score during search;==========================================================================================(defun update-score ()  "Shows the partial solution of the current score until the current search-variable. After the current search-variable, middle C (6000) is set as a default pitch unlessit is not constrained by the user"  (dolist (var (read-key pwcs::*part-collection* :sorted-s-variables))    (let ((note (read-key var :PW-note)))      (when  note        (if (m var)          (setf (pw::midic note) (* 100 (m  var)))          (unless (constraint? var)             (setf (pw::midic note) (* 100 60))))        (pw::update-note note)        (pw::update-chord (read-key var :PW-chord)))))  (when (and pw::*current-score-PMC-RTM-window*             (wptr pw::*current-score-PMC-RTM-window*))    (pw::erase+view-draw-contents pw::*current-score-PMC-RTM-window*)));(update-score) (defun scramble-domains ()  "allows the user to reorder randomly the domains during search"  (when (engine)    (terpri)    (print "Scambling the score !")    (terpri)    (with-cursor *watch-cursor*      (dolist (var (read-key pwcs::*part-collection* :sorted-s-variables))        (setf (domain var) (pw::permut-random (domain var) )))      ;(backtrack (engine))      )));; works only from a text-editor?(defun continue-search ()  (eval-enqueue (forward (engine))))(defun jumpback-in-score () "First abort the search, then evaluate jumpback-in-score box, that opens a dialog asking for the note-index where the user wants to jump back to. After thisjumpback-in-score scrambles the domains, jumps back to a given s-variableand continues the search. This box can be useful in a situation where the search is stucked to a given place in the score. The user can jump back directly to any previous note in the score andtry again with the domains in different order."  (when (engine)    (scramble-domains)    (let ((num (get-string-from-user  "give note-index"                                       :initial-string                                       (format () "~A" (variable-pos (engine) )))))      (when num         (setq num (read-from-string num))        (when (and (integerp num)                    (<= 0 num (1- (length (search-variables (engine))))))          (pwcs::jumpback (engine) (nth num (pwcs::search-variables-list (engine))))          ;(abort)          (forward (engine))          )))));(jumpback-in-score)