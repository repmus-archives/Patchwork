;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Mikhail Malt   &   Jacopo Baboni Schilingi;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Profile;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22-5-1995;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defpackage "PROFILE")(in-package "PROFILE");;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp notes-change  ((pits midic) (scale midic) &optional (mod fix>=0 (:value 12))) list            "<Notes-Change> permet l'ajustement d'une hauteur ou d'une listede hauteurs <pits> à un champs harmonique défini par une autre listede hauteurs <scale>.Ce module possède une troisième entrée, optionnelle, <mod> pourindiquer le modulo du champs harmonique utilisé"  (let* ((pits (pw::list! pits))         (scale (pw::list! scale))         (modsca (pw::g-floor (pw::sort-list (pw::rem-dups (pw::g-mod (pw::g/ scale (/ 100 (/ mod 12))) mod)))))         (pitmods (pw::g-mod (pw::g/ pits (/ 100 (/ mod 12))) mod))         (octa (octave pits))         (posdifs (mapcar #'(lambda (p) (position (pw::g-min (pw::g-abs (pw::g- modsca p)))                                                  (pw::g-abs (pw::g- modsca p))))                          pitmods)))    (mapcar #'(lambda (index octave) (makenote  index octave mod))            (pw::posn-match modsca posdifs)            octa)));;;--------------------------------------;;(pw::defunp octave ((midic midic)) numbers?            "retourne l'octave à partir de c3=octave 3"  (let ((midic (pw::list! midic)))    (mapcar #'(lambda (x) (pw::g- (pw::g-div x 1200) 2) ) midic)));;;--------------------------------------;;(pw::defunp makenote ((index fix>=0) (octave fix/float)                       &optional (mod fix>=0 (:value 12))) numbers?            " construction d'une note à partir des données              de index, octave e modulo du index"  (+ (/ (* index 100 12) mod) (* (+ 2 octave) 1200)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Compressione ed espansione del profilo;;;;;;;;;;;;;;;;;;;;;(pw::defunp compr/expan ((list list)                          (value fix/float (:value 1))                         &optional (note? list (:value '()))) list             "Ce module opère une transformation de compression ou d'expansionsur les intervalles de la liste de hauteurs <list> en les multipliantpar la valeur de l'entrée <value>. <list> est une liste simple, à un niveau, de hauteurs en midicents<value> est facteur multiplicateur, il peut être un  entier ou flottant.<note?> entrée optionnelle qui permet l'ajustement de la forme générée       à un champs harmonique quelconque.       <note?> peut être soit une échelle soit un accord.Si <value> est égal à '1' les intervalles de <liste> seront maintenus les mêmes.Si <value> est plus petit que '1' les intervalles de <liste> seront compressés.Si <value> est plus grand que '1' les intervalles de <liste> seront élargis.Des valeurs négatives de <value>  occasionnent des renversement d'intervalles."  (let* ((calcolo (pw::dx->x                    (first list)                    (mapcar #'(lambda (x) (* x value)) (pw::x->dx list))))         (corretto (when note?                     (notes-change calcolo note? 48))))    (if note? corretto calcolo)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interferenza di una lista;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp alea-pertb ((list list) (range fix>=0)) list           "Applique une perturbation aléatoire sur une listede hauteurs <list>. La perturbation est faite en valeurs absolues,c'est-à-dire, chaque hauteur est modifiée par l'addition d'une valeur aléatoire prise entre -range e +range.<list> est une liste simple, à un niveau, de hauteurs en midicents<range> est le registre de la variation.          Si range est un nombre entier la variation se fera          par l'addition ou la soustraction de valeurs entières.         Si range est un nombre flottant la variation se fera          par l'addition ou la soustraction de valeurs flottantes"  (mapcar #' (lambda (x) (+ x (pw::g-random (- range) range))) list));;;--------------------------------------;;(pw::defunp control-pertb ((list list)                            (index list)                           &optional (fact fix/float)                           ) list            "Ce module permet d'appliquer une perturbation contrôlée sur certaines hauteurs de la liste  <list> en leurs ajoutant la valeur 'fact*index'.<list> est une liste simple, à un niveau, de hauteurs en midicents.<fact> est soit une liste d'index soit un module <multi-bpf>.La liste <fact> indique quels seront les éléments 'perturbés'. Par exemple soit la liste <list> ->>(6000 6600 6800 6700 6200 6300 5900), la liste de <fact> ->>(0 100 -200 0 0 500 -300)et <fact> égal à '1'la liste résultante sera->>(6000* 6700 6600 6700* 6200* 6800 5600)*éléments inchangésUn zéro '0' dans la liste <fact> indique que l'élément correspondantde la liste <list> sera inchangé.Dans certains cas l'entrée <fact> peut être utilisé.Exemple, soit la même liste <list> ->>(6000 6600 6800 6700 6200 6300 5900),et la liste de <index> ->>(0 25 -50 0 0 5 -75)en fonction de la valeur de <fact> il est possiblede contrôler plus finement la perturbation appliquée.si <fact> égal 25 le résultat  sera->>(6000 6625 6750 6700 6200 6425 5825)si <fact> égal 25 le résultat  sera->>(6000 6650 6700 6700 6200 6550 5750)L'entrée <index> accepte aussi un module <multi-bpf>.Dans ce cas précis, le module <control-pertb> opère un échantillonnage (avec le même nombre de pas que la longueur de <list>)de la fonction par segments et considère les valeurs obtenues comme étantune liste <index>."  (let* ((xpoints (unless (listp index) (pw::x-points index)))         (index (pw::g*  fact (if (listp index) index                    (pw::bpf-sample index (length list)                                   (pw::g-min xpoints)                                   (pw::g-max xpoints)                                   1                                   2))))         (calcolo-bpf (pw::g+ list                              (pw::g-round                               (pw::g- 1 index) 0)))         (calcolo-numeri (pw::g+ list                                 (pw::g-round                                  index 0))))    (if (listp index)      calcolo-numeri calcolo-bpf)));;;--------------------------------------;;(defun pr (lista1 lista2)  "Se lista1 è più corta di lista2 allora lista1 viene riletta per il numero di volte   identico a lista 2."  (let ((ros nil))    (dotimes (y (length lista2) (nreverse ros))      (push        (if (< (length lista1) (length lista2))         (nth           (mod y (length lista1))          lista1)         (nth y lista1)) ros))));;;;;;;;;;;;;;;;;;;;;;Profilo-melodico con stessi intervalli;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun prx (lista1 lista2)  "Crea la lettura modulare di lista1 in funzione della lunghezza di lista2.   Se lista1 è più corta di lista2 allora lista1 viene riletta per il numero di volte   identico a lista 2. Ma viene riletto il pw::x->dx di lista1 in funzione del   pw::x->dx di lista2."   (let ((ros nil))      (dotimes (y (length (pw::x->dx lista2)) (nreverse ros))         (push        (if (< (length (pw::x->dx lista1)) (length (pw::x->dx lista2)))         (nth           (mod y (length (pw::x->dx lista1)))          (pw::x->dx lista1))         (nth y lista1)) ros))));;;--------------------------------------;;(defun dillox (lista1 lista2)  "Questa funzione cambia gli intervalli di lista2 in funzione degli intervalli di lista1.   Se un intervallo di lista1 è discendente e quello corrispondente di lista2 è ascendente,    allora l'intervallo di lista2 viene cambiato e reso ascendente."    (let ((ris nil)        (test1 (prx2 lista1 lista2))        (test2 (pw::x->dx lista2)))    (dotimes (x (- (length lista2) 1) (nreverse ris))      (push        (if (> (nth x test1) 0)         (abs (nth x test2))         (- (abs (nth x test2)))) ris))));;;--------------------------------------;;(pw::defunp cambia-prof-mel ((lista1 list) (lista2 list)) list                        "Modifica il profilo melodico di lista2 in funzione del profilo melodico             di mista1. Il 'length' del risultato è sempre uguale al 'length' di              lista2. Se lista2 è più corta di lista1 allora il processo si attua per              la lunghezza di lista2. Ma se lista1 è più corta di lista2, allora              lista2 torna a rileggere i valori di lista1 ogni volta che lista1 finisce."    (pw::dx->x (first lista2) (dillox lista1 lista2)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Profilo-melodico con stesse note;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun prx2 (lista1 lista2)    "Crea la lettura modulare di lista1 in funzione della lunghezza di lista2.   Se lista1 è più corta di lista2 allora lista1 viene riletta per il numero di volte   identico a lista 2. Ma viene riletto il pw::x->dx di lista1 in funzione del   pw::x->dx di lista2."    (let ((ros nil))        (dotimes (y (length (pw::x->dx lista2)) (nreverse ros))         (push        (if (< (length (pw::x->dx lista1)) (length (pw::x->dx lista2)))         (nth           (mod y (length (pw::x->dx lista1)))          (pw::x->dx  lista1))         (nth y (pw::x->dx  lista1))) ros))));;;--------------------------------------;;(defun int-com (lista)    "Restituisce l'intervallo complementare di un intervallo dato in funzione della   prima nota dell'intervallo stesso. Questo significa che se ho SOL3 DO4, la    funzione restituisce do4 sol4."    (let ((ris nil))        (pw::flat     (dotimes (x (- (length lista) 1) (nreverse ris))       (push         (pw::x->dx (append                    (list (nth x lista))                    (list (-  (- (nth x lista)                                 (*  (- 12 (mod                                             (/ (- (first (pw::x->dx lista))                                                   (*                                                    (first                                                     (pw::g-div (pw::x->dx lista) 1200)) 1200)) 100) 12)) 100))                              (* (first (pw::g-div (pw::x->dx lista) 1200)) 1200)))))        ris)))));;;--------------------------------------;;(defun prof (lista1 lista2)  "restituisce l'intervallo complentare tenendo le altezze assolute."    (let ((ris nil))        (pw::flat      (dotimes (x (length (prx2 lista1 lista2)) (nreverse ris))       (push (if (equalp (signum (nth x (prx2 lista1 lista2)))                         (signum (nth x (pw::x->dx lista2))))               (nth x (pw::x->dx lista2))               (int-com (list                         (nth x lista2)                         (nth (1+ x) lista2))))             ris)))));;;--------------------------------------;;(pw::defunp prof-fix-note ((lista1 list) (lista2 list)) list                        "Modifica il profilo melodico di lista2 in funzione del profilo melodico             di mista1. Il 'length' del risultato è sempre uguale al 'length' di              lista2. Se lista2 è più corta di lista1 allora il processo si attua per              la lunghezza di lista2. Ma se lista1 è più corta di lista2, allora              lista2 torna a rileggere i valori di lista1 ogni volta che lista1 finisce."   (pw::dx->x (first lista2) (prof lista1 lista2)));;;--------------------------------------;;(pw::defunp prof-change ((prof list)                          (pitch list)                         (mode? menu                                 (:menu-box-list (("intrv" . 1) ("note". 2))))) list            "Ce module transforme le profil mélodique des hauteurs d'une listede hauteurs <pitch> par le profil d'une deuxième liste de hauteurs <prof>.<prof> est une liste simple, à un niveau, de hauteurs en midicents, qui       définie un profil mélodique.<pitch> est une liste simple, à un niveau, de hauteurs en midicents, qui       définie soit un  réservoir de hauteurs, soit un  réservoir d'intervalles.<mode?> est un menu déroulant qui permet de choisir le mode d'action du module.        Si <mode?> est égal à 'note' la liste  <pitch> sera utilisée comme        un réservoir  de hauteurs.        Si <mode?> est égal à 'intrv' la liste  <pitch> sera utilisée comme        un réservoir  d'intervalles.Pratiquement la structure générée est constituée par les directions de <prof>et les  hauteurs ou les intervalles de <pitch> en fonction de <mode?>."  (funcall (case mode?             (1 'cambia-prof-mel)             (2 'prof-fix-note))           prof pitch));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Modulo;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp malt-mod+ ((list list) (limit midics?)) list            ""  (let ((ris nil)        (limite (first (pw::list! limit))))        (dolist (y list (nreverse ris))      (push (if (< y limite)              (- (* 2 limite) y) y) ris))));;;--------------------------------------;;(pw::defunp malt-mod- ((list list) (limit midics?)) list            ""  (let ((ris nil)        (limite (first (pw::list! limit))))        (dolist (y list (nreverse ris))      (push (if (> y limite)              (- (* 2 limite) y) y) ris))));;;--------------------------------------;;(pw::defunp reflex-int ((ls list) (value fix/float)                         (up/down menu                                 (:menu-box-list (("up" . 1)                                                  ("down" . 2))))) list                        "Restituisce la rifleesione delle note che sono superiori o inferiori             al valore indicato con 'value'. Il menù permette di selezionare se si             vuole una riflessione superiore o inferiore"  (case up/down    (1 (malt-mod+ ls value))    (2 (malt-mod- ls value))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Modulo con altezze fisse;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun mod-fix- (ls asse)  ""  (let ((ris nil)        (asse (pw::list! asse)))    (dotimes (x (length ls) (nreverse ris))      (push       (if (<= (nth x ls) (first asse)) (nth x ls)           (+ (first asse) (first (int-com (list                                            (first asse)                                            (nth x ls))))))        ris))));;;--------------------------------------;;(defun mod-fix+ (ls asse)  ""  (let ((ris nil)        (asse (pw::list! asse)))    (dotimes (x (length ls) (nreverse ris))      (push       (if (>= (nth x ls) (first asse)) (nth x ls)           (+ (first asse) (first (int-com (list                                            (first asse)                                            (nth x ls)))))) ris))));;;--------------------------------------;;(pw::defunp reflex-note ((ls list)                          (value fix/float)                         (up/down menu                             (:menu-box-list (("up" . 1)                                              ("down" . 2))))) list                        "Restituisce per la riflessione superiore con <UP> e quella             inferiore con <DOWN>."  (case up/down    (1 (mod-fix+ ls value))    (2 (mod-fix- ls value))));;;--------------------------------------;;(pw::defunp doppio-reflex-note ((list list)                                (value list)) list                        "Restituisce due volte <REFLEX-NOTE> la prima volta a <LIST>             la seconda volta al risultato della prima volta."    (reflex-note (reflex-note list (pw::g-min value) 1)                (pw::g-max value) 2));;;--------------------------------------;;(pw::defunp doppio-reflex-int ((list list)                               (value list)) list                        "Restituisce due volte <REFLEX-INT> la prima volta a <LIST>             la seconda volta al risultato della prima volta."      (reflex-int (reflex-int list (pw::g-min value) 1)              (pw::g-max value) 2));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Filtra banda;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun int (elt coppia)  (if (< (first coppia) elt (second coppia)) elt nil));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Filtro passa banda;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp pass-band ((lista list) (alt list)) list            "Restituisce i valori inclusi in ALT."  (let ((ris nil))    (dolist (x lista (nreverse ris))      (if (equalp (int x alt) nil) (int x alt) (push x ris)))));;;--------------------------------------;;(pw::defunp correttore-doppio-reflex-note ((list list)                                           (value list)                                           (inclu? menu                                                    (:menu-box-list (("yes" . 1)                                                                     ("no!" . 2))))) list                        "Corregge il risultato di 'DOPPIO-REFLEX-NOTE' in modo che se la              riflessione supera i limiti con <YES> abbiamo una trasposizione             oltre i limiti stessi ma con TRANS-APPROX altrimenti le note              che non sono incluse nei limiti vengono escluse dalla funzione             COMP-OCTAVE."  (let ((risultato (doppio-reflex-note list value )))          (case inclu?        (1 (trans-approx risultato value))        (2 (comp-octave risultato value)))))  ;;;--------------------------------------;;(pw::defunp correttore-doppio-reflex-int ((list list)                                          (value list)) list                        "Corregge il risultato di 'DOPPIO-REFLEX-INT' in modo che              se il risultato di 'DOPPIO-REFLEX-INT supera i limiti dati             ripete l'operazione di adattamento fino a che non soddisfa              i limiti di esistenza."    (let ((risultato (doppio-reflex-int list value))        (ris nil))            (dolist (y risultato (pw::flat (nreverse ris)))      (push (if (int y value) y                (correttore-doppio-reflex-int (pw::list! (1+ y)) value)) ris))));;;--------------------------------------;;(pw::defunp reflexion ((list list)                         (axis midics?)                        (mode? menu                               (:menu-box-list (("intrv" . 1)                                                ("note" . 2))))                        (up/down menu                                 (:menu-box-list (("up" . 1)                                                  ("down" . 2))))) list                        "opération de symétrie au tour d'un axe <axis>.Cette opération considère l'ensemble de hauteurs définies par <list> comme étantun profil géométrique.Exemple:----------------------------*--------------------*---*------------*---*------*--------*--------------*-----*------<<<<<<<<<<<<<axis>>>>>>>>>>>>>>>>>>>>>>>-----------*---*--------------------*--------------------------------------------------------Il est possible alors de réfléchir une partie des hauteurs de <list>soit vers le haut:-----------------------------*---------------------*---*----*-------*----*------*-*---*---*--------------*-----*------<<<<<<<<<<<<<axis>>>>>>>>>>>>>>>>>>>>>>>-----------0---0---------------------0-----------------------------------------------------------soit vers le bas:-----------------------------0---------------------0---0----0-------0----0------0-0---0---0--------------*-----*------<<<<<<<<<<<<<axis>>>>>>>>>>>>>>>>>>>>>>>--*------*-*---*---*--------*---*----*-------*--------*------------------------------------------<list>     est une liste simple, à un niveau, de hauteurs en midicents.<axis>     valeur en midicents déterminant l'axe au tour duquel s'opère la symétrie.<mode?>    est un menu déroulant qui permet de choisir le mode d'action du module.           Si <mode?> est égal à 'note' la liste  <list> sera utilisée comme           un réservoir  de hauteurs, c'est-à-dire que la réflexion au tour de           <axis> respectera les valeurs des notes de <list>.           Si <mode?> est égal à 'intrv' la liste  <list> sera utilisée comme           un réservoir  d'intervalles, c'est-à-dire que la réflexion au tour de           <axis> respectera les valeurs des intervalles de <list>.<up/down>  est un menu déroulant qui permet de choisir la direction de la réflexion.           Si <up/down> est égal à 'up' la réflexion au tour de           <axis>  se fera vers le haut.           Si <up/down> est égal à 'down' la réflexion au tour de           <axis>  se fera vers le bas."    (funcall (case mode?             (1 'reflex-int)             (2 'reflex-note))           list axis up/down))                     ;;;--------------------------------------;;(pw::defunp double-reflect ((list list)                             (limits list)                            (mode? menu                                   (:menu-box-list (("intrv" . 1)                                                    ("note" . 2))))                            (inclu? menu                                    (:menu-box-list (("yes" . 1)                                                     ("no!" . 2))))) list                        "opération de symétrie en relation à deux bornes. Cette opération considère l'ensemble de hauteurs définies par <list> comme étantun profil géométrique.Exemple:*--------------------------*-------------*------------*-----------*-*------------*---------*---*------------*-------*-----*------------*-----*-------*------------*---*---------*------------*-*-----------*------------*-------------*---Il est possible alors de réfléchir une partie des hauteurs de <list>en relation à deux bornes0--------------------------0-------------0------------0-----------0-0------------*---------*---*--------<-<-<-<borne inférieure--*-*---*---*-*-*-*--------*---*-*-*-*---*---*------*-----*---*---------*-----<-<-<-<borne supérieure-------0-0-----------0------------0-------------0---<list>     est une liste simple, à un niveau, de hauteurs en midicents.<limits>   est une liste de deux valeurs en midicents déterminant les bornes            inférieur et supérieur  au tour desquels s'opère la symétrie.<mode?>    est un menu déroulant qui permet de choisir le mode d'action du module.           Si <mode?> est égal à 'note' la liste  <list> sera utilisée comme           un réservoir  de hauteurs, c'est-à-dire que la réflexion au tour de           <axis> respectera les valeurs des notes de <list>.           Si <mode?> est égal à 'intrv' la liste  <list> sera utilisée comme           un réservoir  d'intervalles, c'est-à-dire que la réflexion au tour de           <axis> respectera les valeurs des intervalles de <list>.<inclu?>   est un menu déroulant qui permet de choisir l'inclusion ou non           des notes qui ne seraient pas incluses dans l'intervalle délimité par <limits>           Si <inclu?> est égal à 'yes' les notes non incluses dans            l'intervalle délimité par <limits> sont ajoutées à la borne la plus proche..           Si <inclu?> est égal à 'no' les notes non incluses dans            l'intervalle délimité par <limits> sont exclues."    (case mode?    (1 (correttore-doppio-reflex-int list limits))    (2 (correttore-doppio-reflex-note list limits inclu?))));;;--------------------------------------;;(defun interno (elmt range)          "Restituisce l'elemento se è incluso nel 'range' e nil            se non è incluso."  (if (<= (pw::g-min range) elmt (pw::g-max range)) elmt nil));;;--------------------------------------;;(pw::defunp comp-octave ((list list) (range list)) list            "Restituisce una trasposizione della lista mantenendo le altezze             assolute all'interno del 'range. Se un elemento non è incluso              nel 'range', allora viene tolto dal risultato."  (let ((ris nil))    (dolist (y (mio-transpoct list range) (nreverse ris))      (if (equalp (interno y range) nil) (interno y range) (push y ris)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Riflessione che riparte dal limite;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Filtro passa alto;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp pass-alto ((lista list) (alt fix)) list            "Restituisce tutti i valori superiori al vaore segnato in ALT."  (let ((ris nil))    (dolist (x lista (nreverse ris))      (when (> x alt) (push x ris)))));;;--------------------------------------;;(pw::defunp  pass-basso ((lista list) (alt fix)) list            "Restituisce tutti i valori inferiori al valore segnato in ALT."  (let ((ris nil))    (dolist (x lista (nreverse ris))      (when (< x alt) (push x ris)))));;;--------------------------------------;;(pw::defunp quarta-reflexio ((list list) (limit list)) list                        "Se un elemento di <LIST> è superiore al limite superiore allora viene trasposto              al di sotto di tale limite della differenza tra l'elemento stesso ed il limite              (if (> y maxim) (+ minim  (- y maxim))).              Se un elemento di <LIST> è inferiore al limite inferiore allora viene trasposto              al di sopra di tale limite della differenza tra il limite e l'elemento stesso              (if (< y minim) (- maxim  (-  minim y)))."      (let ((ris nil)        (minim (pw::g-min limit))        (maxim (pw::g-max limit)))        (dolist (y list (pw::flat (nreverse ris)))      (push (cond             ((> y maxim) (+ minim  (- y maxim)))             ((< y minim) (- maxim  (-  minim y)))             (t y))            ris))));;;--------------------------------------;;(pw::defunp quasi-multi-reflexions ((list list)                                     (limit list)                                    ) list                        "Se un elemento di <LIST> è superiore al limite superiore allora viene trasposto              al di sotto di tale limite della differenza tra l'elemento stesso ed il limite              (if (> y maxim) (+ minim  (- y maxim))).              Se un elemento di <LIST> è inferiore al limite inferiore allora viene trasposto              al di sopra di tale limite della differenza tra il limite e l'elemento stesso              (if (< y minim) (- maxim  (-  minim y))).             Se la soluzione non soddisfa i limiti di esistenza dei limiti stessi, il risultato             viene trattato ricorsivamente fino a soddisfare i due limiti."      (let ((ris nil)        (calcolo (quarta-reflexio list limit)))        (dolist (y calcolo (pw::flat (nreverse ris)))      (push (if (int y limit)               y              (quasi-multi-reflexions (pw::list! (1+ y)) limit)) ris))));;;--------------------------------------;;(pw::defunp multi-reflect ((list list)                            (limits list)                           &optional (note? list (:value '()))) list                        "Opération de symétrie en relation à deux bornes. Cette opération considère l'ensemble de hauteurs définies par <list> comme étantun profil géométrique.Exemple:*--------------------------*-------------*------------*-----------*-*------------*---------*---*------------*-------*-----*------------*-----*-------*------------*---*---------*------------*-*-----------*------------*-------------*---Il est possible alors de réfléchir une partie des hauteurs de <list>en relation à deux bornes0--------------------------0-------------0------------0-----------0-0------------*---*-*---*---*--------<-<-<-<borne inférieure*---*---*---*-----*--------*---*-----*---*---*--------*---*---*---*-*---*-----<-<-<-<borne supérieure-------0-0-----------0------------0-------------0---La différence entre ce module <multi-reflect> et <double-reflect>est que ce module garde les directions au moment de la réflexion.<list>     est une liste simple, à un niveau, de hauteurs en midicents.<limits>   est une liste de deux valeurs en midicents déterminant les bornes            inférieur et supérieur  au tour desquels s'opère la symétrie.<note?>    entrée optionnelle qui permet l'ajustement de la forme générée           à un champs harmonique quelconque.           <note?> peut être soit une échelle soit un accord."    (let* ((calcolone (quasi-multi-reflexions list limits))         (con-note (when note?                     (notes-change calcolone note? 48))))        (if note? con-note calcolone)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Media fissa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun primo-passo (lista n)   (let (f)                             ;prende n elementi della lista    (dotimes (x n)                     ;di partenza      (push (nth x lista) f))    (nreverse f)));;;;--------------------------------------;;;;(defun primo-passo (lista n) ;  (let ((n (when (> n (length lista)) (length lista))));    (subseq lista 0 n)));;--------------------------------------;;(pw::defunp scomp ((list1 list) (list2 list)) list            "Restituisce la nostra lista1 di partenza suddivisa nei segmenti             da noi scelti tramite lista2."     (let (ris)                                          ;Prende ogni elemento di lista2 e lo    (dotimes (x (length list2) (nreverse ris))        ;usa per estrarre i valori da lista1.      (push (primo-passo                              ;Per fare in modo che (nth x lista2)             (nthcdr                                  ;non prenda il successivo di lista1              (let (ros)                              ;uso (nthcdr) la cui y è data da                (dotimes (y (length ris))             ;(apply '+ ros) cioè dalla somma                  (push (nth y list2) ros))           ;delle y precedenti.                (apply '+ ros))                       ;              list1)                                  ;             (nth x list2))                           ;            ris))))              ;;;--------------------------------------;;(defun med-fix (lista)            "Restitusce la derivata data dalla media tra una nota e la successiva."  (let ((ris nil))    (dotimes (x (- (length lista) 1) (nreverse ris))      (push (/ (+ (nth x lista) (nth (1+ x) lista))                2) ris))));;;--------------------------------------;;(pw::defunp mean-derivation ((list list)                              (gr° fix>0)                             &optional (note? list (:value '()))) list                       "Opération de simplification de profils mélodiques.Ce module génère un profil mélodique résultant d'un processusde calcul de moyenne entre des notes consécutives de <list>.Exemple:soit <list> = (6000 5700 5100 5200 4900 5800 6400 7200 7800 7500 6600 6800)et <gr°> = 1Le résultat sera:(5850 5400 5150 5050 5350 6100 6800 7500 7650 7050 6700)où5850 est la moyenne entre 6000 et 5700,5400 est la moyenne entre 5700 et 5100,et ainsi de suite.et  que le nombre d'éléments est réduit de unSi nous gardons la même <list> et nous faisons <gr°> = 2,le résultat sera:(5625 5275 5100 5200 5725 6450 7150 7575 7350 6875)où5625 est la moyenne entre 5850 et 5400, 5275 est la moyenne entre 5400 et 5150,  et ainsi de suite.(se rappeler que (5850 5400 5150...)sont les résultats du processus avec  <gr°> = 1)Nous pouvons calculer ce processus avec plusieurs degrés de profondeur,mais en se souvenant que  à chaque fois la liste résultante sera réduite d'un élémentIl est possible aussi d'utiliser l'entrée optionnelle <note?>pour ajuster la forme générée à un champs harmonique particulier.<list>     est une liste simple de hauteurs en midicents.<gr°>      est le niveau de profondeur du processus.<note?>    entrée optionnelle qui permet l'ajustement de la forme générée           à un champs harmonique quelconque.           <note?> peut être soit une échelle soit un accord."    (let* ((calcolo (if (= 1 gr°) (med-fix list)                     (mean-derivation (med-fix list) (- gr° 1)  note?)))         (con-note (when note?                     (notes-change calcolo note? 48))))        (if note? con-note calcolo)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Derivate;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Derivata fissa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Baricentro;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp baricentro ((valori list)) fix            "Calcola il baricentro di una sequenza di valori: il valore medio."     (pw::g-average valori 1.0));;;--------------------------------------;;(pw::defunp deriv ((list list) (start midics?)) list            "Calcola la differenza (delta y) tra una altezza e la precedente e             se si considera (= (delta x) 1) allora il risultato è la 'derivazione             della lista <LIST>."  (pw::g+ (first (pw::list! start)) (pw::x->dx list)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Derivate successive;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp quasi-der-suc ((list list)                           (start menu (:menu-box-list (("first" . 1)                                                        ("orig" . 2))))                           (note? midics?)                           (gr° fix>0)) list                        "Calcola la differenza (delta y) tra una altezza e la precedente e             se si considera (= (delta x) 1) allora il risultato è la 'derivazione             della lista <LIST>. Con <gr°> possiamo decidere di sapere quante volte             vogliamo applicare la stessa operazione a <LIST>, in altre parole             decidiamo il grado della derivazione da fare a <LIST>."    (let ((partenza (case start                    (1 (first list))                    (2 note?))))    (if (= gr° 1)       (deriv list partenza)      (quasi-der-suc (deriv list partenza)                     start note?                     (- gr° 1)))));;;--------------------------------------;;(pw::defunp prime-note ((list list)                        (gr° fix>0)) list                        "Prende la prima nota di ogni derivata e ne fa una lista.             Se <GR°> è uguale a 1 allora restituisce la prima nota              di <LIST>. Questo serve per la funzione <INTEGR-SUC> che             abbisogna di ogni passo delle derivate per risalire alla             lista <LIST> di partenza."    (let ((ris (first list))        (partenza (first list)))    (if (= gr° 1)       (pw::list! ris)      (append (prime-note (deriv list partenza)                          (- gr° 1)) (list  ris)))));;;--------------------------------------;;(pw::defunp derivation ((list list)                        (start menu (:menu-box-list (("first" . 1)                                                     ("orig" . 2))))                                                (gr° fix>0)) list                        "--------*-*--------------------------------*--------------------------------*---------*----------------------------*---------*---------*-*----------*---------------*-----*--------------------------------*-*-------------------------------------------------------------------------------------------------------------------------------Ce module est la transcription musicale de l'opération de dérivation, appliquéeà un profil mélodique. Dans ce cas précis l'intervalle tempporel entre leshauteurs est considéré égal à un (1). Le résultat de ce module est toujours uneliste de listes où le premier élément est le résultat de l'opération de dérivationreprésenté comme une liste de hauteurs en midicents. Et le reste des éléments représententle 'baricentre' des structures dérivées. Si on procède à une dérivation du premier dégrécette deuxième partie de la liste contiendra un élément, on procède à une dérivation du deuxième dégré cette deuxième partie de la liste contiendra deux éléments, et ainsi de suite.<list>     est soit une liste simple de hauteurs en midicents représentant un profil,           spoit une liste de listes originaire d'un module <integration>.<start>    menu dérroulant qui permet de définir le mode de fonctionement de ce module.           Si <start> égal à 'first' l'entrée <list> doit être une liste simple de hauteurs,           en midicents, représentant un profil, le résultat de l'opération sera la dérivation           de ce profil.           Si <start> égal à 'orig' l'entrée <list> doit être une liste de listes,           originaire d'un module <integration>. Ce mode sert à la reconstitution d'un profil           suite à des dérivations successives.          <gr°>      est l'ordre de l'opération de dérivation.                  "  (when (or (and (= start 1) (listp (first list))) (and (= start 2) (atom  (first list))))    (error "ATTENTION!! Au format de la liste d'entrée <list> et au menu <start>"))  (let ((value (if (= start 2) (rest list) nil))        (list (if (= start 1) list (first list))))        (append (list (quasi-der-suc list start value gr°))            (prime-note list gr°))))        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Integrali;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp integr ((list list) (start numbers?)) list                        "E' la funzione inversa alla funzione <DERIV>. In altre parole             prende una lista <LIST> gli sottrae un elemento scelto in <START>             e costruisce una lista con (pw::dx->x) a partire da <START>."    (pw::dx->x (first (pw::list! start)) (pw::g- list (first (pw::list! start)))));;;--------------------------------------;;(pw::defunp quasi-integr-suc ((list list)                              (start menu (:menu-box-list (("baric" . 1)                                                           ("orig" . 2))))                              (value numbers?)                              (gr° fix>0)) list                        "E' la funzione inversa alla funzione <DERIV-SUC>. In altre parole             prende una lista <LIST> gli sottrae un elemento scelto in <START>             e costruisce una lista con (pw::dx->x) a partire da <START>.             Con <GR°> possiamo decidere il numero di integrazioni successive             da applicare ad una lista.             Con <START> uguale BARIC allora la nota di partenza sarà il BARICENTRO             della lista.             Con <START> uguale a NOTE? possiamo scegliere noi il valore su cui             ricostruire la curva mettendo il valore in <VALUE>.             Nel caso in cui avessimo fatto delle operazioni di derivazione             successive su una lista di partenza e volessimo risalire alla lista              originaria allora <START> deve essere uguale ad ORIG."    (let ((ris nil)        (partenza (case start                    (1 (baricentro list))                    (2 (pop value)))))        (if (= gr° 1)      (push       (integr list partenza) ris)      (quasi-integr-suc (integr list partenza) start value (- gr° 1)))));;;--------------------------------------;;(pw::defunp integration ((list list)                         (start menu (:menu-box-list (("baric" . 1)                                                      ("orig" . 2))))                         (gr° fix>0)) list                        "Ce module est la transcription musicale de l'opération d'integration, appliquéeà un profil mélodique. Dans ce cas précis l'intervalle tempporel entre leshauteurs est considéré égal à un (1). Le résultat de ce module est toujours uneliste de listes où le premier élément est le résultat de l'opération d'integrationreprésenté comme une liste de hauteurs en midicents. Et le second  élément représentle 'baricentre' des structures integrées. Si on procède à une integration du premier dégrécette deuxième partie de la liste contiendra un élément, on procède à une integration du deuxième dégré cette deuxième partie de la liste contiendra toujours un élément, et ainsi de suite.<list>     est soit une liste simple de hauteurs en midicents représentant un profil,           spoit une liste de listes originaire d'un module <integration>.<start>    menu dérroulant qui permet de définir le mode de fonctionement de ce module.           Si <start> égal à 'baric' l'entrée <list> doit être une liste simple de hauteurs,           en midicents, représentant un profil, le résultat de l'opération sera l'integration           de ce profil.           Si <start> égal à 'orig' l'entrée <list> doit être une liste de listes,           originaire d'un module <derivation>. Ce mode sert à la reconstitution d'un profil           suite à des integrations successives.        <gr°>      est l'ordre de l'opération d'integration. "(when (or (and (= start 1) (listp (first list))) (and (= start 2) (atom  (first list))))    (error "ATTENTION!! Au format de la liste d'entrée <list> et au menu <start>"))  (let ((value (if (= start 2) (rest list) nil))        (list (if (= start 1) list (first list))))  (append (quasi-integr-suc list start value gr°)          (list (baricentro list)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interposizione di due liste;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun lettura-modulare (lista1 lista2)            "Se la prima lista è più grande della seconda lista, allora legge              modularmente la seconda lista restituendo un length uguale al length             di lista1."  (let ((ros nil))    (dotimes (y (length lista1) (nreverse ros))      (push        (if (< (length lista2) (length lista1))         (nth           (mod y (length lista2))          lista2)         (nth y lista2)) ros))));;;--------------------------------------;;(pw::defunp inter-profile ((list1 list) (list2 list)) list            ""  (let ((ris nil)        (y (lettura-modulare list1 list2)))        (pw::flat      (append       (dotimes (x (1- (length list1)) (nreverse ris))        (push         (pw::mat-trans (list (list (nth x list1))                              (list (trans-approx (list (nth x y))                                                  (list (nth x list1)                                                         (nth (1+ x) list1)))))) ris))     (last list1)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;Interposizione di due liste completa;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp prof-inter ((list1 list) (list2 list)                         (total menu                               (:menu-box-list (("ltd" . 1)                                                 ("copl". 2))))) list            "Restituisce l'interposizione di list1 con list2. Se list1 è più piccola             di list2 allora la funzione crea un'interposizione di n elementi di list2             dove (= n (- (length list1) 1)). In questo caso si puo' decidere con il              menù se avere la prima ricorsione per completare list2."  (case total    (1 (inter-profile list1 list2))    (2 (inter-profile (inter-profile list1 list2)                      (pw::permut-circ list2 (1- (length list1)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;Interposizione di due liste ricorsiva;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp interlock ((list1 list) (list2 list) (gr° fix>0)) list                        "Enchevêtrement des notes de la liste <list2> entre les notes de la liste <list1>,avec un degré <gr°> de profondeur variable.L’intérêt de ce module réside dans le fait que n'importe quelles que soientles notes de <list2> chaque fois qu'elles sont enchevêtrées entre les notesde <list1>, le module a le soin de changer la note d'octave de façonqu'elle puisse être entre les deux notes de <list1>.Exemple:soit un f#1 de <list2> qui devrait être enchevêtrée entre une pairee3 et a3 de <list1>. Le f#1 de <list2> serait, alors, transposé à f#3pour que la séquence devienne: e3 f#3 a3. Au cas où la note a être enchevêtréene soit pas contenu entre la paire de <list1>, elle sera alors transposéevers l'octave la plus proche d'une des notes de la paire en question.Exemple:Soit le même f#1 de <list2> qui devrait être enchevêtrée entre une paireg3 et a#3 de <list1>. Le f#1 de <list2> serait, alors, transposé à f#3pour que la séquence devienne:  f#3 g3 a#3. Le f#1 a été transposéle plus proche d'une des bornes de cette paire, dans ce cas précis à f#3qui été proche de g3.<gr°> est le niveau de profondeur du processus.Exemple:soit <list1> (6000* 4300* 6900* 5900*) et (pour des questions pédagogiques)<list2> (6100 6300 6500 6600 6800 7000 7200) et <gr°> = 1.Le résultat sera:(6000* 4900 4300* 6300 6900* 6500 5900*)                               [le * a été ajouté pour marquer les notes de <list1>] Il est possible de remarquer deux choses: 1) C'est la longueur de <list1> qui détermine la fin du processus 2) Le c#3 (6100) a été transposé à c#2 (4900) pour pouvoir être    inséré entre les deux notes de la première paire de <list1> ->(6000* 4300*)Si on maintient les mêmes listes, <list1> et  <list2> mais on change<gr°> à 2 nous aurons:(6000* 5400 4900! 4400 4300* 5800 6300! 6000 6900* 7300 6500! 6300 5900*)          [le * a été ajouté pour marquer les notes de <list1> et ! pour            marquer les notes déjà ajoutés lors du premier processus]nous percevons que les notes ajoutées sont 5400 (f#2 transposition de f#3 6600pour pouvoir être insérée entre 6000 et 4900),4400 (g#1 transposition de g#3 6800 pour pouvoir insérée entre 4900 et 4300)et ainsi de suite. C'est-à-dire à chaque niveau du processus le modulelit les notes de <list2> qui n'ont pas été lues lors de l'opération du niveau précédant.Au cas où on aurait finit de lire toutes les notes de <list2> et il aurait encore des pairesà enchevêtrer e module lirait circulairement <list2>.Ce processus est une transcription musicale de l'algorithme nommé <Midpoint-Displacement>,utilisé pour la construction de courbes fractales."    (if (= gr° 1) (inter-profile list1 list2)      (interlock (inter-profile list1 list2)                 (pw::permut-circ list2 (1- (length list1)))                 (- gr° 1))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interpolazione con BPF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp lin-list ((init fix) (end fix) (steps fix)) list                        "interpolation linèaire!!!!"    (if (eq init end) (make-list  steps :initial-element init)      (pw::arithm-ser init (/ (-  end init ) (+ 1 steps)) end)));;;--------------------------------------;;(pw::defunp cambia-ogni-accordo ((list list) (note? list)) list                        "Effettua la trasposizione per ogni accordo o nota del materiale in <LIST>             con ogni accordo o materiale in <NOTE?>. Se il length di NOTE? è inferiore             a quello di list allora NOTE? viene riletto modularmente."  (let ((ris nil))     (dotimes (x (length list) (nreverse ris))      (push (notes-change              (nth x list)             (nth x (pr note? list)) 48) ris))));;;--------------------------------------;;(pw::defunp inter-dyn0 ((init fix/float) (end fix/float) (steps fix>0)                        &OPTIONAL (tab object (:value '()))                         (inclu? menu                                  (:menu-box-list (("yes" . 1) ("no". 2))                                                :type-list (no-connection)))) list                        "Interpolation dynamique entre deux points avec la possibilité de définirle parcours.<begin>    valeur initiale, peut être soit une valeur simple soit une liste,<end>      valeur finale, peut être soit une valeur simple soit une liste,<steps>    nombre de pas pour l'interpolation             <tab>      cette entrée accepte un module bpf  et réalise l'interpolation            entre <begin> et <end> avec le profil dessiné dans la bpf.           Si aucun module <multi-bpf> est connecté l'interpolation sera linéaire.<inclu?>   est un menu déroulant qui permet de choisir l'inclusion ou non           des objets <begin> et <end>.           Si <inclu?> est égal à 'yes' les objets  seront inclus dans            la liste de sortie.           Si <inclu?> est égal à 'no' les objets  seront  supprimés de            la liste de sortie."    (let* ((x-points (when tab (pw::x-points tab)))         (listetab (when tab (pw::g-scaling (pw::bpf-sample tab (+ 2 steps)                                                        (pw::g-min x-points)                                                        (pw::g-max x-points)                                                        1                                                        4)                                        0.0                                        1.0)))         (liste1 (if tab listetab                     (lin-list 0 1 steps)))         (liste2 (pw::g+ (pw::g* liste1 (- end init)) init)))    (case inclu?      (1 liste2)      (2 (butlast (rest liste2))))));;;--------------------------------------;;(pw::defunp inter-dyn ((begin numbers?)                        (end numbers?)                        (steps fix>0)                       (tab object (:value '()))                        (inclu? menu                                 (:menu-box-list (("yes" . 1) ("no". 2))))                       &optional (note? list (:value '()))) list                        "Interpolation dynamique entre deux points avec la possibilité de définirle parcours.<begin>    valeur initiale, peut être soit une valeur simple soit une liste,<end>      valeur finale, peut être soit une valeur simple soit une liste,<steps>    nombre de pas pour l'interpolation             <tab>      cette entrée accepte un module bpf  et réalise l'interpolation            entre <begin> et <end> avec le profil dessiné dans la bpf.           Si aucun module <multi-bpf> est connecté l'interpolation sera linéaire.<inclu?>   est un menu déroulant qui permet de choisir l'inclusion ou non           des objets <begin> et <end>.           Si <inclu?> est égal à 'yes' les objets  seront inclus dans            la liste de sortie.           Si <inclu?> est égal à 'no' les objets  seront  supprimés de            la liste de sortie.Entrée optionnelle<note?>    entrée optionnelle qui permet l'ajustement de la séquence générée           (exception faite à <begin> et <end>) à un (ou plusieurs) champs harmoniques.           <note?> peut être soit une liste simple ou soit une liste de listes.           Si <note?> est une liste simple tous les objets seront ajustés           en fonction des notes de cette liste.           Si <note?> est une liste de listes à chaque objet généré sera           fait correspondre une des sous listes. Si le nombre de sous listes           est plus petit que la longueur de la liste des interpolations, la           liste de listes <note?> sera lue circulairement."    (let* ((initio (pw::list! begin))         (endio (pw::list! end))         (le-note (when note?                    (if (atom (first note?))                      (list note?) note?)))         (interpo (pw::mat-trans (mapcar #'(lambda                                              (liste1 liste2)                                              (inter-dyn0 liste1 liste2 steps tab 2))                                         initio endio)))         (con-scala (when note?                      (if (= (length begin) 1)                        (pw::list-explode                         (notes-change (pw::flat interpo) (pw::flat le-note) 48)                         (length interpo))                        (cambia-ogni-accordo interpo le-note))))         (fine-calcolo (append (list begin)                               (if note? con-scala interpo)                               (list end))))            (case inclu?      (1 fine-calcolo)      (2 (butlast (rest fine-calcolo))))));;;         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interpolazione ad n punti;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp dyn-mult ((elmt list)                       (steps list)                       (tab object (:value '()))) list                        "Restituisce l'interpolazione tra tutti gli elementi di 'elmt'.             I passi e le curve sono definibili per ogni tratto dell'interpolazione             con l'utilizzo di una o più curve BPF."    (pw::flat-once   (let ((ris nil)         (passi (pr steps elmt))         (curve (when tab (pr (pw::list! tab) elmt))))               (dotimes (x (- (length elmt) 1))       (push (list (nth x elmt)) ris)       (push          (inter-dyn (nth x elmt)                   (nth (1+ x) elmt)                   (nth x passi)                   (nth x curve)                   2)        ris))     (nreverse (push (list (pw::last-elem elmt)) ris)))));;;--------------------------------------;;(pw::defunp interpol-multipla ((elmt list)                                (steps list)                                (tab object (:value '()))) list                        "Restituisce l'interpolazione tra tutti gli elementi di 'elmt'.             I passi e le curve sono definibili per ogni tratto dell'interpolazione             con l'utilizzo di una o più curve BPF."    (pw::flat-once   (let ((ris nil)         (passi (pr steps elmt))         (curve (when tab (pr (pw::list! tab) elmt))))               (dotimes (x (- (length elmt) 1) (nreverse ris))              (push          (list (inter-dyn (nth x elmt)                         (nth (1+ x) elmt)                         (nth x passi)                         (nth x curve)                         2))        ris)))));;;--------------------------------------;;(pw::defunp our-interlock ((liste1 list) (liste2 list)) list                        "l'interlock se fait un à un et commence avec le             premier élément de liste1"    (let ((longs (mapcar #'(lambda (x) (length x)) liste2))        (aux nil)        (int-list (pw::flat-once liste2))         (k 0) (p 0))        (dotimes (n (1- (length liste1)) (pw::x-append (reverse aux) (last liste1)))      (push (nth n liste1) aux)              (dotimes (m (nth n longs))          (push (nth (+ k m) int-list) aux)          (setf p m))      (setf k (+ k p 1)))));;;--------------------------------------;;(pw::defunp interpol-mult-note? ((elmt list)                                  (steps list)                                  (tab object (:value '()))                                 (note? list)) list                        "Restituisce l'interpolazione tra tutti gli elementi di 'elmt'.             I passi e le curve sono definibili per ogni tratto dell'interpolazione             con l'utilizzo di una o più curve BPF."    (let* ((note? (if (atom (first note?)) (list note?) note?))         (calcolo (interpol-multipla elmt steps tab))         (longs (mapcar #' (lambda (x) (length x)) calcolo))         (interpolazione (pw::flat-once calcolo)))        (our-interlock elmt (scomp (cambia-ogni-accordo interpolazione                                                    note?) longs))));;;--------------------------------------;;(pw::defunp multi-interpol ((prof list)                             (n°elm numbers? (:min-val 1 :value 1))                             (tab object (:value '()))                            &optional (note? list (:value '()))) list                        "Interpolation dynamique entre les éléments d'un profil de base.Ce module permet l'interpolation entre les éléments d'une liste qu'ils soientdes notes ou des accords.<prof>    est soit une liste simple, soit une liste de listes, de hauteurs en midicents.           <n°elm>   est soit un nombre, soit une liste. Il est possible de choisir          le nombre de pas d'interpolation entre les éléments de <prof>.          Si <n°elm> est un nombre, par exemple '3', nous allons ajouter           trois pas d'interpolation entre chaque paire d'éléments de <prof>.          Dans ce cas <n°elm> a une action globale.          Mais il est aussi possible de rentrer dans <n°elm> une liste          qui définirait un nombre de pas d'interpolation différents          pour chaque paire d'éléments de <prof>, ce qui nous permet          un contrôle locale.          Par exemple si <n°elm> égal à (3 4 5) nous aurons trois éléments          interpolés entre la première paire de valeurs, quatre entre           la deuxième et cinq entre la troisième.          Si le nombre de points de <n°elm> est plus petit que le nombre           d'éléments de <prof> moins un, la liste <n°elm> sera lue circulairement.          Dans l'exemple au-dessus si <prof> a plus de quatre éléments,          le module recommencera la lecture du début de <n°elm>, c'est-à-dire,          entre la quatrième paire d'éléments de <prof> nous aurons trois éléments,          après quatre, etc..                    <tab>     cette entrée accepte un module bpf  et réalise l'interpolation           entre <begin> et <end> avec le profil dessiné dans la bpf.          Si aucun module <multi-bpf> est connecté l'interpolation sera linéaire.          De la même manière que <n°elm> il est possible de connecter soit un          objet <multi-bpf>, soit une liste d'objets <multi-bpf>.          Si <tab> est un objet <multi-bpf> l'interpolation entre toutes les paires          de <prof> sera toujours avec la forme désignée par <tab>.          Dans ce cas <tab> a une action globale.          Mais il est aussi possible de rentrer dans <tab> une liste          qui définirait une direction d'interpolation différente          pour chaque paire d'éléments de <prof>, ce qui nous permet          un contrôle locale.          Si le nombre d'éléments de <tab>> est plus petit que le nombre           d'éléments de <prof> moins un, la liste <tab> sera lue circulairement.         <note?>    entrée optionnelle qui permet l'ajustement de la séquence générée           (exception faite à <begin> et <end>) à un (ou plusieurs) champs harmoniques.           <note?> peut être soit une liste simple ou soit une liste de listes.           Si <note?> est une liste simple tous les objets seront ajustés           en fonction des notes de cette liste.           Si <note?> est une liste de listes à chaque objet généré sera           fait correspondre une des sous listes. Si le nombre de sous listes           est plus petit que la longueur de la liste des interpolations, la           liste de listes <note?> sera lue circulairement."    (let* ((steps (pw::list! n°elm))         (interpo (dyn-mult prof steps tab))         (interpo-note (when note?                         (if (atom (first prof))                           (interpol-mult-note? (pw::list-explode prof (length prof)) steps tab note?)                           (interpol-mult-note? prof steps tab note?)))))        (if note? interpo-note interpo)))         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interferenza di una lista;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp prof-pert ((ls list) (range fix/float)) list           "Restituisce una perturbazione casuale 'random' della lista             aggiungendo o sottraendo dei valori scelti casualmente tra             +range e -range."  (mapcar #' (lambda (x) (+ x (pw::g-random (- range) range))) ls));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interpolazione con note prestabilite;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp tutti-int ((list list) (ref fix/float)) list                        "Calcola gli intervalli che ci sono fra una lista di note ed             un'unica nota di riferimento."        (let ((ris nil))        (dolist (y list)      (push (pw::x->dx (list ref y)) ris))    (pw::flat (nreverse ris))));;;--------------------------------------;;(pw::defunp segno+picc ((list list)) list            "Trasforma tutta la lista in valori tutti positivi e prende il valore             più piccolo."  (pw::g-min (mapcar #' (lambda (x) (abs x)) list)));;;--------------------------------------;;(pw::defunp nota-vicina ((list list) (ref fix/float)) list                        "Prende l'intervallo più piccolo di una lista."    (let* ((intervalli (tutti-int list ref))         (piccolo (segno+picc intervalli)))            (if      (equalp (abs (first intervalli)) piccolo)      (first intervalli)      (nota-vicina (rest list) ref))));;;--------------------------------------;;(pw::defunp tieni-nota ((list list) (ref fix/float)) list                        "tiene la nota più vicina."    (pw::g+ ref (nota-vicina list ref)));;;--------------------------------------;;(pw::defunp vicine-note ((list1 list) (refs list)) list                        "Prende le note più vicine di list per ogni nota di refs."       (let ((ris nil))     (dotimes (x (length refs) (nreverse ris))       (push (tieni-nota list1 (nth x refs)) ris))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Trasposizione controllata;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun int-com-ottava (lista)    "Restituisce l'intervallo complementare ad ull'intervallo in 'lista'   ma all'interno di un'ottava."      (let ((ris nil))        (pw::flat     (dotimes (x (- (length lista) 1) (nreverse ris))       (push         (pw::x->dx (append                    (list (nth x lista))                    (list                       (- (nth x lista)                        (* (- 12 (mod                                   (/ (- (first (pw::x->dx lista))                                         (*                                          (first                                           (pw::g-div (pw::x->dx lista) 1200)) 1200)) 100) 12)) 100)))))        ris)))));;;--------------------------------------;;(defun mio-transpoct (list range)            "Restituisce lo stesso risultato di 'transpoct' della libreria Esquisse"  (let ((ris nil))    (dolist (y list (nreverse ris))      (push        (cond ((< y (pw::g-min range))              (+ (pw::g-min range)                 (+ 1200 (first (int-com-ottava (list (pw::g-min range) y))))))             ((> y (pw::g-max range))              (+                (pw::g-max range)                (first (int-com-ottava (list (pw::g-max range) y)))))             (y))       ris))));;;--------------------------------------;;(pw::defunp correttore ((elmt fix) (range list)) list          "Restituisce un elemento se questo compare all'interno del range.           Se l'elemento è escluso allora lo traspone in modo tale che sia           il più vicino possibile o al limite superiore o a quello inferiore.           Se il limite è DO-SOL allora Mi viene incluso, SI viene trasposto           sotto il DO e il SOL# viene trasposto sopra il SOL."  (let ((max (pw::g-max range))        (min (pw::g-min range)))    (cond ((<= (pw::g-min range) elmt max)            elmt)          ((cond ((< elmt min)                  (cond ((<= (- min elmt) (- (+ 1200 elmt) max))                         elmt)                        ((> (- min elmt) (- (+ 1200 elmt) max))                         (+ 1200 elmt))))                 ((> elmt max)                  (cond ((<= (- elmt max) (- min (- elmt 1200)))                         elmt)                        ((> (- elmt max) (- min (- elmt 1200)))                         (- elmt 1200)))))))));;;--------------------------------------;;(defun cor-ott-list (elmt range)                  "Restituisce un elemento se questo compare all'interno del range.           Se l'elemento è escluso allora lo traspone in modo tale che sia           il più vicino possibile o al limite superiore o a quello inferiore.           Se il limite è DO-SOL allora Mi viene incluso, SI viene trasposto           sotto il DO e il SOL# viene trasposto sopra il SOL.La differenza           con 'CORRETTORE' è che questo modulo agisce su una lista intera."                (let ((ris nil))          (dolist (y elmt)            (push (correttore y range) ris))          (nreverse ris)));;;--------------------------------------;;(pw::defunp trans-approx ((list list) (range list)) list            "E' meglio di transpoct di Esquisse. Infatti attua lo stesso             procedimento ma traspone una nota non inclusa nel range il più             vicino o al limite superiore o a quello inferiore."  (cor-ott-list (mio-transpoct list range) range));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interpolazione con note prestabilite;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp interpol-prof  ((prof1 midics?)                              (prof2 midics?)                            (steps fix>0 (:value 4 :min-val 2))                            (nbr-n list  (:value '()))                            (tab object (:value '()))                            (note? list (:value '()))                            (precis fix (:min-val 1 :value 1))                            (approx fix>0 (:value 2))) list                        "Interpolation entre deux profils mélodiques <prof1> et <prof2> de tailles quelconques!!!.Ce module se prête à l'interpolation quand le profil est important.La sortie de ce module est une liste de listes où chaque sous-listecorrespond à un profil.<prof1>    est une liste simple, de hauteurs en midicents, qui           définie un profil mélodique. <prof2>    est une liste simple, de hauteurs en midicents, qui           définie un deuxième profil mélodique.    <steps>    nombre de pas d'interpolation<nbr-n>    nombre de notes dans chaque profil généré.            Si aucun nombre ou liste est donnée, chaque profil intermédiaire           aura un nombre de notes correspondant à une interpolation linéaire           entre le nombre de notes de <prof1> et le nombre de notes de <prof2>           Si <nbr-n> est un entier, comme par exemple '5', tous les profils générés (à l'exception de          <prof1> et <prof2>) auront cinq notes.           Si <nbr-n> est une liste, chaque profil généré aura  un nombre d'éléments           correspondant à une valeur de <nbr-n>. Par exemple si <nbr-n> est           (2 3 4 5 6 1 2), le premier profil aura deux notes, le deuxième profil           aura trois notes, le troisième profil aura quatre notes, et ainsi de suite.<tab>      cette entrée accepte un module bpf  et réalise l'interpolation            entre <prof1> et <prof2> avec le profil dessiné dans la bpf.           Si aucun module <multi-bpf> est connecté l'interpolation entre <prof1> et <prof2>           sera linéaire.<note?>    entrée  qui permet l'ajustement de la séquence générée           (exception faite à <prof1> et <prof2>) à un (ou plusieurs) champs harmoniques.           <note?> peut être soit une liste simple ou soit une liste de listes.           Si <note?> est une liste simple tous les objets seront ajustés           en fonction des notes de cette liste.           Si <note?> est une liste de listes à chaque objet généré sera           fait correspondre une des sous listes. Si le nombre de sous listes           est plus petit que la longueur de la liste des interpolations, la           liste de listes <note?> sera lue circulairement.<précis>   Comme ce module n'interpole pas des notes, mais des profils,           un des pas dans sont processus est la conversion de la liste,           soit <prof1> ou <prof2>, en un profil. Pour cela il est nécessaire           de définir un 'taux d’échantillonnage'. Le paramètre <précis>            défini un 'taux d’échantillonnage' égal à             <précis>*(plus grande longueur entre <prof1> et <prof2>).           Ce qui défini une valeur minimale de '1' pour  <précis>.           En fonction de l'utilisation il est nécessaire d'ajuster ce paramètre.           Une valeur égale à '5' nous a paru largement suffisante dans tous les essais           préliminaires.<approx>  approximation des résultats.          <approx> = 4 l'approximation sera de quart de ton,          <approx> = 2 l'approximation sera de demi  ton,          <approx> = 8 l'approximation sera de huitième de ton, et ainsi de suite.           "    (let* ((prof1 (pw::list! prof1))         (prof2 (pw::list! prof2))         (lungo1 (length prof1))         (lungo2 (length prof2))         (le-note (when note?                    (if (atom (first note?))                      (list note?) note?)))         (bpf1 (pw::make-break-point-function  (pw::arithm-ser 0 (* 10 precis) (1- (* precis 10 lungo1))) prof1))         (bpf2 (pw::make-break-point-function  (pw::arithm-ser 0 (* 10 precis) (1- (* precis 10 lungo2))) prof2))         (liste-interpolations (bpf-interpolx bpf1 bpf2                                               (* precis                                                  (pw::g-max (list lungo1 lungo2)))                                              2 steps tab 1))         (nbr-n (cond                  ((null nbr-n) (lin-list lungo1 lungo2 steps))                 ((numberp nbr-n) (pw::create-list (- steps 2) 0 nbr-n))                 (t (pw::x-append lungo1 (pr nbr-n (pw::create-list (- steps 2) 0 nbr-n)) lungo2))))         (calcolone (mapcar #'(lambda (x ech) (pw::approx-m (pw::bpf-sample x ech                                                             (pw::g-min (pw::x-points x))                                                            (pw::g-max (pw::x-points x))                                                            1                                                            4) approx))  liste-interpolations nbr-n))         (con-note (when note?                     (append (list prof1)                             (cambia-ogni-accordo (rest (butlast calcolone)) le-note)                             (list prof2)))))    (if note? con-note calcolone)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UTILITA';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Range-approx;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp range-approx ((list list)                          (limit list)                          (inclu? menu                                    (:menu-box-list (("yes" . 1) ("no". 2))))) list            "Transposition des notes (en midicents) de <list> dans le registredéfini par la liste <limit>.<list>    liste de hauteurs en midicents<limit>   liste de deux éléments, en midicents, qui définissent le registre          dans lequel les notes de <list> seront transposées.<inclu?>   est un menu déroulant qui permet de choisir l'inclusion ou non           des notes qui ne seraient pas incluses dans le registre défini par <limit>.           Si <inclu?> est égal à 'yes' les notes non incluses dans            cet intervalle  sont ajoutées à la borne la plus proche.           Si <inclu?> est égal à 'no' les notes non incluses dans            cet intervalle  sont exclues."  (funcall (case inclu?             (1 'trans-approx)             (2 'comp-octave))           list limit));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Scompositore;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp segment ((liste list)                      (place fix)                      (n-elem fix>0)                     (lecture menu (:menu-box-list (("lin" . 1) ("circ". 2) )                                                   :type-list (no-connection)))) list                        "retire les <n-elem> éléments de la liste <liste> à partir de la place            <place>. OBS: place=0 c'est-à-dire premier élément de liste.            Il est possible de choisir deux types de lectures -lineaire- ou -circulaire-"    (case lecture    (1 (if (> (length liste) (+ place n-elem))          (subseq  liste place  (+ place n-elem))         (nthcdr place (butlast liste 0))))    (2 (let ((aux))         (dotimes (n n-elem (reverse aux))           (push (nth (mod (+ n place ) (length liste)) liste) aux))))));;;--------------------------------------;;(defun crea-spazio (list segm)  (let ((place (pw::dx->x 0 segm)))    (remove nil (mapcar #'(lambda (pl el) (segment list pl el 1)) place segm))));;;--------------------------------------;;(pw::defunp group-list ((list list)                         (group list)                        (mode? menu                               (:menu-box-list                                 (("stop" . 1) ("circ". 2)                                 ("scal" . 3))))) list                                    "Articulation d'une liste <list> en segments de longueurs définispar une deuxième liste de nombres entiers <group>.<list>  est une liste quelconque<group> est une liste de nombres qui définissent des longueurs        de segments.Par exemple soit la liste <list>(a b c d e f g h i j k l m)et la liste <group>(4 2 1 3 3)le résultat sera:PW->((a b c d) (e f) (g) (h i j) (k l m))<mode?> est un menu déroulant qui défini le mode de fonctionnement de         ce module.        Si <mode?> égal 'stop' la segmentation se fera linéairement,         c'est-à-dire, même si la liste <group> contient plus d'élément        ou si la somme de ses éléments est supérieure à la longueur        de <list> la segmentation se fera jusqu’à la fin des éléments        de <list>. Exemple: soit <list> (a b c d e f g h i j k l m)        et <group> (4 2 1 3 5) le résultat sera toujours:        PW->((a b c d) (e f) (g) (h i j) (k l m)). Où si <group> égal (4 2 1 3 5 2)        le résultat sera toujours:        PW->((a b c d) (e f) (g) (h i j) (k l m)).        Si <mode?> égal 'circ' la segmentation se fera circulairement.        c'est-à-dire, que pour constituer les segments imposés par <group>,        le module ajoutera des éléments du début de <list>.        Exemple: soit <list> (a b c d e f g h i j k l m)        et <group> (4 2 1 3 5 2) le résultat sera alors        PW->((a b c d) (e f) (g) (h i j) (k l m a b) (c d)).        Si <mode?> égal 'scal' la segmentation se fera proportionnellement.        L'articulation prendra en compte plutôt les proportion entre les        éléments de <group> et constituera des segments avec tous les         éléments de <list>.Exemple soit la liste <list> de 12 éléments        (a b c d e f g h i j k l) et la liste <group> (5 3 4).        Logiquement le résultat sera         PW->((a b c d e) (f g h) (i j k l)).        Mais si nous gardons la même <list> et nous changeons <group>        pour (10 3 8) le résultat sera toujours le même:        PW->((a b c d e) (f g h) (i j k l)).       "    (let ((calcolo (pr list (pw::create-list (apply'+ group) 0))))        (case mode?      (1 (crea-spazio list group))      (2 (scomp calcolo group))      (3 (crea-spazio list (pw::g-round                       (pw::g-scaling/sum group (length list))))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;substitute;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp subst-list ((list list)                         (new numbers?)                        (old numbers?)                        (start fix>=0)                        (count fix>0)                        &optional (test symbol (:value 'equalp :type-list ()))) list                        "Ce module permet la substitution de tout élément <old>appartenant à <list> par un nouveau élément <new>.<list>  est la liste de référence<old>   est l'élément à retirer de <list>,        il peut être un nombre, une liste ou un symbole  <new>   est l'élément à substituer dans <list> à la place de <old>,        il peut être un nombre, une liste ou un symbole                           <start> est un indice qui indique à partir de quel élément de la liste        se fera la substitution. '0' (zéro) est le premier élément.<count> est un indice qui indique combien d'éléments <old> de <list>        seront substitués.<test>  est un prédicat optionnel pour la comparaison des éléments.        Il est possible que pour certaines applications les éléments à        substituer et implicitement à comparer soient de types diverses,        ce qui peut exiger l'utilisation de prédicats de comparaison        spéciaux. Le prédicat par défaut est 'equalp' qui est un prédicat        d'égalité faible, se prêtant bien à la comparaison entre nombres,        listes et symboles."  (let ((old (cond                ((atom old) old)               ((listp old) (if (= 1 (length old)) (first old) old)))))  (substitute new              old              list              :start start              :count count              :test test)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp interpol-tab ((begin numbers?)                           (end numbers?)                           (steps fix>0)                          (tab object (:value '()))                           (inclu? menu                                    (:menu-box-list (("yes" . 1) ("no". 2))))) list                        "Interpolation dynamique entre deux points avec la possibilité de définirle parcours.<begin>    valeur initiale, peut être soit une valeur simple soit une liste,<end>      valeur finale, peut être soit une valeur simple soit une liste,<steps>    nombre de pas pour l'interpolation             <tab>      cette entrée accepte un module bpf  et réalise l'interpolation            entre <begin> et <end> avec le profil dessiné dans la bpf.           Si aucun module <multi-bpf> est connecté l'interpolation sera linéaire.<inclu?>   est un menu déroulant qui permet de choisir l'inclusion ou non           des objets <begin> et <end>.           Si <inclu?> est égal à 'yes' les objets  seront inclus dans            la liste de sortie.           Si <inclu?> est égal à 'no' les objets  seront  supprimés de            la liste de sortie."    (let ((initio (pw::list! begin))        (endio (pw::list! end)))        (pw::mat-trans (mapcar #'(lambda                                (liste1 liste2)                                (inter-dyn0  liste1 liste2 steps tab inclu?))                           initio endio))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp weight-average ((list list)) midics?            "Calcule le barycentre de l'ensemble de hauteurs <list>"  (baricentro list));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Interpolazione di BPF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(pw::defunp BPF-interpolx  ((bpf1 object)  (bpf2 object)                            (echantillons fix>0 (:min-val 2 :value 20))                            (approx fix>0)                             (steps fix>0 (:value 4 :min-val 2))                            (tab object (:value '()))                            (mode menu (:menu-box-list (("bpf" . 1) ("liste". 2))                                                       :type-list (no-connection)))) list                        "Interpolation entre deux profils  <bpf1> et <bpf2> de tailles quelconques!!!.Ce module se prête à l'interpolation quand le profil est important.La sortie de ce module est soit une liste de listes où chaque sous-listecontient les coordonnées correspondantes à un profil, soit une listed'objets bpf.<bpf1>    est une liste simple, de hauteurs en midicents, qui           définie un profil mélodique. <bpf2>    est une liste simple, de hauteurs en midicents, qui           définie un deuxième profil mélodique.   <échantillons>   Comme ce module n'interpole pas des points, mais des profils,                 un des pas dans son processus est la conversion de la liste,                 soit <bpf1> ou <bpf2>, en un profil. Pour cela il est nécessaire                 de définir un 'taux d’échantillonnage'. Le paramètre <échantillons>                  défini un nombre de points nécessaires pour cet échantillonnage.                 <échantillons> est une espèce de 'taux d’échantillonnage' .                 Pour des utilisations courantes la valeur '20' nous a semblé suffisante. <steps>    nombre de pas d'interpolation<tab>      cette entrée accepte un module bpf  et réalise l'interpolation            entre <bpf1> et <bpf2> avec le profil dessiné dans la bpf.           Si aucun module <multi-bpf> est connecté l'interpolation entre <bpf1> et <bpf2>           sera linéaire.<mode>     menu déroulant qui défini la sortie de ce module.           Si <mode> égal à <bpf> la sortie sera une liste d'objets BPF.           Si <mode> égal à <liste> la sortie sera une liste de           listes où chaque sous liste contient deux sous listes.           La première étant les abscisses et la deuxième les coordonnées           de chaque profil.           "    (let* ((xbpf1 (pw::x-points bpf1))         (xbpf2 (pw::x-points bpf2))         (x-max-bpf1 (pw::g-max xbpf1))         (x-min-bpf1 (pw::g-min xbpf1))         (x-max-bpf2 (pw::g-max xbpf2))         (x-min-bpf2 (pw::g-min xbpf2))         (databpfy1           (pw::bpf-sample bpf1 echantillons x-min-bpf1 x-max-bpf1 1 2))         (databpfx1 (epw:arithm-ser x-min-bpf1                                     (/ (- x-max-bpf1                                           x-min-bpf1)                                        (- echantillons 1))                                    x-max-bpf1))         (databpfy2           (pw::bpf-sample bpf2 echantillons x-min-bpf2 x-max-bpf2 1 2))         (databpfx2 (epw:arithm-ser x-min-bpf2                                     (/ (- x-max-bpf2                                           x-min-bpf2)                                        (- echantillons 1))                                    x-max-bpf2))         (coordonx (pw::g-round (interpol-tab databpfx1 databpfx2  steps tab 1) approx))         (coordony (pw::g-round (interpol-tab databpfy1 databpfy2  steps tab  1) approx)))    (case mode      (1 (mapcar #'(lambda (x  y)                      (pw::make-break-point-function x  y)) (pw::g-round coordonx) (pw::g-round coordony)))      (2 (pw::mat-trans (list coordonx coordony))))));;;