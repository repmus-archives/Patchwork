(in-package "repmus");;;;;;            Librairie RepMus;;;;            Gerard Assayag, Claudy Malherbe, Joshua Fineberg, Peter Hanappe  © IRCAM 1996           (defclass partial ()  ((onset :accessor onset :initarg :onset)   (outset :accessor outset :initarg :outset)   (frequency :accessor frequency :initarg :frequency)   (amplitude :accessor amplitude :initarg :amplitude)))(defclass partial-set ()  ((partials :accessor partials :initarg :partials)   (inter-onsets :accessor inter-onsets :initarg :inter-onsets)   (chord-delta :accessor chord-delta :initarg :chord-delta))) (defmethod duration ((partial partial))  (- (outset partial) (onset partial)))(defmethod round-time ((partial partial))  (setf (onset partial)  (round (* 100  (onset partial))))  (setf (outset partial) (max (onset partial) (round (* 100 (outset partial)))))  partial)(defmethod move-onset ((partial partial) onset)  (setf (outset partial) (+ (outset partial) (- (onset partial) onset))        (onset partial) onset)  partial)(defmethod set-inter-onset ((partial-set partial-set))  (setf (inter-onsets partial-set)        (loop for partial1 in (partials partial-set)              for partial2 in (rest (partials partial-set))              collect (- (onset partial2) (onset partial1))))  partial-set)(defmethod round-time ((partial-set partial-set))  (loop    for partial in (partials partial-set)    with window-left = 0 and window-right = (chord-delta partial-set)    if (< (onset partial) window-right) do    (move-onset partial window-left)    else do (setf window-left (onset partial)                  window-right (+ window-left (chord-delta partial-set)))    )  partial-set)(defun mk-partial-set (analyse delta vmin vmax fmin fmax)  (setf analyse (first analyse))  (unless (string= (symbol-name (pop analyse)) "PARTIALS")    (error "This is not a spectral analysis"))  (let ((nbpartials (pop analyse)))    (setf analyse          (mapcar #'(lambda (partial)                      (pop partial)                      (loop with nbpoints = (pop partial)                            with first-date = (first partial)                            with last-date                             for date in partial by #'cdddr                            for freq in (cdr partial) by #'cdddr                            for amp in (cddr partial) by #'cdddr                            do (setf last-date date)                             sum freq into freq-sum                            sum amp into amp-sum                            finally (return (list first-date last-date                                                   (/ freq-sum nbpoints)                                                   (/ amp-sum nbpoints)))))                  analyse))    (setf analyse (epw::mat-trans analyse))     (setf (fourth analyse)          ;(epw::g-round (epw::g-scaling (fourth analyse) vmin vmax)))          (epw::g-round            (epw::g-scaling (mapcar #'(lambda (x) (* x (exp (* x 2))))                                   (epw::g-scaling (fourth analyse) 0.0 1.0))                           vmin vmax)))    (let      ((partial-set        (make-instance 'partial-set          :chord-delta delta          :partials          (apply  #'mapcar                  #'(lambda (onset outset freq amp)                      (round-time (make-instance 'partial :onset onset :outset outset :frequency freq                                                 :amplitude amp)))                  analyse))))      (setf (partials partial-set)            (loop for partial in (partials partial-set)                  when (<= fmin (frequency partial) fmax)                  collect partial))      (round-time partial-set)      (set-inter-onset partial-set)      partial-set)))(defun partials->chords (partial-set approx npoly)  (and (partials partial-set)       (let ((partial-list (list (list (first (partials partial-set)))))             (chord-list) )                   (loop for partial in (rest (partials partial-set))               for inter-onset in (inter-onsets partial-set)               if (zerop inter-onset) do               (push partial (first partial-list))               else do (push (list partial) partial-list))         (setf partial-list (reverse partial-list))         (setf chord-list               (mapcar #'(lambda (partials)                           (setf partials (reduce-partials partials approx npoly))                           (pw::mk-chord                            (epw::f->mc (mapcar #'frequency partials))                            (mapcar #'duration partials)                            ()                            (mapcar #'amplitude partials)))                       partial-list))         (mapc #'(lambda (chord partials)                   (setf (pw::t-time chord)                         (onset (first partials))))               chord-list partial-list)         (when chord-list           (let ((sequence-offset (pw::t-time (first chord-list))))             (when (not (zerop sequence-offset))               (mapc #'(lambda (chord)                         (setf (pw::t-time chord) (- (pw::t-time chord) sequence-offset)))                     chord-list))))         chord-list)))  (defun reduce-partials (partials approx npoly)  (let ((pbuf ()) (partials (sort partials #'(lambda (p1 p2) (< (frequency p1) (frequency p2))))))    (loop for partial in partials          if (and pbuf                   (= (epw::approx-m (epw::f->mc (frequency partial)) approx)                     (epw::approx-m (epw::f->mc (frequency (first pbuf))) approx))) do          (setf (amplitude (first pbuf)) (max (amplitude (first pbuf)) (amplitude partial))                (outset (first pbuf)) (max (outset (first pbuf)) (outset partial)))          else do (push  partial pbuf))    (pw::first-n   (sort pbuf '> :key #'amplitude) npoly)))                                (defunp AS->pw ((analyse fix/fl/list (:value ()))                (vmin integer  (:value 40 :min-val 1 :max-val 127))                (vmax integer  (:value 100 :min-val 1 :max-val 127))                (delta fix>=0 (:value 5))                (mmin midic (:value 4000))                (mmax midic (:value 8600))                (approx approx)                (npoly integer (:value 1 :min-val 1 :max-val 64))) list "Converts partials-analysis data, obtained from AudioSculpt by the 'Export Partials' command,in a suitable format for displaying and manipulating in PatchWork.parameters : analyse : connect here the output of a text-win module where you have read the analysis text file.vmin,vmax : integers, amplitudes will be scaled between  vmin and vmax velocitiesdelta: integer, events whose onset-time fall within a window of <delta> 1/100sec will be gathered into chordsmmin,mmax: midic values that define the allowed pitch range for the output.approx: 1,2,4, or 8. Micro-tone approximation.npoly: tries and reduce the polyphony to <npoly> notes at the same time by taking the louder partials first.output : a list of chords to be connected to a chordseq module."  (partials->chords (mk-partial-set analyse delta vmin vmax (epw::mc->f mmin) (epw::mc->f mmax)) approx npoly))#|(defunp chseq->poly ((chseq list (:value "(6000)" :type-list (list  chord pw::collector)))                     (del fix>0) (approx approx)) list         "Converts a sequence of chords in a pseudo polyphony where common notesbetween two chords are changed into a single sustained note (harmonic link).chseq is a list of chords-objects or midics sublists.del defines the time interval between two chords.approx (1, 2, 4, 8) tells the approximation used for finding common notes.Outputs a list of chord objects suitable for input to a chordseq module."     (let ((time 0)  prevch  poly vel-list del-list)    (when (subtypep (type-of chseq)'pw::c-chord-line)      (setf chseq (pw::get-slot chseq 'pw::chords)))    (when (consp chseq)      (if (consp (car chseq))        (setf vel-list              (mapcar #'(lambda (midics)                          (make-list (length midics) :initial-element 100))                      chseq)              del-list (make-list (length chseq) :initial-element del))        (when (subtypep (type-of (car chseq)) 'pw::c-chord)          (if (some  #'(lambda (chord) (not (zerop (pw::t-time chord)))) chseq)            (setf del-list  (pw::x->dx (pw::get-slot chseq 't-time )))            (setf del-list (make-list (length chseq) :initial-element del)))          (setf vel-list (c-get-note-slots:get-note-slots chseq 'vel)                chseq (c-get-note-slots:get-note-slots chseq 'midic)))        ))    (setf chseq (epw::approx-m chseq approx)          prevch (make-list (length (car chseq)) :initial-element 0))    (mapc #'(lambda (curch curvels curdel)              (mapc               #'(lambda (n1 vel)                   (if (not (memq n1 prevch))                     (push (list n1 time curdel vel) poly)                     (let ((event (member n1 poly :test #'(lambda (n e) (= n (car e))))))                       (incf  (caddar event) curdel))))               curch               curvels)              (incf time curdel)              (setf prevch curch))          chseq          vel-list          del-list)    (setf poly (epw::mat-trans (reverse poly)))    (mapcar  #'(lambda (notes dates durs vels)                 (let ((chord (pw::mk-chord  notes durs () vels)))                   (setf (pw::t-time chord) dates)                   chord))             (first poly)             (second poly)             (third poly)             (fourth poly)              )))|#