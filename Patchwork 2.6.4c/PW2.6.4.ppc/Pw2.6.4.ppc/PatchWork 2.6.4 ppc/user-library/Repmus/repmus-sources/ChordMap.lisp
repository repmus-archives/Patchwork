(in-package "repmus");;;;;;            Librairie RepMus;;;;            Gerard Assayag, Claudy Malherbe  © IRCAM 1996           (defun ambitus (chord)  (abs (- (first (first (last chord))) (first (first chord)))))(defun register (chord)  (/ (apply #'+ (mapcar #'first chord)) (length chord)))(defun distance-register (chord1 chord2)  (/ (abs (- (register chord1) (register chord2))) 8400.0))(defun distance-ambitus (chord1 chord2)  (/ (abs (- (ambitus chord1) (ambitus chord2))) 8400))(defun distance-nnotes (chord1 chord2)  (abs (- (length chord1) (length chord2))))(defun distance-freq-amp (chord1 chord2)  (loop for (note1 amp1) in chord1        for (note2 distance) = (closest-freq note1 amp1 chord2)        ;collect (list note1 note2 distance) into notes        sum distance into gdistance        finally return  (/ gdistance (length chord1))))(defun closest-freq (note amp chord)  (loop     with distance = 10000    with rnote = 0    with ramp = 1    for (note1 amp1) in chord    ;for fdist = (mod (abs (- (epw::approx-m note1 8)  (epw::approx-m note 8))) 1200)    ; normalize distance to 7 octaves = 1.    for fdist =  (/ (abs (-  note1 note)) 8400)    do (setf amp1 (max 1 amp1))    if (< fdist distance) do (setf distance fdist rnote note1 ramp amp1)    if (> fdist distance)  do (loop-finish)    finally return (list rnote (/ (* distance ramp) 127.0)))) (defun chord-distance (chord1 chord2 cf ca cr cn)  ;(let ((chord1   (c-get-note-slots::get-note-slots chord1 '(midic vel)))  ;      (chord2 (c-get-note-slots::get-note-slots chord2 '(midic vel))))  (sqrt (+ (expt (* cf (distance-freq-amp chord1 chord2)) 2)           (expt (* ca (distance-ambitus  chord1 chord2)) 2)           (expt (* cr (distance-register  chord1 chord2)) 2)           (expt (* cn (distance-nnotes  chord1 chord2)) 2))))(defunp map-chords ((chs1 object)                    (chs2  object)                    (cf fix>=0 (:value 10))                    (ca fix>=0)                     (cr fix>=0)                     (cn fix>=0)                     (approx approx (:value 2))                     (penal fix>=0 (:value 5))) all-types         "map-chords takes a sequence of chords as a model, and another set of chords as areservoir. Then it picks chords in the reservoir and it builds up a new sequencefrom them, trying to make that sequence look as much as possible like the model.map-chords uses a euclidian distance measure between chords in the reservoir andchords in the model. Dimensions used are : the number of common notes, the ambitus(dist from the bottom to the to of the chord), the register (the gravity center of the chord),the difference in the number of notes. The user has the ability to give a weightingcoefficient for any of these criteria thus influing on the resolution. If O the criterium istotally ignored. Typical values are between 0 and 10.There is also a penalty parameter for chord repetition : if this value is high, a chord cannotbe repeated in the sequence except if its first occurence is very far behind. Values typically between 0 (no penalty) and 10. parameterschs1 : a list of chord-objects or a chord-line. This is the model.chs2 : a list of chord-objects or a chord-line. This is the reservoir.cf : integer, coefficient for common notes criteriaca : integer, coefficient for ambitus criteriacr : integer, coefficient for register criteriacn : integer, coefficient for number of notes criteriaapprox: an integer between 1 and 16. Microtone approximation used in comparisons. 2 = 1/2tone.penal : an integer >=0, penalty value for chord repetitionoutput : a list of chord-objects."  (let ((chseq1 (c-get-note-slots::get-note-slots chs1 '(midic vel)))        (chseq2 (c-get-note-slots::get-note-slots chs2 '(midic vel))))    (when (subtypep (type-of chs1) 'pw::c-chord-line)      (setf chs1 (pw::chords chs1)))    (when (subtypep  (type-of chs2) 'pw::c-chord-line)      (setf chs2 (pw::chords chs2)))    (setf chseq1 (mapcar #'(lambda (chord)                             (mapcar #'(lambda (note) (list (epw::approx-m (first note) approx) (second note)))                                     chord))                         chseq1)          chseq2 (mapcar #'(lambda (chord)                             (mapcar #'(lambda (note) (list (epw::approx-m (first note) approx) (second note)))                                     chord))                         chseq2))    (loop      for chord1 in chseq1      for index1 from 0      with index      with used      do (princ index1) (princ " ")      do (loop for chord2 in chseq2               for index2 from 0               with gdistance = 1e+10               for distance = (chord-distance chord1 chord2 cf ca cr cn)               if (> penal 0.0) do (incf distance  (already-used-weight index2 used (* penal distance)))                if (< distance gdistance)                do (setf gdistance distance index index2) )      do (push index used)       collect  (clone-chord (nth index chs2) (nth index1 chs1)))))(defun already-used-weight (index list factor)  (/ factor (1+ (or (position index list) (- 1e+5 1)))))(defun clone-chord (model t-chord)  (let* ((midics (c-get-note-slots::get-note-slots model 'midic))         (durs (c-get-note-slots::get-note-slots t-chord 'dur))         (vels (c-get-note-slots::get-note-slots t-chord 'vel))         (nnotes (length midics))         (chord (pw::mk-chord                  midics                 (subseq durs 0 (min nnotes (length durs)))                 (list 0)                  (subseq vels 0 (min nnotes (length vels))))))    (setf (pw::t-time chord) (pw::t-time t-chord))    chord));(closest-freq 1000 100 '((250 100) (500 100) (900 100) (1050 100) (2000 100)));        ;(distance-freq-amp '((250 100) (500 100) (900 100) (1050 100) (2000 100));                   '((300.0 100.) (500 50) (900 25) ))