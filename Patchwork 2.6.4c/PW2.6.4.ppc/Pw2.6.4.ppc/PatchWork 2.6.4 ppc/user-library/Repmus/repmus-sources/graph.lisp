(in-package "repmus");;;;;;            Librairie RepMus;;;;            Gerard Assayag, Claudy Malherbe  © IRCAM 1996           ; an alphabet A; a collection S of sequences (S is a subset of A*) (a node list); a mapping r: SxS -> A* (a gweight function); exemple :; A is a set of notes; S is a collection of chords; r (chord1, chord2) -> a-chord-representing-the-common-notes; A is a set of chords; S is a collection of sets of chords; r (set1, set2) -> the-list-of-common-chords; etc.(defclass graph ()  ((node-list :initarg :node-list :accessor node-list :initform ())   (gweight-order-p :accessor gweight-order-p :initform #'<=)   (gweight-min :accessor gweight-min :initform 0)   (gweight-max :accessor gweight-max :initform 1000000)   (build-edge-m :initarg :build-edge-m :accessor build-edge-m :initform 'common-notes)   (gweight-threshold-p :initarg :gweight-threshold-p :accessor gweight-threshold-p                               :initform #'(lambda (gweight) (> gweight 0)))   (traverse-tree-m :initarg :traverse-tree-m :accessor traverse-tree-m :initform 'pre)))(defclass edge ()   ((gsource :initarg :gsource :accessor gsource :initform ())   (gdestination :initarg :gdestination :accessor gdestination :initform ())   (gweight :initarg :gweight :accessor gweight :initform 0)   (content :initarg :content :accessor content :initform ()) )) (defclass node ()  ((graph :initarg :graph :accessor graph :initform ())   (content :initarg :content :accessor content :initform ())   (adj-list :initarg :adj-list :accessor adj-list :initform ())   (father :initarg :father :accessor father :initform ())   (childs :initarg :childs :accessor childs :initform ())   (key :initarg :key :accessor key :initform 0)))(defmethod build-edge ((u node) (v node) (edge-type symbol))  (when (neq u v)    (multiple-value-bind (edge-content edge-gweight)                         (funcall (build-edge-m (graph u)) (content u) (content v))      (when (funcall (gweight-threshold-p (graph u)) edge-gweight)        (let ((edge (make-instance edge-type :gsource u :gdestination v)))          (setf (content edge) edge-content                (gweight edge) edge-gweight)          edge)))))(defmethod graph ((e edge))  (graph (gsource e)))(defmethod initialize-instance ((self graph) &key node-type edge-type node-content)  (call-next-method)  (setf (node-list self)        (mapcar #'(lambda (s)                    (make-instance (or node-type 'node)                      :content s                       :graph self))                node-content))  (mapc #'(lambda (node1)            (mapcar #'(lambda (node2)                        (let ((edge (funcall #'build-edge node1 node2 (or edge-type 'edge))))                          (when edge                            (push edge (adj-list node1)))))                    (node-list self)))        (node-list self))  self  )(defmethod edge ((u node) (v node))  (car (member v (adj-list u) :key #'gdestination)))(defmethod nodes-weight  ((u node) (v node))  (let ((edge (edge u v)))    (if edge (gweight edge) 0))) (defmethod reverse-tree-links ((G graph) (root node))  (let ()    ; (dolist (node (node-list G)) (setf (key node) nil))    (dolist (node (node-list G)) (setf (childs node) nil))    (dolist (node (node-list G))      (when (father node)        (push (cons (key node) node) (childs (father node)) )))    G))(defmethod tree-traversal ((G Graph) (root node) )  (let ((traversal (epw::x-append (tree-traversal-2 G root)                                  (and (eq (traverse-tree-m G) 'pre)                                       root))))    traversal))(defmethod tree-traversal-2 ((G Graph) (root node))  (if (null (childs root))    root    (epw:x-append      (and (memq (traverse-tree-m G)  '(pre full))           root)      (mapcon #'(lambda (child-list)                   (epw:x-append                   (tree-traversal-2 G (cdr (first child-list)))                   (and (memq (traverse-tree-m G)  '(in full))                        (rest child-list)                        root)))              (childs root))             ;(epw::permut-random (copy-list (key root))))     (and (memq (traverse-tree-m G) '(post full))          root))))                  (defmethod traversals ((graph graph) (root node) link &key statmode (root-n 0) (order-p '>=))  (MST-prim graph root)  (reverse-tree-links graph root)  (let ((traversal (tree-traversal graph root)))    (when statmode      (let ((performance (loop for u in traversal                               for v in (rest traversal)                               collect  (nodes-weight u v))))        (format t "~D : ~D~%"  root-n                  (/ (float (apply #'+ performance))                    (if (eq order-p '<=) 1 (+ 1 (count 0 performance)))))))    (setf traversal          (if  (eq link 1)            (mapcar 'content traversal)            (cons (content (first traversal))                  (loop for node in traversal                        for next-node in (rest traversal)                        for weight = (nodes-weight node next-node)                        if (> weight 0) collect (content next-node)                        else collect (ameliorate (content next-node) (content node))))))    (loop for object in traversal          for rest on traversal            if (memq object rest) collect (copy-object object)          else collect object)));; -------------------------------- Minimum Spanning Tree(defun extract-min (queue order)  (let ((min-node (car queue)))    (dolist (u queue)      (when (funcall order (key u) (key min-node))        (setf min-node u)))    min-node))(defmacro pop-min (queue order)  `(let ((minimum (extract-min ,queue ,order)))     (prog1 minimum       (setf ,queue (delete minimum ,queue)))))(defmethod MST-Prim ((a-graph graph) (root node))  (let (u tree (queue (copy-list (node-list a-graph))))    (dolist (u queue)      (setf (key u) (gweight-max a-graph)            (father u) nil))    (setf (key root) (gweight-min a-graph)          (father root) nil)    (while queue      (setf u (pop-min queue (gweight-order-p a-graph)))      (push u tree)      (dolist (uv (adj-list u))        (when (and (memq (gdestination uv) queue)                   (funcall (gweight-order-p a-graph)                            (gweight uv)                            (key (gdestination uv))))          (setf (father (gdestination uv)) u)          (setf (key (gdestination uv)) (gweight uv)))))    tree));------------------ interface PatchWork(defunp make-graph ((coll object (:value '((1) (2)))) &optional (pred object (:value ())) )        all-types"Builds a relation graph between chords in a chord set.The default relation is the amount of common notes between chords. The <pred> inputcan be used to change the relation. 'make-graph' may also be used to relate any kind of datathat you can code into lists of numbers.parameters : coll :     a list of list of midics (or any number) or a list of chord-objects or a chord-line objectpred :     (optional) must be the output of a 'mk-pred' box.result :a graph object. Generally the ouput of 'make-graph' is connected to the 'graph' inputof a 'graph-tour' box."  (let ((closure #'=))    (when pred  (setf closure pred))    (when (subtypep (type-of coll) 'pw::c-chord-line)      (setf coll (pw::chords coll)))    (when (subtypep (type-of (first coll)) 'pw::c-chord)      (setf coll (mapcar #'copy-chords coll))      (mapc #'(lambda (chord) (setf (pw::t-time chord) 0)) coll))    (make-instance 'graph       :node-content coll      :build-edge-m #'(lambda (c1 c2) (com-sub-structure c1 c2 closure))      :gweight-threshold-p #'(lambda (w) (declare (ignore w)) t))))(defunp graph-tour ((graph list (:value nil))                     (solu fix>=0 )                     &optional                     (link menu (:menu-box-list (("no" . 1) ("yes". 2))))                    (order menu (:menu-box-list ((">=" . 1) ("<=". 2))))                    (trav menu (:menu-box-list (("short" . 1) ("long". 2))))                                       (stat menu (:menu-box-list (("norm" . 1) ("stat". 2))))) all-types        "Builds a (quasi-) optimal path between chords that have been organized intoa graph with the box 'make-graph'. If the relation used in make-graph is the amountof common notes, graph-tour delivers a sequence of chords where the amount of commonnotes between successive chords has been maximized (or minimized). There are as many differentsolutions as there are nodes (i.e. chords) in the graph.parametersgraph : the output of a 'make-graph' boxsolu : positive integer. Choose a solution between 0 and n-1 (n is the number of chords)link : (optional, menu) if 'yes' adds a low common note when there is no common notes between 2 chords.order : (optional, menu) if '>=' maximize (default). If '<=' minimize (i.e. get path of maximum contrast).trav : (optional, menu) if 'short' (default) short path without repetitions. If 'long' long path with repetitions.stat : (optional, menu) if 'norm' (default) output the solu(nth) solution. If 'stat' print all the solutions with an optimality factor.outputDepends on the kind objects that have been put into the graph (see 'make-graph') : If the graph was built with a list of lists  of integers, output is a list of lists of integers.If the graph was built with a list of chord-objects or a chord-line object, output is list of chord objects.The output is generally connected to the 'chords' input of a 'chordseq' box."  (let ((root (nth solu (node-list graph)))  order-p traversal-m)    (when  (eq link 0) (setf link 1))    (when (eq order 0) (setf order 1))    (when (eq  trav 0) (setf trav 1))    (setf order-p          (case order (1 '>=) (2 '<=)))    (setf traversal-m          (case trav (1  'pre) (2  'full)))    (case order-p      (<= (setf (gweight-min graph) 0                (gweight-max graph) 1000000))      (>= (setf (gweight-min graph) 1000000                (gweight-max graph) 0)))    (setf (gweight-order-p graph) order-p)    (setf (traverse-tree-m graph) traversal-m)    (cond     ((/= stat 2) (traversals graph root link))     (t      (loop for root-n from 0 upto (1- (length (node-list graph)))            for root in (node-list graph)            for traversal = (traversals  graph root link :statmode t :root-n root-n :order-p order-p)            finally return traversal)))))(defunp mk-pred ((val integer (:value 0)) (tol fix>=0 (:value 0))) all-types ""  (eval   `(let ((delta ,tol) (val ,val))      (function (lambda (x y) (<= (abs (- val (- y x) )) delta))))))(defunp mk-pred ((val integer (:value 0)) (tol fix>=0 (:value 0)) &rest (v integer)) all-types         "This box is used in conjunction with the 'make-graph' box. It defines a predicateused to compare elements in the objects (e.g. chords) put into the graph. Each element x (e.g. note)of each object (e.g. chord) is compared to each element y of every other object. Then (y-x) is compared for equality to the parameter <val>, with the tolerance <tol>.Thus, for <val> = 0 and <tol> = 0, strict equality (e.g. common notes relation) is seek.For <val> = 100, hal-tone upward step relation is seek. If <tol> = 25, then a quarter tonetolerance is allowed. If you build a graph using 'make-graph' with these values, then find an optimal pathusing 'graph-tour', what you get is a chord sequence where there is a maximum number of half-tone stepsbetween 2 consecutive chords, with a quarter tone tolerance.If you add optional arguments (as many as you like), these values will be used to complexify the relation.For instance, with <val> = 300, <opt-arg1> = 400, <opt-arg2> = 700,the optimisation will be : 'find a sequence where consecutive chords have the max amount of minor 3rd, major 3rd andperfect 5th upward steps.'parametersval : integer, value to be compared with the difference between notes of chords.tol : integer, allowed deviation in the former comparison.arg : (optional, integer) additional value to be used like <val>outputa predicate function object to be connected to the 'pred' input of a 'make-graph' box."  (eval   `(function (lambda (x y)                 (or                   ,. (mapcar #'(lambda (value) `(<= (abs (- ,value (- y x) )) ,tol))                            (cons val v)))))))                      ; ------------------- Application sur les objets sonores (defmethod com-sub-structure ((s1 list) (s2 list) (inter-p function))   (let ((inter (epw::x-intersect  s1 s2 inter-p)))    (values inter (length inter))))(defmethod com-sub-structure ((s1 pw::c-chord) (s2 pw::c-chord) (inter-p function))  (let ((inter (epw::x-intersect                (c-get-note-slots:get-note-slots s1 'midic)                (c-get-note-slots:get-note-slots s2 'midic)                inter-p)))    (values inter (length inter))))(defmethod ameliorate ((s1 list) (s2 list))  (cons (apply #'min s2) s1) )(defmethod ameliorate ((s1 pw::c-chord) (s2 pw::c-chord))  (pw::mk-chord     (ameliorate  (c-get-note-slots:get-note-slots s1 'midic)                (c-get-note-slots:get-note-slots s2 'midic))   (cons (first (c-get-note-slots:get-note-slots s2 'dur))         (c-get-note-slots:get-note-slots s2 'dur))   ()   (cons (first (c-get-note-slots:get-note-slots s2 'vel))         (c-get-note-slots:get-note-slots s2 'vel))))(defun eq-mod-12 (x y) (= (mod x 1200) (mod y 1200)))(defun mk-joint-step (i-min i-max)  #'(lambda (x y)      (and (<= (abs (- x y)) i-max)           (>= (abs (- x y)) i-min)))); ------------------- chord utilities#|(defunp chseq->poly ((chseq list (:value "(6000)" :type-list (list  chord pw::collector)))                     (del fix>0) (approx approx)) list         "Converts a sequence of chords in a pseudo polyphony where common notesbetween two chords are changed into a single sustained note (harmonic link).chseq is a list of chords-objects or midics sublists.del defines the time interval between two chords.approx (1, 2, 4, 8) tells the approximation used for finding common notes.Outputs a list of chord objects suitable for input to a chordseq module."    (let ((time 0) (dur del) prevch  poly vel-list)    (when (subtypep (type-of chseq)'pw::c-chord-line)      (setf chseq (pw::get-slot chseq 'pw::chords)))    (when (consp chseq)      (if (consp (car chseq))        (setf vel-list            (mapcar #'(lambda (midics)                        (make-list (length midics) :initial-element 100))                    chseq))        (when (subtypep (type-of (car chseq)) 'pw::c-chord)          (setf vel-list (c-get-note-slots:get-note-slots chseq 'vel)                chseq (c-get-note-slots:get-note-slots chseq 'midic)))))    (setf chseq (epw::approx-m chseq approx)          prevch (make-list (length (car chseq)) :initial-element 0))    (mapc #'(lambda (curch curvels)              (mapc               #'(lambda (n1 vel)                   (if (not (memq n1 prevch))                     (push (list n1 time dur vel) poly)                     (let ((event (member n1 poly :test #'(lambda (n e) (= n (car e))))))                       (incf  (caddar event) del))))               curch               curvels)              (incf time del)              (setf prevch curch))          chseq          vel-list)    (setf poly (epw::mat-trans (reverse poly)))    (mapcar  #'(lambda (notes dates durs vels)                 (let ((chord (pw::mk-chord  notes durs () vels)))                   (setf (pw::t-time chord) dates)                   chord))             (first poly)             (second poly)             (third poly)             (fourth poly)              )))|#(defunp chseq->poly ((chseq list (:value "((6000))" :type-list (list  chord pw::collector)))                     (del fix>0 (:value 50))                      (approx approx (:value 2))) list                "Changes a sequence of chords in a polyphony where common notesbetween two chords are changed into a single sustained note (harmonic link).parameters : chseq  :  a list of list of midics, or a list of chord-objects or a chord-line object.del : positive integer, defines the time interval between two chords.approx : integer (1, 2, 4, 8) tells the approximation used for finding common notes.output : A list of chord objects suitable for input to a chordseq module."  (let ((time 0)  prevch  poly vel-list del-list)    (when (subtypep (type-of chseq)'pw::c-chord-line)      (setf chseq (pw::get-slot chseq 'pw::chords)))    (when (consp chseq)      (if (consp (car chseq))        (setf vel-list              (mapcar #'(lambda (midics)                          (make-list (length midics) :initial-element 100))                      chseq)              del-list (make-list (length chseq) :initial-element del))        (when (subtypep (type-of (car chseq)) 'pw::c-chord)          (if (some  #'(lambda (chord) (not (zerop (pw::t-time chord)))) chseq)            (setf del-list  (pw::x->dx (pw::get-slot chseq 't-time )))            (setf del-list (make-list (length chseq) :initial-element del)))          (setf vel-list (c-get-note-slots:get-note-slots chseq 'vel)                chseq (c-get-note-slots:get-note-slots chseq 'midic)))        ))    (setf chseq (epw::approx-m chseq approx)          prevch (make-list (length (car chseq)) :initial-element 0))    (mapc #'(lambda (curch curvels curdel)              (mapc               #'(lambda (n1 vel)                   (if (not (memq n1 prevch))                     (push (list n1 time curdel vel) poly)                     (let ((event (member n1 poly :test #'(lambda (n e) (= n (car e))))))                       (incf  (caddar event) curdel))))               curch               curvels)              (incf time curdel)              (setf prevch curch))          chseq          vel-list          del-list)    (setf poly (epw::mat-trans (reverse poly)))    (mapcar  #'(lambda (notes dates durs vels)                 (let ((chord (pw::mk-chord  notes durs () vels)))                   (setf (pw::t-time chord) dates)                   chord))             (first poly)             (second poly)             (third poly)             (fourth poly)             )))(defunp copy-chords ((chords object)) nil        "Deep copies a chord or chord list or chord sequence.Very useful to overcome some of PatchWork board-effects on chords (i.e. editing a chordinside some editor causes a change in an other editor...)parameters : chords : a chord (in midics or object form) or a list of same, or a chord-line object.output : same type as input."  (if (and (listp chords) (subtypep (type-of (first chords)) 'pw::c-chord))    (mapcar #'copy-object chords)    (copy-object chords)))(defmethod copy-object ((chord pw::c-chord))   (let ((midics (c-get-note-slots:get-note-slots chord 'midic))        (durs (c-get-note-slots:get-note-slots chord 'dur))        (offsets (c-get-note-slots:get-note-slots chord 'offset))        (vels (c-get-note-slots:get-note-slots chord 'vel))        (chans (c-get-note-slots:get-note-slots chord 'chan))        (order (c-get-note-slots:get-note-slots chord 'order)))      (let ((new-chord (pw::mk-chord midics durs offsets vels chans order)))        (setf (pw::t-time new-chord) (pw::t-time chord))        new-chord)))(defmethod copy-object ((chordseq pw::c-chord-line))  (make-instance 'pw::c-chord-line     :chords (mapcar #'copy-object (pw::chords chordseq))))(defmethod copy-object ((list list))  (copy-list list))