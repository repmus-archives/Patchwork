;;;;;;Arc Consistency (Forward Checking) with Hierarchical domains;;;;;; By C. Rueda (c) IRCAM 921203;;;;;;  Constraints: Problem specific: rhythmic patterns computation;;;(in-package "HD-CONSTRAINTS")(defvar *rhythmic-units-allowed* )(defvar *rhythmic-units-starts*)(defvar *max-local-numvars*)(defvar *global-rhythmic-units*)(defvar *num-items-range*)(defvar *allowed-groupings*);;;;=============================;;;;Utilities(defun get-max-local-numvars ()  (ceiling (apply 'max *global-rhythmic-units*) (apply 'min *rhythmic-units-allowed*)))(defun relative-index (index) (mod index *max-local-numvars*))(defun global-proportion (index) (or (nth (floor index *max-local-numvars*)                                          *global-rhythmic-units*) (first (last *global-rhythmic-units*))))(defun sum-of-proportions (relative-index patterns)  (let* ((accum 0)         (length (length patterns))         (upto (if (> (1- relative-index) length) length (1- relative-index))))    (dolist (unit (subseq patterns 0 upto) accum)      (incf accum (abs unit)))))(defun multiple-proportions? (relative-index unit patterns)  (let ((sum-prop (+ (abs unit) (sum-of-proportions relative-index patterns))))  (or (integerp sum-prop) (is-a-multiple? sum-prop *rhythmic-units-allowed*))))(defun number-of-notes (relative-index patterns)  (let* ((accum 0)         (length (length patterns))         (upto (if (> (1- relative-index) length) length (1- relative-index))))    (dolist (unit (subseq patterns 0 upto) accum)      (when (note? unit) (incf accum))      )))(defun number-of-groups (relative-index patterns)   (let* ((accum 0) (new t)         (length (length patterns))         (upto (if (> (1- relative-index) length) length (1- relative-index))))    (dolist (unit (subseq patterns 0 upto) accum)      (if (and (note? unit) new)        (progn (setq new nil) (incf accum))        (when (silence? unit) (setq new t))      ))));(number-of-groups 13 '(1/3 1/3 -1/3 -1/3 -1/3 -1/3 -1/2 -1/2 -1/4 -1/4 -1/4 1/4))(defun is-a-multiple? (value list)  (dolist (base list nil)    (when (integerp (/ value base)) (return t))))(defun form-rhythm-domain ()  (let ((res '(0)))    (dolist (unit *rhythmic-units-allowed* res)      (push unit res))))(defun no-duration? (unit) (zerop unit))(defun silence? (unit) (minusp unit))(defun note? (unit) (plusp unit))(defun max-num-notes (index)   (second (or (nth (floor index *max-local-numvars*) *num-items-range*)              (first (last *num-items-range*)))))(defun possible-notes (duration global)  (floor (- global duration) (apply 'min *rhythmic-units-allowed*)))(defun min-possible-notes? (current-duration num-notes index)  (>= (+ num-notes (possible-notes current-duration (global-proportion index)))     (first (or (nth (floor index *max-local-numvars*) *num-items-range*)                (first (last *num-items-range*))))))(defun same-group? (index1 index2)  (= (floor index1 *max-local-numvars*) (floor index2 *max-local-numvars*)))(defun max-number-groups (range) (second range))(defun min-number-groups (range) (first range))(defun grouping-allowed (index) (nth (floor index *max-local-numvars*) *allowed-groupings*))(defun within-group-range? (range number)  (and (>= number (min-number-groups range)) (<= number (max-number-groups range))));;;;===============================;;;; Constraints(defun check-unit (tx sx unit &rest patterns)  (declare (ignore sx))  (let ((relative-index (relative-index tx) ))    (cond ((no-duration? unit) (= (global-proportion tx)                                  (sum-of-proportions relative-index patterns)))          (t (and (multiple-proportions? relative-index unit patterns)                  (<= (+ (abs unit) (sum-of-proportions relative-index patterns))                      (global-proportion tx)))))))(defun check-global-unit-filled (tx sx unit &rest patterns)  (declare (ignore sx))  (= (global-proportion (1- tx))     (+ (abs unit) (sum-of-proportions (1+ (relative-index (1- tx))) patterns))))(defun define-rhythm-constraints ()  (setf *problem-constraints*        (list           (make-HD-constraint           :choose-pred #'(lambda (tx sx) (and (= (- tx sx) 1) (same-group? tx sx)))          :test-level 0           :source-vars (arithm-ser 0 1 (- *max-local-numvars* 2))          :predicate #'check-unit)         (make-HD-constraint           :choose-pred #'(lambda (tx sx)                          (and (= (- tx sx) 1) (zerop (mod tx *max-local-numvars*))))          :test-level 0           :source-vars (arithm-ser 0 1 (- *max-local-numvars* 2))          :predicate #'check-global-unit-filled))));;;;===================;;;; Exploration display & solutions saving;;a function to call when a solution is found(defun rhythm-succeed (d &optional n alpha user-alpha)  (declare (ignore n alpha user-alpha))  (push (remove 0 (nicely-put d *num-vars*)) *all-solutions*)  (or (> (length *all-solutions*) *max-num-solns*)      (progn (print "une!!!") nil)));;a function to accumulate partial results(defvar *partial-results* ())(defun rhythm-accumulate (k value &optional alpha)  (declare (ignore alpha))  (let ((length (length *partial-results*)))    (if (<= k length)      (setf (nth (- length k) *partial-results-save*) value)      (progn (push value *partial-results-save*)             (setf *partial-results* (mapcar #'nicely-put *partial-results-save*))))));;a function to display number of chords found(defun rhythm-display-process (k value &optional alpha)  (declare (ignore value alpha))  (if (zerop (mod k *max-local-numvars*))     (format t "units: ~S ~%" (floor k *max-local-numvars*))))#|(pw::defunp part-sols ()list " "   ;;(nreverse (mapcar #'nicely-put *partial-results*)))  (reverse *partial-results*))|#;;;;================================;;;; PW interface(pw:defunp rhythm-constraints           ((n-solutions fix>0 (:view-size #@(80 14)))            (n-units fix>0 (:view-size #@(80 14)))            (units list (:view-size #@(80 14) :value '(4)))            (valid-divisions list (:view-size #@(80 14) :value '(1/2 1/4)))) list " Rhythmic pattern calculation by constraints satisfaction"  (setf *global-rhythmic-units* units        *rhythmic-units-allowed* valid-divisions        *max-local-numvars* (get-max-local-numvars)        *max-num-solns* (1- n-solutions)        *partial-results* nil *partial-results-save* nil        *all-solutions* nil *done-for-user* nil)  (setf *num-vars* (* n-units *max-local-numvars*))  (define-rhythm-constraints)  (setf *max-advance* (get-max-advance ()))  (setf *domains* (make-array (list (1+  *num-vars*))))  (do ((index 1 (1+ index))) ((> index *num-vars*))    (setf (aref *domains* index)          (make-AB2-leaf (permut-random (form-rhythm-domain)))))  (time   (progn     (HD-AC5-consistency *problem-constraints* *domains* *num-vars* *max-advance*)     (print "exploring...")     (soft-constr::soft-forward-check *problem-constraints* *domains* *num-vars*              :succeed-fun #'rhythm-succeed :accum-fun #'rhythm-accumulate              :display-fun #'rhythm-display-process :advance *max-advance*)))  *all-solutions*);;;MCM to be (highly!) optimized(defun mcm (list)  (let ((min (apply 'min list)))    (labels ((iter (num)               (if (every #'integerp (mapcar #'(lambda (x) (/ num x)) list))                 num                 (iter (+ num min)))))      (iter min))))(defun simplify-rhythm (base denom list)  (let* ((unsimplified (mapcar #'(lambda (item) (* item denom)) list))         (sum (reduce #'(lambda (x y) (+ (abs x) (abs y))) unsimplified))  ;;(apply '+ unsimplified))         (div (floor sum base)))    (if (and (/= base 1) (zerop (mod sum base)))      (let ((accum 0) subrhythm result unit sign)        (dolist (r-unit unsimplified)          (setq unit (abs r-unit) sign (/ unit r-unit))          (cond ((> (+ unit accum) div)                 (push (nreverse (cons (* sign (- div accum)) subrhythm)) result)                 (setq subrhythm (if (minusp sign)                                   (list (- (+ unit accum (- div))))                                   (list (float (+ unit accum (- div)))))                       accum 0))                ((= (+ unit accum) div)                 (push (nreverse (cons r-unit subrhythm)) result)                 (setq subrhythm nil accum 0))                (t (progn (push r-unit subrhythm) (incf accum unit)))))        (and subrhythm (push (nreverse subrhythm) result))        (mapcar #'(lambda (beat) (list 1 beat)) (nreverse result)))      (list(list base unsimplified)))))(pw::defunp construct-rhythm ((rhythm list)) list "forms a tree expression representing the given rhythmic proportionsin a format suitable to be input to an rtm box."  (let (res one-solution accum partial)    (dolist (solution rhythm (nreverse res))      (setq one-solution nil partial nil accum 0)      (push       (dolist (unit solution (apply 'append (nreverse one-solution)))        (incf accum (abs unit))        (push unit partial)        (when (integerp accum)          (let ((denom (mcm (mapcar #'denominator partial))))            (push (simplify-rhythm accum denom (nreverse partial)) one-solution)            ;;(push (list accum (mapcar #'(lambda (item) (* item denom)) (nreverse partial)))            ;;      one-solution)            )          (setq accum 0 partial nil)))       res))))(pw::defunp dist-into-units ((units list) (list list)) list "Takes in <list> the output of a rhythm-constraints box. Groups the elements (duration proportions) in the list into sublists adding up to a the sizes given in <units>"  (let (groups a-group (accum 0))    (dolist (unit list (nreverse groups))      (if (= (car units) (incf accum unit))        (progn (pop units)               (push (nreverse (cons unit a-group)) groups)               (setq a-group nil accum 0))        (push unit a-group)))))(pw::defunp random2 ((low fix/float) (high fix/float)) number  "Returns a random value between low high inclusive"  (if (zerop (- high low))    (+ high low (- low))    (let ((low-min (min low high)))      (if (or (floatp  low) (floatp high))        (+ (random (- (max low high) low-min)) low-min)        (+ (random (- (1+ (max low high)) low-min)) low-min)))))(defun put-in-silences (groups)  (let (res test)    (do ((subgroup groups subgroup)) ((not (rest subgroup)) (nreverse (cons (first subgroup) res)))      (setq test             (cond ((= (length (first subgroup)) 1) nil)                  ((= (length (second subgroup)) 1) t)                  (t (zerop (random2 0 1)))))      (if test        (push (nreverse (cons (- (first (last (first subgroup)))) (nreverse (butlast (pop subgroup)))))              res)        (progn (push (pop subgroup) res)               (push (cons (- (first (first subgroup))) (rest (pop subgroup))) subgroup))))))(pw::defunp groups-per-unit ((groups list) (ranges list)) list "<groups> gets the output of a dist-into-unit box. Divides each unitin <groups> into a number of groups taken from the range given inthe corresponding element of <ranges>. Groups are separated by silences. "  (let (res num)    (dolist (group groups (nreverse res))      (setq num (random2 (first (first ranges)) (second (pop ranges))))      (push        (if (= num 1)         (list group)         (put-in-silences          (pw::list-explode group num)  ) )         res))))(defun all-with-one-note? (list)  (every #'(lambda (item) (= 1 (number-of-notes (length item) item))) list))(defun fix-num-notes (groups number)  (let ((flat-group (apply #'append groups))        (list (copy-list groups))        (length (1- (length groups)))        item chosen)    (do ((diff-notes (-  (number-of-notes (length flat-group) flat-group) number) diff-notes))        ((or (zerop diff-notes) (all-with-one-note? list)) list)      (setq item (random2 0 length) chosen (nth item list))      (unless (= 1 (number-of-notes (length chosen) chosen))        (setf (nth item list) (remove-one-note chosen))        (decf diff-notes)))))      (defun remove-one-note (list)  (let* ((copy (copy-list list))        (from-end? (plusp (random2 0 1)))        (position (position-if #'plusp copy :from-end from-end?))        (element (- (nth position copy))))    (setf (nth position copy) element)    copy))(pw::defunp notes-per-unit ((groupings list) (ranges list)) list "<groupings> gets the output of a groups-per-unit box. Modifies each  UNIT so that the number of non-silence elements is within therange given in the corresponding list position of <ranges>"  (let (res min-notes flat-group)    (dolist (group groupings (nreverse res))      (setq min-notes (max (length group) (random2 (first (first ranges)) (second (pop ranges)))))      (setq flat-group (apply #'append group))      (if (>= min-notes (number-of-notes (length flat-group) flat-group))        (push group res)        (push (fix-num-notes group min-notes) res)))))(defun add-note-left (group)  (add-to-position group (1- (position-if #'plusp group))))(defun add-note-right (group)  (add-to-position group (1+ (position-if #'plusp group :from-end t))))(defun add-to-position (group position)  (let ((element (- (nth position group))))    (setf (nth position group) element)))(defun no-right? (group index groups)  (or (note? (first (last group)))                       (and (note? (first (last (butlast group)))) (nth (1+ index) groups)                            (note? (first (nth (1+ index) groups))))))(defun no-left? (group index groups)  (or (note? (first group))                      (and (note? (second group)) (> index 0)                           (note? (first (last (nth (1- index) groups)))))))(defun add-notes-to-group (groups index notes)  (do* ((group (nth index groups) (nth index groups))         (no-right (no-right? group index groups) (no-right? group index groups))        (no-left (no-left? group index groups) (no-left? group index groups)))       ((or (and no-right no-left) (zerop notes)) notes)      (cond (no-right (add-note-left group))            (no-left (add-note-right group))            (t (if (zerop (random2 0 1))                  (add-note-left group)                 (add-note-right group))))      (decf notes)))(defun fix-notes/group (groups notes)  (do ((index-min) (notes-changed)) ((not (plusp notes)))    (multiple-value-bind (index max-notes) (get-max-notes-group groups)      (if (< notes max-notes)        (progn          (setq index-min (find-maximum-silences groups))          (setf (nth index groups) (first (fix-num-notes (list (nth index groups)) notes)))          (setq notes-changed (add-notes-to-group groups index-min (- max-notes notes)))          (cond ((= notes-changed (- max-notes notes))                 (warn "cannot find a solution compatible with max-notes/group") (ed-beep) (return groups))                ((zerop notes-changed) (return groups))))        (return groups)))))(defun find-maximum-silences (groups)  (let ((silences (mapcar #'(lambda (group) (count-if #'minusp group)) groups)))    (position (apply 'max silences) silences)))(defun get-max-notes-group (groups)  (let* ((notes (mapcar #'(lambda (group) (count-if #'plusp group)) groups))         (max (apply 'max notes)))    (values (position max notes) max)))        (pw::defunp notes-per-group ((list list) (max-notes list)) list "<list> gets the output of a notes-per-unit box. Modifies each  GROUP so that the number of non-silence elements is less thanor equal to the value given in the corresponding list position of <max-notes>"  (let (res)    (do* ((sublists (copy-list list) (rest sublists)) (count 0 (1+ count))         (groups (first list) (first sublists)))        ((not sublists) (nreverse res))      (push (fix-notes/group groups (or (nth count max-notes) (first (last max-notes))))            res))))(pw::defunp replace-unit ((list list) (select list) (new list)) list "Replaces values of <list> in positions given by <select> by  valuestaken successively from <new>. Used to replace measures for an rtm"  (let ((list (copy-list list)) (new (pw::list! new)))    (dolist (item (pw::list! select))      (setf (nth item list) (pop new)))    list))(pw::defunp total-notes ((list list)) list "returns the total number of non-negative elements in <list>. Usedto compute the number of beats (different from silences) in a sequence"  (mapcar #'(lambda (solution) (count-if #'plusp solution)) list)) (pw::pw-addmenu *rhythm-menu* '(rhythm-constraints construct-rhythm total-notes dist-into-units                                 groups-per-unit notes-per-unit notes-per-group))          