;;;;;;Arc Consistency (Forward Checking) with Hierarchical domains;;;;;; By C. Rueda (c) IRCAM 921203;;;;;;  Constraints Class definition;;;(in-package "HD-CONSTRAINTS")(defclass C-constraint ()  ((rule-name :initform "constraint" :initarg :rule-name :accessor rule-name)    (predicate :initform #'always-true :initarg :predicate :accessor predicate)   (target-var-ix :initform 1 :initarg :target-var-ix :accessor target-var-ix)   (source-var-ix :initform 1 :initarg :source-var-ix :accessor source-var-ix)   (all-var-vals :initform nil :initarg :source-var-vals :accessor all-var-vals)   (necessity-degree :initform 1 :initarg :necessity-degree :accessor  necessity-degree)   (now-satisfied? :initform nil :accessor now-satisfied?)   ))(defun make-constraint (&rest others &key (class 'C-constraint)                               predicate target-var source-vars                             &allow-other-keys)  (apply #'make-instance class :predicate predicate :target-var-ix target-var                 :source-var-ix source-vars :allow-other-keys t others))(defmethod initialize-instance :after ((self C-constraint) &key keys)  (declare (ignore keys))  (setf (all-var-vals self) (make-list (1+ (length (source-var-ix self))))))(defmethod enabled? ((self C-constraint) tx sx &optional domain-collection)  (and (= tx (target-var-ix self) (all-instanciated? self sx domain-collection) self)))(defmethod all-instanciated? ((self C-constraint) sx &optional domain-collection)  (declare (ignore sx))  (dolist (source (source-var-ix self) t)    (unless (singleton-instance? domain-collection source) (return nil))))(defmethod full-consistency ((self C-constraint) tx sx domain-collection)  (declare (ignore tx sx self domain-collection))  (values nil nil))(defmethod local-consistency ((self C-constraint) tx sx value domain-collection)  (declare (ignore tx sx value domain-collection))  nil)(defmethod arc-consistency ((self C-constraint) tx sx &optional domain-collection)    (set-source-var-vals self sx domain-collection)    (filter-constraint-domains self tx sx domain-collection))(defmethod set-source-var-vals ((self C-constraint) sx domain-collection)  (setf (rest (all-var-vals self)) (get-source-in-domain self sx  domain-collection)))(defmethod get-source-in-domain ((self C-constraint) sx domain-collection)  (declare (ignore sx))  (mapcar #'(lambda (var) (get-current-instance domain-collection var))          (source-var-ix self)))#|(defmethod filter-constraint-domains ((self C-constraint) tx sx domain-collection)  (filter-domain (all-domain-of domain-collection tx)                 #'(lambda (t-value)                     (setf (first (all-var-vals self)) t-value)                     (apply (predicate self) tx sx (all-var-vals self)))                 self))|#(defmethod filter-constraint-domains ((self C-constraint) tx sx domain-collection)  (if (or (< (- 1 (necessity-degree self)) soft-constr::*beta*)          (= (necessity-degree self) 1))    (progn      (filter-domain (all-domain-of domain-collection tx)                   #'(lambda (t-value)                       (setf (first (all-var-vals self)) t-value)                       (apply (predicate self) tx sx (all-var-vals self)))                   self)      (setf (now-satisfied? self) t))    (setf (now-satisfied? self) (satisfied? self tx sx domain-collection))))(defmethod satisfied? ((self C-constraint) tx sx domain-collection &optional node)  (declare (ignore node))  (set-source-var-vals self sx domain-collection)  (setf (first (all-var-vals self)) (get-current-instance domain-collection tx))  (apply (predicate self) tx sx (all-var-vals self)))(defmethod filter-unary ((self C-constraint) tx domain-collection)  (all-domain-of domain-collection tx))                       ;;;range constraints(defclass C-range-constraint (C-constraint)  ((choose-pred :initform #'always-true :initarg :choose-pred :accessor choose-pred)))(defun make-range-constraint (&rest others &key choose-pred                                    (class 'C-range-constraint)                                   &allow-other-keys)  (apply #'make-constraint :class class :choose-pred choose-pred         :allow-other-keys t others))(defmethod enabled? ((self C-range-constraint) tx sx &optional domains)  (declare (ignore domains))  (and (funcall (choose-pred self) tx sx) self))(defmethod get-source-in-domain ((self C-range-constraint) sx domain-collection)  (let* ((vars (source-var-ix self))   (-length (- (apply 'max vars)))         res)    (dolist (var vars res)      (when (plusp (+ var sx -length))        (push (get-current-instance domain-collection (+ var sx -length)) res)))));;hierarchical domains constraints(defclass C-HD-constraint (C-range-constraint)  ((test-level :initform 0 :initarg :test-level :accessor test-level)   (HD-predicate :initform ()  :accessor HD-predicate)   (tx :initform 0 :accessor tx)   (sx :initform 0 :accessor sx)))(defun make-HD-constraint (&rest others &key (test-level 0) (class 'C-HD-constraint)                                   &allow-other-keys)  (apply #'make-constraint :class class :test-level test-level         :allow-other-keys t others))(defvar *filter-node-pred* #'(lambda (node) (not (not-in-domain? node))))(defmethod satisfied? ((self C-HD-constraint) tx sx domain-collection &optional node)  (set-source-var-vals self sx domain-collection)  (setf (first (all-var-vals self)) (form-tree-values node))  (apply (predicate self) tx sx (all-var-vals self)))(defmethod filter-constraint-domains ((self C-HD-constraint) tx sx domain-collection)  (let* ((root-tree (all-domain-of domain-collection tx))         (the-nodes (get-nodes-at-depth root-tree (test-level self)                                          *filter-node-pred*))           pred)    (if (or (< (- 1 (necessity-degree self)) soft-constr::*beta*)            (= (necessity-degree self) 1))            (progn        (setq pred              (let ((to tx) (from sx) (vars (rest (all-var-vals self))))                #'(lambda (t-value)                    (apply (predicate self) to from t-value vars))))        (setf (now-satisfied? self) t)         (do ((trees the-nodes (rest trees))) ((null trees))          (unless (not-in-domain? (filter-deep (first trees) pred self))            (return (progn (tell (rest trees) #'filter-domain pred self) t)))))        (setf (now-satisfied? self)              (and the-nodes (satisfied? self tx sx domain-collection (first the-nodes)))))    root-tree)  );;a user defined constraint(defclass C-user-constraint (C-HD-constraint)  ((advance :initform 2 :initarg :advance :accessor advance)))(defun make-user-constraint (&rest others &key (test-level 0) (class 'C-user-constraint)                                   &allow-other-keys)  (apply #'make-constraint :class class :test-level test-level         :allow-other-keys t others))(defmethod get-source-in-domain ((self C-user-constraint) sx domain-collection)  (let (res)    (dotimes (i sx res)      (push (get-current-instance domain-collection (1+ i)) res))));;;Unary constraint(defclass C-full-unary-const (C-HD-constraint) ())(defun make-full-unary-constraint (&rest others &key (class 'C-full-unary-const)                             &allow-other-keys)  (apply #'make-HD-constraint :class class :source-var-ix nil         :allow-other-keys t others))(defmethod filter-unary ((self C-full-unary-const) tx domain-collection)  (filter-constraint-domains self tx tx domain-collection))(defmethod arc-consistency ((self C-full-unary-const) tx sx &optional domain-collection)  (declare (ignore sx))  (all-domain-of domain-collection tx))(defmethod satisfied? ((self C-full-unary-const) tx sx domain-collection &optional node)  (declare (ignore tx sx domain-collection node))  t);;full AC4-constraints (binary only)(defclass C-full-const (C-HD-constraint) ())(defun make-full-constraint (&rest others &key (class 'C-full-const)                             &allow-other-keys)  (apply #'make-HD-constraint :class class         :allow-other-keys t others))(defun full-domain-values (node-list)  (mapcan #'(lambda (node) (get-all-domain node)) node-list))(defmethod cycle-full-domain ((self C-full-const) tx sx tx-nodes sx-nodes dir)  (let (res)    (do* ((sx-values (full-domain-values sx-nodes) (rest sx-values))         (sx-val (first sx-values) (first sx-values))) ((not sx-values) res)      (unless        (do* ((tx-values (full-domain-values tx-nodes) (rest tx-values))              (tx-val (first tx-values) (first tx-values))) ((not tx-values))          (when (if dir (funcall (predicate self) tx sx tx-val sx-val)                    (funcall (predicate self) tx sx sx-val tx-val))            (return t)))        (do ((sub-sx-nodes sx-nodes (rest sub-sx-nodes))) ((not sub-sx-nodes))          (remove-from-domain (first sub-sx-nodes) sx-val))        (push sx-val res)))))(defmethod full-consistency ((self C-full-const) tx sx domain-collection)  (let ((sx-nodes (get-nodes-at-depth (all-domain-of domain-collection sx)                                       (test-level self) *filter-node-pred*))         (tx-nodes (get-nodes-at-depth (all-domain-of domain-collection tx)                                       (test-level self) *filter-node-pred*)))    (values (cycle-full-domain self tx sx tx-nodes sx-nodes t)            (progn (setq sx-nodes (remove-if-not *filter-node-pred* sx-nodes))                   (cycle-full-domain self tx sx sx-nodes tx-nodes nil)))))(defmethod local-consistency ((self C-full-const) from to value domain-collection)  (declare (ignore value))    (if (> to from)      (cycle-full-domain self to from                          (get-nodes-at-depth (all-domain-of domain-collection to)                                             (test-level self) *filter-node-pred*)                         (get-nodes-at-depth (all-domain-of domain-collection from)                                             (test-level self) *filter-node-pred*)   t)      (cycle-full-domain self from to                          (get-nodes-at-depth (all-domain-of domain-collection from)                                             (test-level self) *filter-node-pred*)                         (get-nodes-at-depth (all-domain-of domain-collection to)                                             (test-level self) *filter-node-pred*)   nil)));;monotone constraints (binary only)(defclass C-monotone-const (C-HD-constraint)  ((left-cut-point :initform () :initarg :left-cut-point :accessor left-cut-point)   (right-cut-point :initform () :initarg :right-cut-point :accessor right-cut-point)))(defun make-monotone-constraint (&rest others &key (class 'C-monotone-const)                             &allow-other-keys)  (apply #'make-HD-constraint :class class         :allow-other-keys t others))(defun accumulate-unsupported-vals (nodes pred)  (let (res)    (dolist (node nodes)      (dolist (val (get-all-domain node))        (unless (funcall pred val)           (push val res)          (remove-from-domain node val))))    res))(defmethod full-consistency ((self C-monotone-const) tx sx domain-collection)  (let* ((sx-nodes (get-nodes-at-depth (all-domain-of domain-collection sx)                                       (test-level self) *filter-node-pred*))         (tx-nodes (get-nodes-at-depth (all-domain-of domain-collection tx)                                       (test-level self) *filter-node-pred*))         (tx-cut (funcall (right-cut-point self) (full-domain-values tx-nodes)))         (sx-res          (accumulate-unsupported-vals sx-nodes                    #'(lambda (value) (funcall (predicate self) tx sx tx-cut value))))         tx-res sx-values)    (setq sx-nodes (remove-if #'not-in-domain? sx-nodes))    (if sx-nodes        (progn          (setq sx-values (full-domain-values  sx-nodes)                tx-res                (and sx-values                     (accumulate-unsupported-vals tx-nodes                        #'(lambda (value)                             (funcall (predicate self) tx sx value                                      (funcall (left-cut-point self) sx-values))))))          (if (remove-if #'not-in-domain? tx-nodes)            (values sx-res tx-res)  (values t t)))        (values t t))))(defmethod local-consistency ((self C-monotone-const) from to value domain-collection)  (declare (ignore value))  (let ((sx-nodes (get-nodes-at-depth (all-domain-of domain-collection from)                                       (test-level self) *filter-node-pred*))         (tx-nodes (get-nodes-at-depth (all-domain-of domain-collection to)                                       (test-level self) *filter-node-pred*)))    (if (> to from)      (let ((tx-cut (funcall (right-cut-point self) (full-domain-values tx-nodes))))        (accumulate-unsupported-vals sx-nodes                         #'(lambda (value) (funcall (predicate self) to from tx-cut value))))      (let ((sx-cut (funcall (left-cut-point self) (full-domain-values sx-nodes))))        (accumulate-unsupported-vals tx-nodes                         #'(lambda (value) (funcall (predicate self) from to value sx-cut)))))))        ;;======================================;;problem specific: How to filter a PB-1 leaf(defclass C-leaf-AB1 (C-tree-domain)   ((leaf-predicate :initform () :allocation :class :accessor leaf-predicate)))(defun make-AB1-leaf (domain &rest keys &key (class 'C-leaf-AB1) &allow-other-keys)  (apply #'make-tree-domain :class class         :tree-data domain :allow-other-keys t keys))(defmethod form-leaf-value ((self C-leaf-AB1) value)  value)(defmethod get-value ((self C-leaf-AB1)) (delay-first (tree-data self)))(defmethod copy-leaf ((self C-leaf-AB1))  (make-ab1-leaf (tree-data self)  ;;(copy-domain (tree-data self))                 :mark (mark self)))(defmethod not-in-domain? ((self C-leaf-AB1))  (or (null-AB1-series? (tree-data self)) (call-next-method)))#|(defmethod filter-deep ((self C-leaf-AB1) (pred function) &optional constraint)  (unless (not-in-domain? self)    (when (or (not constraint)              (< (- 1 (necessity-degree constraint)) soft-constr::*beta*)              (= (necessity-degree constraint) 1))           (let ((series (filter-series pred (tree-data self))))             (set-value self series)    ;(setf (tree-data self) series)             (when (null-AB1-series? series) (assert-not-in-domain self)))))    self)|#(defmethod filter-deep ((self C-leaf-AB1) (pred function) &optional constraint)  (declare (ignore constraint))  (unless (not-in-domain? self)    (let ((series (filter-series pred (tree-data self))))      (set-value self series)    ;(setf (tree-data self) series)      (when (null-AB1-series? series) (assert-not-in-domain self))))  self)(defun null-AB1-series? (series) (not (first series)))#|(defmethod filter-domain ((domain C-leaf-AB1) (pred function) &optional constraint)  (unless (not-in-domain? domain)    (when (or (not constraint)              (< (- 1 (necessity-degree constraint)) soft-constr::*beta*)              (= (necessity-degree constraint) 1))      (set-value domain (lazy-filter pred (tree-data domain)))))  domain)|#(defmethod filter-domain ((domain C-leaf-AB1) (pred function) &optional constraint)  (declare (ignore constraint))  (unless (not-in-domain? domain)    (set-value domain (lazy-filter pred (tree-data domain))))  domain)(defmethod invalidate-leaf ((self C-leaf-AB1))  (let ((new-series (delay-cdr (tree-data self))))    (set-value self new-series)    (when (null-AB1-series? new-series) (assert-not-in-domain self))))(defmethod in-domain? ((self C-leaf-AB1))  (and (plusp (mark self))       (or (and (first (tree-data self)) (delay-first (tree-data self)))           (progn (assert-not-in-domain self) nil))))(defmethod get-all-domain ((self C-leaf-AB1)) (series-to-list (tree-data self)))(defmethod remove-from-domain ((self C-leaf-AB1) value)  (filter-deep self #'(lambda (chord) (not (equal chord value)))))(defmethod remove-useless-subtrees ((self C-tree-domain))  (setf (subtrees self) (remove-if #'not-in-domain? (subtrees self)))  (unless (subtrees self) (assert-not-in-domain self))  self)(defmethod get-span ((self number)) self)(defmethod get-low-int ((self number)) self)(defmethod get-span ((self cons)) (apply '+ self))  ;(first self))(defmethod get-low-int ((self cons)) (first self))(defmethod get-high-int ((self cons)) (first (last self)))(defclass C-leaf-AB2 (C-tree-domain) ())(defun make-AB2-leaf (domain &rest keys &key (class 'C-leaf-AB2) &allow-other-keys)  (apply #'make-tree-domain :class class         :tree-data domain :allow-other-keys t keys))(defmethod get-value ((self C-leaf-AB2))    (first (tree-data self)))(defmethod get-all-domain ((self C-leaf-AB2)) (tree-data self))(defmethod copy-leaf ((self C-leaf-AB2))  (make-ab2-leaf (copy-domain (tree-data self)) :mark (mark self)))#|(defmethod filter-domain ((self C-leaf-AB2) (pred function) &optional constraint)  (when (and (not (not-in-domain? self))             (or (not constraint)                 (< (- 1 (necessity-degree constraint)) soft-constr::*beta*)                 (= (necessity-degree constraint) 1)))    (let ((filtered-value (remove-if-not pred (tree-data self))))      (unless (not-null-domain? filtered-value)        (assert-not-in-domain self))      (set-value self filtered-value)))  self)|#(defmethod filter-domain ((self C-leaf-AB2) (pred function) &optional constraint)  (declare (ignore constraint))  (when (not (not-in-domain? self))    (let ((filtered-value (remove-if-not pred (tree-data self))))      (unless (not-null-domain? filtered-value)        (assert-not-in-domain self))      (set-value self filtered-value)))  self)(defmethod remove-from-domain ((self C-leaf-AB2) value)  (or (not-in-domain? self)      (let ((filtered-value (remove-if-not #'(lambda (item) (/= value item))                                           (tree-data self))))        (unless (not-null-domain? filtered-value)          (assert-not-in-domain self))        (set-value self filtered-value)))  self)  ;;(filter-domain self #'(lambda (item) (/= value item))))(defmethod invalidate-leaf ((self C-leaf-AB2))  (let ((new-val (cdr (tree-data self))))    (if new-val      (set-value self new-val)      (assert-not-in-domain self))))#|(defvar *pred* #'(lambda (z) (/= (car z) 2)))(defvar *leaf* (make-AB1-leaf (all-permutations '(1 2 3 4 5 6 7 8))))|#