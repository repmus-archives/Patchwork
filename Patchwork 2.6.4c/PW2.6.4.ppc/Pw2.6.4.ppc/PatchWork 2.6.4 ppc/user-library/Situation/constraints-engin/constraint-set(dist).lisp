;;;;;;Arc Consistency (Forward Checking) with Hierarchical domains;;;;;; By C. Rueda (c) IRCAM 93 0603;;;;;;  Constraints: Problem specific : Constraints for chords given explicitly. ;;;(in-package "HD-CONSTRAINTS")(defun b-min-note (chord) (first chord))(defun b-max-note (chord) (first (last chord)))(defun b-middle-note (chord)  (nth (1- (ceiling (1+ (length chord)) 2)) chord))(defun b-nth-note (i chord) (nth i chord))(defun b-choose-repet? (target-index source-index)  (and (successives 1 #'+ target-index source-index)       (>= target-index 2)))(defun b-repet-notes-vars ()  (arithm-ser 0 1 (max 0 (- (or *max-note-repets* 1) 1))))(defun b-no-repet (tx sx target &rest sources)  (declare (ignore sx))  (let* ((note-d (b-min-note target))         (note-u (b-max-note target))         (res t)         (repets (1- (first (find-constraint-fun (1- tx) *melodic-note-repets*)))))    (unless (< (length sources) repets)      (setq sources (subseq sources 0 repets)))    (dolist (chord sources res)      (if (or (= note-d (b-min-note chord))              (= note-u (b-max-note chord)))        (return (setq  res nil))))    (count-fail res 0)    ;;;;TEST!!    res))(defun b-check-melodie-base (tx sx target source)  (declare (ignore sx))  (let ((int (voice-interval 0 (1- tx) *valid-intervals*)))    (or (not int)        (member (abs (- (b-min-note target) (b-min-note source))) int))))(defun b-check-melodie (tx sx target source)  (declare (ignore sx))  (let ((intervals (voice-interval (1- (min (length target) (length source)))  (1- tx) *valid-intervals* () t)))     (or (not intervals)         (and (member (abs (- (b-max-note target) (b-max-note source)))                      intervals :test #'=)))))(defun b-check-middle-melodie (tx sx target source)  (declare (ignore sx))  (dotimes (i  (1- (min (length target) (length source))) t)    (let ((internal-ints (voice-interval (1+ i) (1- tx) *valid-intervals* t)))      (unless        (or (not internal-ints)            (member (abs (- (b-nth-note (1+ i) target) (b-nth-note (1+ i) source)))                    internal-ints :test #'=))        (return nil)))))(defun b-check-densities (tx sx target source) (check-densities tx sx target source))(defun b-get-//-source-vars ()  (arithm-ser 0 1 (max 0 (1- (apply 'max *max-//-ints*)))))(defun b-test-//-ints? (tx sx)  (and (successives 1 #'+ tx sx)       (> tx (get-nth (* 2 (1- tx)) *max-//-ints*))))(defun b-check//ints-low (tx sx target &rest sources)  (declare (ignore sx))  (setq sources (subseq sources 0 (1- (get-nth (* 2 (1- tx)) *max-//-ints*))))  (funcall (find-constraint-fun (1- tx) *parallel-ints*)           (nreverse (cons (get-low-int target) (mapcar #'low-interval sources)))))(defun b-check//ints-high (tx sx target &rest intervals)  (declare (ignore sx))  (setq intervals (subseq intervals 0 (1- (get-nth (* 2 (1- tx)) *max-//-ints*))))  (funcall (find-constraint-fun (1- tx) *parallel-ints*)           (nreverse (cons (get-high-int target) (mapcar #'high-interval intervals)))))(defun b-check-fixed-notes (tx sx chord)  (declare (ignore sx))  (let ((notes (gethash (1- tx) *fixed-notes-hash*)))    (or (not notes)        (if (>= (length chord) (length notes))          (= (length (intersection notes chord :test #'=)) (length notes))          (= (length (intersection chord notes :test #'=)) (length chord))))))(defun b-check-ambitus (tx sx chord)  (declare (ignore sx)) ;;(print tx)   (and (>= (b-min-note chord) (nth (1- tx) *ambitus-inf*))        (<= (b-max-note chord) (nth (1- tx) *ambitus-sup*))))(defun b-check-base-limit (tx sx chord)  (declare (ignore sx))  (let* ((horizontal-zone (get-valid-zone (1- tx) *limite-grave*))         (zones (and horizontal-zone (first (vertical-passbands horizontal-zone))))         (functions (and zones (second (vertical-passbands horizontal-zone))))        interv)    (do ((subzones zones (cdr subzones)) (subfuns functions (cdr subfuns)))        ((null subzones) t)      (when (setq interv (get-interv-zone (car subzones) (pw::x->dx chord)                                          (b-min-note chord)))        (unless (funcall (car subfuns) interv) (return nil))))))(defun b-choose-low-filter? (tx sx)  (and (successives 1 #'+ tx sx)       (> tx (get-nth (* 2 (1- tx)) *low-pat-length*))))(defun b-low-filters-vars ()  (arithm-ser 0 1 (max 0 (1- (apply 'max *low-pat-length*)))))(defun b-check-melodic-filter (tx chords length filter fun)    (setq chords (subseq chords 0 (1+ (get-nth (* 2 (1- tx)) length))))  (funcall (find-constraint-fun (1- tx) filter)     (mapcar #'(lambda (note1 note2)                 (abs (- (funcall fun note1) (funcall fun note2))))             chords (rest chords))))(defun b-check-low-filter (tx sx &rest chords)  (declare (ignore sx))  (b-check-melodic-filter tx chords *low-pat-length* *low-filter* #'b-min-note))(defun b-choose-h-filter? (tx sx)  (and (successives 1 #'+ tx sx)       (> tx (get-nth (* 2 (1- tx)) *hi-pat-length*))))(defun b-h-filters-vars ()  (arithm-ser 0 1 (max 0 (1- (apply 'max *hi-pat-length*))))) (defun b-test-voice-h-filter (tx sx &rest chords)  (declare (ignore sx))  (b-check-melodic-filter tx chords *hi-pat-length* *hi-filter* #'b-max-note))(defun b-notes+ints-sources () (notes+ints-sources))(defun b-choose-notes+ints? (tx sx)  (and  (successives 1 #'+ tx sx)       (zone-test-enabled? (1- tx) *min-different-notes*)))(defun b-check-notes+ints (tx sx &rest chords)  (declare (ignore sx))  (let* ((zone (get-valid-zone (1- tx) *min-different-notes*))         (min-notes (zone-notes zone)) (zone-chords (zone-chords zone))         res (dens 0))    (setf *octave-equivalence* (zone-octave-eq zone))    (dotimes (k zone-chords)      (setq res (union (nth k chords) res :test #'test-equal-notes)            dens (+ (length (nth k chords)) dens)))     (or (>= (length res) min-notes) (>= (length res) dens))    ))(defun b-horizontal-interval (chords fun)  (- (funcall fun (first chords)) (funcall fun (second chords))))(defun b-choose-equal-move? (tx sx)  (and (successives 1 #'+ tx sx)       (> tx (first (find-constraint-fun (1- tx) *maximum-equal-movement*)))))(defun b-check-movement (tx sx &rest chords)  (declare (ignore sx))  (setq chords         (subseq chords 0                 (1+ (first (find-constraint-fun (1- tx) *maximum-equal-movement*)))))  (do ((next-chords chords (rest next-chords)) (res 0) diff)      ((not (rest next-chords)) nil)    (setq diff (b-horizontal-interval next-chords #'b-max-note))    (if (< (abs (+ res diff)) (abs res))       (return t)      (setq res (+ res diff)))))(defun b-check-melodic-profile (tx sx chord1 chord2)  (declare (ignore tx))  (let ((sign (or (nth (1- sx) *melodic-profile*) (first (last *melodic-profile*)))))    (or (zerop sign)        (plusp (* sign (- (apply '+ chord1) (apply '+ chord2)))))))(defun b-test-parallel-moves? (tx sx)  (and (successives 1 #'+ tx sx)       (> tx (first (find-constraint-fun sx *max-parallel-moves*)))))(defun b-parallel-moves (tx sx &rest chords)  (declare (ignore tx))  (setq chords         (subseq chords 0 (1+ (first (find-constraint-fun sx *max-parallel-moves*)))))  (do ((next-chords chords (rest next-chords)))      ((not (rest next-chords)) nil)    (when (or (= (length (first chords)) (length (second chords)) 1)              (minusp (* (b-horizontal-interval next-chords #'b-max-note)                         (b-horizontal-interval next-chords #'b-min-note))))      (return t))))(defun b-check-user-constraint (tx sx &rest chords)  (declare (ignore tx))  (let (base-list ints-list)    (do ((i (1- (length chords)) (- i 1)))        ((< i 0)         (setf (intervals *the-user-constraint-object*) ints-list)         (setf (bases *the-user-constraint-object*) base-list))      (push (b-min-note (nth i chords)) base-list)      (push (pw::x->dx (nth i chords)) ints-list) )    (setf (h-table *the-user-constraint-object*) soft-constr::*solution-hash-table*))  (funcall *user-defined-constraints* sx *the-user-constraint-object*))(defun b-unary-interval-filter (tx sx chord)  (declare (ignore tx sx))  (funcall *vertical-filters* (pw::x->dx chord)))(defun define-given-chords-constraints ()  (setf *problem-constraints* (remove nil        (list          (and *valid-intervals*              (make-HD-constraint :rule-name "base-mel"                :choose-pred #'(lambda (tx sx) (successives 1 #'+ tx sx))               :test-level 1 :source-vars '(0)                :predicate #'b-check-melodie-base))         (make-full-unary-constraint  :rule-name "ambitus"          :test-level 1          :predicate #'b-check-ambitus)         (and *low-filter*               (make-HD-constraint   :rule-name "vi-filter"               :choose-pred #'b-choose-low-filter?               :test-level 1 :source-vars (b-low-filters-vars) :predicate #'b-check-low-filter))         (and *hi-filter*              (make-HD-constraint   :rule-name  "vs-filter"               :choose-pred #'b-choose-h-filter?               :test-level 1 :source-vars (b-h-filters-vars) :predicate #'b-test-voice-h-filter))         (and *melodic-note-repets*              (make-HD-constraint   :rule-name  "vs-rep"               :choose-pred #'b-choose-repet?               :test-level 1 :source-vars (b-repet-notes-vars) :predicate #'b-no-repet))         (and *maximum-equal-movement*              (make-HD-constraint   :rule-name "dir=ok"               :choose-pred  #'b-choose-equal-move?               :source-vars (arithm-ser 0 1 (max 0 (or *max-max-equal* 0)))               :predicate #'b-check-movement :test-level 1               :necessity-degree 1))         (and *melodic-profile*              (make-HD-constraint   :rule-name "melodic-profile"               :choose-pred  #'(lambda (tx sx) (and (successives 1 #'+ tx sx) (>= tx 2)))               :source-vars '(0)               :predicate #'b-check-melodic-profile :test-level 1               :necessity-degree 1))                      (and *valid-intervals*              (make-HD-constraint   :rule-name "all-mel"               :choose-pred #'(lambda (tx sx) (and (successives 1 #'+ tx sx) (>= tx 2)))               :test-level 1 :source-vars '(0) :predicate #'b-check-melodie))         (and *max-parallel-moves*              (make-HD-constraint  :rule-name "mouv//"               :choose-pred #'b-test-parallel-moves?               :test-level 1                :source-vars (arithm-ser 0 1 (max 0 (or *max-of-all-parallel* 0)))               :predicate #'b-parallel-moves               :necessity-degree 1))         (and *parallel-ints*              (make-HD-constraint   :rule-name "int//-high"               :choose-pred #'b-test-//-ints?               :source-vars (b-get-//-source-vars)               :test-level 4 :predicate #'b-check//ints-high))         (and *vertical-filters*              (make-full-unary-constraint   :rule-name "int-vert"               :choose-pred #'(lambda (tx sx) (declare (ignore sx tx)) t)               :test-level 1 :predicate #'b-unary-interval-filter))         (and *fixed-notes-hash*              (make-full-unary-constraint   :rule-name "fixed-notes"               :choose-pred #'(lambda (tx sx) (declare (ignore tx sx)) t)               :test-level 4 :predicate #'b-check-fixed-notes))         (and *limite-grave*              (make-full-unary-constraint   :rule-name "pass-band"               :choose-pred #'(lambda (tx sx) (declare (ignore sx tx)) t)               :test-level 1 :predicate #'b-check-base-limit) )         (and *valid-intervals*              (make-HD-constraint  :rule-name "middle-mel"               :choose-pred #'(lambda (tx sx) (and (successives 1 #'+ tx sx) (>= tx 2)))               :test-level 4 :source-vars '(0) :predicate #'b-check-middle-melodie))         (and *min-different-notes*              (make-HD-constraint   :rule-name "renouv-haut"               :choose-pred #'b-choose-notes+ints?               :test-level 4 :predicate #'b-check-notes+ints               :source-vars (b-notes+ints-sources)               :necessity-degree 1) )         (and *parallel-ints*              (make-HD-constraint   :rule-name "int//-low"               :choose-pred #'b-test-//-ints?               :source-vars (b-get-//-source-vars)               :test-level 4 :predicate #'b-check//ints-low) )         #|(and *user-defined-constraints*              (make-HD-constraint   :rule-name "user"               :choose-pred #'(lambda (tx sx) (successives 1 #'+ tx sx))               :test-level 4 :predicate #'b-check-user-constraint               :source-vars (arithm-ser 0 1 (floor (1- *num-vars*) 2)) ))|#         ))))