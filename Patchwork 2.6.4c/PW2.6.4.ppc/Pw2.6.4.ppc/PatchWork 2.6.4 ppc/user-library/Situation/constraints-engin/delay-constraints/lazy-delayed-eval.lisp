;;;;;; delayed expression handling;;; by Camilo Rueda (c), IRCAM 1992;;;(in-package "DELAYED-EVAL")(defmacro delay-exp (exp) `(function (lambda () ,exp)))(defun lazy? (exp) (subtypep (type-of exp) 'function))(defun force (exp) (if (lazy? exp) (funcall exp) exp))(defun force-all (exp) (do ((x exp (force x))) ((not (lazy? x)) x)))(defun delay-cdr (exp) (force (cdr exp)))(defun delay-nth (n exp)  (if (zerop n) (force-all (first exp)) (delay-nth (1- n) (delay-cdr exp))))(defun delay-first (exp) (force-all (first exp)))(defun delay-nthcdr (n exp)  (if (zerop n) exp (delay-nthcdr (1- n) (delay-cdr exp))))(defmacro delay-cons (item list)  `(cons ,item (function (lambda () ,list))))(defmacro dolist-delayed (var-exp &body body)  (let ((var (first var-exp))         (list (second var-exp))        (result-exp (third var-exp)))    `(do*  ((sublists ,list (delay-cdr sublists)) (,var (force-all (car ,list)) (force-all (car sublists))))           ((null sublists) ,result-exp) ,@ body)))(defun get-next (next-fun test-fun item)  (unless (funcall test-fun item)    (let ((new-item (funcall next-fun item)))      (delay-cons new-item (get-next next-fun test-fun new-item)))))(defun make-series (init next test)  (let ((init-val (funcall init)))    (delay-cons init-val (get-next next test init-val))))(defun multi-get-next (next-fun test-fun &rest item)  (unless (apply test-fun item)    (let ((new-items (multiple-value-list (apply next-fun item))))    (delay-cons (first new-items)                 (multiple-value-call #'multi-get-next next-fun test-fun (values-list new-items))))))(defun multi-make-series (init next test)  (let ((inits (multiple-value-list (funcall init))))      (delay-cons (first inits)                   (multiple-value-call #'multi-get-next next test  (values-list inits)))))(defun series-range (from upto)  (make-series #'(lambda () from) #'(lambda (item) (1+ item))                #'(lambda (item) (>= (1+ item) upto))))(defun series-from-list (list)  (multi-make-series #'(lambda () (values (car list) (cdr list)))                     #'(lambda (item rest)                          (declare (ignore item)) (values (car rest) (cdr rest)))                     #'(lambda (item rest) (declare (ignore item)) (not rest))))(defun series-to-list (series)  (and series       (let (res) (dolist-delayed (x series (nreverse res)) (push x res)))))(defun find-next-satisfying (pred series)  (let (val)    (and series         (setq val (force-all (first series)))         (if (funcall pred val)           (cons val (cdr series))           (find-next-satisfying pred (delay-cdr series))))))(defun filter-series (pred series)  (let ((next (find-next-satisfying pred series)))    (and next (cons (car next)                     (let ((continuation (cdr next)))                      #'(lambda () (filter-series pred (force continuation))))))))(defun lazy-filter (pred series)  (let (lazy-next)    (cons #'(lambda () (first (setq lazy-next (force (find-next-satisfying pred series)))))          #'(lambda () (filter-series pred (delay-cdr (force lazy-next)))))))  ;; (lazy-filter pred (delay-cdr (setq lazy-next (force lazy-next)))))))(defun get&move-series (&rest series)  (let* (value         (index (dotimes (i (length series))                  (if (setq value (delay-first (nth i series)))  ;;(setq value (car (nth i series)))                    (return i)))))    (and index      (values-list (list* value (delay-cdr (nth index series)) (nthcdr (1+ index) series))))))(defun append-series (&rest more-series)  (multi-make-series #'(lambda () (apply #'get&move-series more-series))                     #'(lambda (val &rest more-s) (declare (ignore val))                         (apply #'get&move-series more-s))                     #'(lambda (val &rest more-s) (declare (ignore val))                         (dolist (x more-s t)                           (if x (return nil)))))) ;;;======================================================;;utilities(defun all-permutations (list)    (make-series #'(lambda () (sort (copy-list list) '<))   ;;(sort list '<))                 #'get-next-perm                 #'test-end-perm))(defun where-position (it list length)  (let ((where (position it list :test #'>)))    (if where (+ where (- length (length list))) most-positive-fixnum)))(defun get-next-perm (p)  (let* ((rp (reverse p)) (length  (length p))         (currents (maplist #'(lambda (it) (where-position (car it) (cdr it) length))                           rp))         (pos-curr (position (apply #'min currents) currents :test #'=))         (pos-in-rp (nth pos-curr currents))         (old-item (nth pos-curr rp))         (new-item (nth pos-in-rp rp))         p-first)    (setf (nth pos-curr rp) new-item (nth pos-in-rp rp) old-item)    (setq p-first (subseq rp 0 pos-in-rp))    (setq rp (nreverse rp))    (nconc (subseq rp 0 (- length pos-in-rp)) (sort  p-first '<))));;;faster???#|(defun get-next-perm (p)  (let ((rp (reverse p)) index)    (do ((sp rp (rest sp))         (tail (list (first rp)) tail)) ((not (rest sp)) (nreverse sp))      (when (> (first sp) (second sp))        (setq tail (sort tail '<) index (position (second sp) tail :test #'< ))        (psetf (nth index tail) (second sp) (second sp) (nth index tail))        (return (nreverse (nconc (sort tail '>) (rest sp)))))      (if (< (second sp) (first tail))        (push (second sp) tail)        (setq tail (cons (first tail) (push (second sp) (rest tail))))))))|#(defun test-end-perm (p)  (let (res (search t))    (pw::while search      (if (cdr p)        (if (< (pop p) (car p)) (setq search nil))        (setq search nil res t)))    res))(defun shuffle-permut (list)  (multi-make-series           #'(lambda () (values list                                 (let (res)                                   (dotimes (i (length list) (nreverse res))                                    (push i res)))))           #'get-next-s-perm           #'test-end-s-perm))(defun get-next-s-perm (p op)  (let ((perm-list (get-next-perm op)))    (values (mapcar #'(lambda (perm) (nth perm p)) perm-list) perm-list)))(defun test-end-s-perm (p op)  (declare (ignore p))  (test-end-perm op));;;combinations(defun combinations (list k)  (let ((list (sort (copy-list list) '<)) (n (length list)))    (and (> n k)         (make-series #'(lambda () (butlast list (- n k)))                  #'(lambda (comb) (next-comb comb list k))                  #'(lambda (comb) (test-end-comb comb list k))))))(defun next-comb (comb list k)  (let ((posns (reverse                 (mapcar #'(lambda (item) (position item list)) comb)))        (length (length list))        ipos n-pos)    (setq ipos           (dotimes (j k)            (if (< (nth j posns) (- length j 1)) (return j))))    (setq n-pos (nth ipos posns))    (nconc (subseq comb 0 (- k ipos 1)) (subseq list (1+ n-pos) (+ n-pos ipos 2)))))(defun test-end-comb (comb list k)   (let ((posns (nreverse (mapcar #'(lambda (item) (position item list))                                 comb)))        (length (length list)))      (dotimes (j k t)       (if (< (nth j posns) (- length j 1)) (return nil)))));;combinations with duplications(defun resize-list (list k)  (let ((length (length list)))  (if (> length k) list      (dotimes (i (-  k length)) (push (car list) list))) list))(defun comb-with-dups (list k)  (let* ((dup-list (sort (resize-list (copy-list list) k) '<))         (n (length dup-list)))    (and (>= n k)         (make-series #'(lambda () (make-list k :initial-element (car dup-list)))                  #'(lambda (comb) (next-comb-dups comb dup-list k))                  #'(lambda (comb) (test-end-comb-dups comb dup-list k))))))(defun next-comb-dups (comb list k)  (let ((rcomb (reverse comb)) (in-comb (1- (length comb)))        in-list new-elem)    (setq new-elem          (dolist (item  rcomb)            (setq in-list (position item list :test #'<))            (if in-list (return (nth in-list list)))            (decf in-comb)))    (nconc (subseq comb 0 in-comb)            (cons new-elem (make-list (- k in-comb 1)                                     :initial-element (car list))))))(defun test-end-comb-dups (comb list k)  (declare (ignore k))  (let ((last (car (last list))))    (dolist (item comb t)      (if (/= item last) (return nil)))))(defun test-end-cart-prod (s1 s2)  (and (not (delay-cdr s1)) (not (delay-cdr s2))))(defun cartesian (s1 s2)    (multi-make-series             #'(lambda () (values (list (car s1) (car s2)) 0 0 s1 s2))             #'(lambda (item i1 i2 last1 last2)                 (declare (ignore item))                 (next-cartesian i1 i2 last1 last2 s2))             #'(lambda (item i1 i2 last1 last2)                  (declare (ignore item i1 i2))                 (test-end-cart-prod last1 last2))))(defun next-cartesian (i1 i2 last1 last2 s2)  (let ((ds2 (delay-cdr last2))         ds1)   (if ds2     (values (list (car last1) (car ds2)) i1 (1+ i2) last1 ds2)     (values (list (car (setq ds1 (delay-cdr last1))) (car s2)) (1+ i1) i2 ds1 s2))));;all possible replacements of a value for elements in a list(defun get-first-replacement (item list)  (values (sort (copy-list list) #'(lambda (x y) (declare (ignore y)) (= x item)))          (if (position item list) item ())))#|(defun get-next-replacement (list saved-val item)  (let ((pos 0) (saved saved-val) (list (copy-list list)))    (when saved-val      (setq pos (position item list :from-end t))      (setf (nth pos list) saved)      (incf pos))    (when (= pos (length list))      (if (position item list :from-end t)        (progn (setq pos (position item list :from-end t))               (setf (nth (incf pos) list) item)               (incf pos))        (setf (nth 0 list) item pos 1)))    (setq saved (nth pos list))    (setf (nth pos list) item)    (values list saved)))(defun last-replacement? (list item repetitions)  (or (zerop (count item list :test #'/=))      (and (position item list :test #'=)           (and (= (position item list :from-end t) (1- (length list)))                (= (count item list) repetitions)))))(defun all-replacements (list item &optional (repetitions most-positive-fixnum))  (cond ((= (count item list) repetitions)         (series-from-list (list (get-first-replacement item list))))        ((< (count item list) repetitions)         (multi-make-series           #'(lambda () (get-first-replacement item list))          #'(lambda (list saved-val) (get-next-replacement list saved-val item))          #'(lambda (list saved-val)              (declare (ignore saved-val)) (last-replacement? list item repetitions))))))|#(defun get-first-rep-lists (item list reps)  (let* ((nums (count item list))        (length (- (length list) nums))        (indexes (series-to-list (series-range nums (+ nums length))))        result        (indexes-list (series-to-list                       (apply #'append-series                              (dotimes (i (- reps nums) (nreverse result))                                (push (combinations indexes (1+ i)) result))))))   (get-next-reps list indexes-list item list)))(defun get-next-reps (previous indexes item list)  (declare (ignore previous))  (let ((list (copy-list list)) (first (first indexes)))    (values     (if (numberp first)       (progn (setf (nth first list) item) list)       (dolist (i first list) (setf (nth i list) item)))     (rest indexes))))(defun all-replacements (list item &optional (repetitions 2))  (cond ((= (count item list) repetitions)         (series-from-list (list (get-first-replacement item list))))        ((< (count item list) repetitions)         (let ((list (get-first-replacement item list)))           (multi-make-series             #'(lambda () (get-first-rep-lists item list repetitions) )            #'(lambda (previous indexes) (get-next-reps previous indexes item list))            #'(lambda (list indexes)                (declare (ignore list)) (null indexes)))))))#|(series-to-list (all-replacements '(7) 7 2))(dolist-delayed (x (all-permutations '(1 2 3 4))))(delay-nth 2 (all-permutations '(1 2 3 4)))(shuffle-permut '(4 2 1 3 )))(combinations '(1 2 3 4) 3)(dolist-delayed (x (comb-with-dups '(4 7 11 13 2) 7)) (incf foo))(dolist-delayed (x  (combinations '(25 23 23) 1)) (print x))(dolist-delayed (x  (append-series (all-permutations '(1 2 3 4)) (series-range 0 10)))  (print x))(time (setq foo (filter-series #'(lambda (x) (/= (second x) 2))                     (all-permutations '(1 2 3 4 5 6 7 8 9)))))(setq foo (lazy-filter #'(lambda (x) (/= (third x) 3))                     (all-permutations '(1 2 3 4 5 6 7 8 9))))(setq fi (lazy-filter  #'(lambda (x) (/= (third x) 4)) foo)) (delay-nth 0 foo)(dolist-delayed (x fi) (print x))(dolist-delayed (x (all-replacements '(4 7 11) 11 2)) (print x))(series-to-list (all-replacements '(4 7 11) 11 2))(get-first-replacement 7 '(2 4 5 7 2 4 5))|#