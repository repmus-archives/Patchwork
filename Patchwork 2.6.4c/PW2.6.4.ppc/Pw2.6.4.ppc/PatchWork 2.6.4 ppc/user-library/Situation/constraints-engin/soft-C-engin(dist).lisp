;;;;;;  Soft Constraints;;;;;;  By C. Rueda (c) IRCAM. Based on Thomas Schiex's formal model.;;;(in-package "SOFT-CONSTR")(defvar *all-solutions* ())(defvar *done-for-user* ())(defvar *problem-constraints* ())(defvar *num-vars* 1)(defvar *max-advance* 2)(defvar *domains* ())(defvar *beta* 0)(defvar *user-beta* 0)(defvar *solution-hash-table* ())(defvar *max-time* most-positive-fixnum)(defvar *elapsed-time* 0)(defvar *all-solutions* ())(defvar *current-computed-alpha* 1)(defvar *backtrack-to* ())(defclass C-param-object ()  ((bound :initform 1 :initarg :bound :accessor bound)   (varindex :initform 1 :accessor varindex)   (numvars :initform 1 :accessor numvars)   (data :initform () :accessor data)))(defvar *parameter-object* (make-instance 'C-param-object))(defun standard-accum (k value alpha)(declare (ignore k value alpha)) )(defun standard-display (k value alpha) (declare (ignore value alpha)) (when (zerop (mod k 2)) (format t " ~S" k)))(defun standard-succeed (d &optional length alpha user-alpha)  (format t "solution= ~S value= ~S maximized-val= ~S~% want more (t nil)?" (nicely-put d length) alpha user-alpha)  (not (read)))(defun standard-node-evaluation (index alpha test-soft? solution-collection)  (if (<= index 1) alpha       (progn        (when test-soft?          (dolist (constraint *problem-constraints* *current-computed-alpha*)            (when (< (hd-constraints:necessity-degree constraint) 1)              (dotimes (j *max-advance*)                (when (enabled? constraint index (- index j) solution-collection)                  (arc-consistency constraint index (- index j) solution-collection)                  (unless (hd-constraints::now-satisfied? constraint)                    (setf *current-computed-alpha*                          (min *current-computed-alpha* (- 1 (hd-constraints:necessity-degree constraint))))))))))        (min alpha *current-computed-alpha*))))(defun soft-forward-check (constraints domains  numvars                           &key                            (node-evaluation #'standard-node-evaluation)                           (succeed-fun #'standard-succeed)                           (accum-fun #'standard-accum)                           (display-fun #'standard-display)                           (advance *max-advance*)                           (max-time *max-time*)                           (min-beta 0)                           (user-alpha 1)                           (user-beta 0)                           (maximize-function)                           (user-test-fun))  (setf *problem-constraints* constraints *num-vars* numvars *max-advance* advance *domains* domains        *done-for-user* nil *all-solutions* nil)  (let ((*beta* min-beta) (*user-beta* user-beta) (*current-computed-alpha* 1) new-user-alpha        (current-time (midi::clock-time))   ;;;;WARN: PW dependent...        (test-fun (or user-test-fun #'(lambda (a b n k) (declare (ignore n k)) (or (= a b user-alpha) (> a b))))))    (labels       ((DF-alpha-beta (k solution-collection reduced-d-collection alpha user-a)         (when (soft-check-ahead k solution-collection reduced-d-collection alpha user-a maximize-function)           (if (> (/ (- (midi::clock-time) current-time) 6000) max-time)  ;;;;WARN: PW dependent...             (progn (print "time out!!") (setf *done-for-user* t))             (let ((domain-tree (get-domain-item reduced-d-collection 0))                   (*solution-hash-table* (aref solution-collection 0))                   new-alpha nicely-put-value test-soft?)               (do-tree-domain (value domain-tree)                 (setf *backtrack-to* ())        ;;no current information for back jumping                 (setq new-alpha (funcall node-evaluation k alpha test-soft? solution-collection))                 (set-domain-item solution-collection k (get-one-value value))                 (when (or (= new-alpha *beta* 1) (> new-alpha *beta*))                   (setq new-user-alpha                          (get-next-user-alpha user-a k numvars maximize-function solution-collection))                   (when (funcall test-fun new-user-alpha *user-beta* numvars k)                     (funcall display-fun k value new-alpha)  ;;user supplied partial results displaying function                     (funcall accum-fun k value new-alpha)    ;;user supplied partial results accumulation function                     (setq nicely-put-value (nicely-put value))                     (push nicely-put-value (gethash nicely-put-value *solution-hash-table*))                     (if (= k numvars)                       (progn                          (when (setf *done-for-user* (funcall succeed-fun solution-collection k new-alpha new-user-alpha))                           (return))                         (setq *beta* (max *beta* new-alpha))                         (setq *user-beta* (max *user-beta* new-user-alpha)))                       (DF-alpha-beta (1+ k) solution-collection                                      (soft-copy-domain-collection reduced-d-collection  k advance)                                      new-alpha new-user-alpha))                     (if *done-for-user* (return))                     (setf (gethash nicely-put-value *solution-hash-table*)                           (remove nicely-put-value (gethash nicely-put-value *solution-hash-table*) :test #'equal))                     (cond ((and *backtrack-to* (< (first *backtrack-to*) k)) (return))                           ((and (rest *backtrack-to*) (= (first *backtrack-to*) k))                            (funcall (rest *backtrack-to*) k domain-tree)))                     ))                 (setf *current-computed-alpha* alpha test-soft? t)))))))      (DF-alpha-beta 1 (initialize-solution-collection numvars)                     (soft-copy-domain-collection domains 0 advance) 1 user-alpha))))(defun get-next-user-alpha (u-alpha k n function solution)  (if function     (progn (setf (bound *parameter-object*) u-alpha                 (varindex *parameter-object*) k                 (numvars *parameter-object*) n                 (data *parameter-object*) (nreverse (nicely-put solution k)))           (funcall function *parameter-object*))    u-alpha))(defun initialize-solution-collection (numvars)  (let ((a (make-array (list (1+ numvars)))))    (setf (aref a 0) (make-hash-table :test #'equal))    a))(defun soft-check-ahead (k solution-collection domain-collection alpha &optional user-alpha optimize-function)  (declare (ignore alpha))  (let ((res t) (1-k (1- k)))    (when (> k 1)      (setf *current-computed-alpha* 1)      (do ((p k (1+ p))) ((> p (min (+ 1-k *max-advance*) *num-vars*)))        (unless (soft-revise p (1- k) solution-collection domain-collection user-alpha optimize-function)          (setq res nil)          (return))))    res))(defun soft-revise (i j solution-collection reduced-d-collection &optional user-alpha optimize-function)  (set-domain-item solution-collection i (all-domain-of reduced-d-collection (- i j 1)))  ;;(setf *current-computed-alpha* 1)  (dolist (constraint *problem-constraints*)    (when (enabled? constraint i j solution-collection)      (arc-consistency constraint i j solution-collection)      (unless (hd-constraints::now-satisfied? constraint)        (setf *current-computed-alpha* (min *current-computed-alpha* (- 1 (hd-constraints:necessity-degree constraint)))))))  (when optimize-function    (filter-by-opt-function solution-collection i j user-alpha optimize-function))  (set-domain-item reduced-d-collection (- i j 1) (all-domain-of solution-collection i))  (set-domain-item solution-collection i nil)  (not-null-domain? (all-domain-of reduced-d-collection (- i j 1)))      )(defun filter-by-opt-function (solution-collection i j user-alpha optimize-function)  (when (= (- i j) 1)     ;;;consecutive elements in the sequence    (let ((previous (nreverse (nicely-put solution-collection (1- i)))))      (filter-leaves-domain (all-domain-of solution-collection i)             #'(lambda (value)                  (setf (bound *parameter-object*) user-alpha                       (varindex *parameter-object*) i                       (numvars *parameter-object*) *num-vars*                       (data *parameter-object*) (cons value previous))                 (>= (funcall optimize-function *parameter-object*) *user-beta*))))))    (defmethod soft-copy-domain-collection ((domain-collection vector)                                &optional (from 0) (upto most-positive-fixnum))  (let* ((upto-section (min *num-vars* (+ from upto)))         (a (make-array (list (min *num-vars* upto)))))    (do ((i (1+ from) (1+ i))) ((> i (1- upto-section)))      (setf (aref a (- i from 1)) (copy-domain (aref domain-collection (- i from)))))    (if (> (+ from upto) *num-vars*)      (setf (aref a (- upto-section from 1)) (copy-domain (aref domain-collection (- upto-section from))))      (setf (aref a (- upto-section from 1)) (copy-domain (aref *domains* upto-section)))  )    a))(defun HD-AC5-consistency (constraints domain-collection numvars max-advance)  (let (queue)    (do ((sx 1 (1+ sx))) ((> sx numvars))    ;;((>= sx numvars))      (dolist (one-constraint constraints t)                (when (enabled? one-constraint sx sx)                  (hd-constraints::filter-unary one-constraint sx domain-collection))))    (when      (do ((sx 1 (1+ sx))) ((>= sx numvars) t)        (unless          (do ((tx (1+ sx) (1+ tx))) ((> tx (min numvars (+ sx max-advance))) t)            (unless              (dolist (one-constraint constraints t)                (when (enabled? one-constraint tx sx)                  (multiple-value-bind (bads-from bads-to)                                        (full-consistency one-constraint tx sx domain-collection)                    (when bads-from (setq queue (add-to-queue queue sx bads-from constraints)))                    (when bads-to (setq queue (add-to-queue queue tx bads-to constraints)))                    (when (and (eq bads-from t) (eq bads-to t))                      (format t "there is no solution!!" ) (ed-beep) (return nil)))))              (return nil)))          (return nil)))      (do* ((queue queue (rest-queue queue))            (element (first-queue queue) (first-queue queue)) (from) (to) (value) (data))           ((empty-queue? queue) domain-collection)        (setq from (get-source-node element) to (get-target-node element) value (get-node-value element))        (dolist (one-constraint constraints)          (when (enabled? one-constraint to from)            (when (setq data (local-consistency one-constraint from to value domain-collection))              (add-to-queue queue from data constraints))))))))(defmethod add-to-queue ((self list) tx values constraints)  (do ((sx 1 (1+ sx))) ((= sx tx))     (dolist (one-constraint constraints)       (when (enabled? one-constraint tx sx)         (push (make-element sx tx values) self))))  self)(defmethod rest-queue ((self cons)) (rest self))(defmethod first-queue ((self null)) self)(defmethod first-queue ((self cons)) (first self))(defmethod empty-queue? ((self cons)) nil)(defmethod empty-queue? ((self null)) t)(defun make-element (sx tx values) (declare (ignore values)) (cons sx tx))(defun get-source-node (element) (first element))(defun get-target-node (element) (rest element))(defun get-node-value (element) (declare (ignore element)) nil) 