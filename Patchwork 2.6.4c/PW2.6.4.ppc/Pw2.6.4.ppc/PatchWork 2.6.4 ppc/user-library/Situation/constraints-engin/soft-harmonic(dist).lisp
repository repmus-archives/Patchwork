;;;===============================================================;;;Arc Consistency (Forward Checking) with Hierarchical domains;;;;;; By C. Rueda (c) IRCAM 921203;;;;;;  Constraints: PatchWork Interface: harmonic sequence computation;;;=================================================================(in-package "HD-CONSTRAINTS");;globals accessible in constraints rules (defvar *valid-intervals* ())    ;; valid intervals for the chords(defvar *min-different-notes* 1)  ;;;a number or list expression giving min different notes in a subsequence(setf *min-different-notes* 22)(defvar *maximum-equal-movement* 3)  ;;max num of steps in the same direction(defvar *max-max-equal* ())(defvar *ambitus-sup* ())        ;; a list of top ambitus for the sequence(defvar *ambitus-inf* ())        ;; a list of bottom ambitus for the sequence(defvar *melodic-note-repets* 7) ;; min num of steps without repetion of notes at the upper voice. (an expression)(defvar *max-note-repets*)(defvar *limite-grave*)          ;; an expression (list) giving pass-bands for pitches.(defvar *intervalles* ())        ;; Objects: base-note + intervals representations of chords(defvar *parallel-ints* ())      ;; parallel intervals forbid or imposed in a subsequence(defvar *max-//-ints* ())(defvar *no-density-checking* ())  ;;old stuff. This should always be TRUE.(defvar *max-parallel-moves* ())   ;;Controls relative movement (parallel or not) in outer voices.(defvar *max-of-all-parallel* ())(defvar *hi-filter* ())            ;; Horizontal intervals filter for the upper voice.(defvar *low-filter* ())           ;; Vertical intervals filter for the upper voice.(defvar *hi-pat-length* '(0))      ;; maximum length of a subexpression in the above(defvar *low-pat-length* '(0))(defvar *parallel-length* 0)(defvar *rep-by-density-a-list* ()) ;; max num of equal intervals in a chord, based on its density(defvar *fixed-notes-hash* ())      ;; imposed fixed notes(defvar *octave-equivalence* ())    ;; absolute (NIL) pitches or pitch classes (TRUE) for the above.(defvar *density* ())               ;; number of notes in each chord(defvar *max-num-solns* 1)(setf *max-num-solns* 100)(defvar *vertical-filters* ())      ;; filter expression for chord intervals(defvar *stabilities*)              ;;  Specific stuff (Marco Stroppa) not used.(defvar *homogeneities*)(defvar *stability-table*)(defvar *octave-scale-table*)(defvar *partial-results-save* ())(defvar *vertical-intervals* ())(defvar *user-defined-constraints* ())(defvar *melodic-profile* ())(defvar *standard-chord-representation* t)  ;; TRUE if base-note + intervals chord representation.(defvar *importance-list* nil)              ;; weight of each constraints (Default 1)(defvar *maximum-search-time* most-positive-fixnum)(defvar *min-beta* 0)                ;; constraints hierarchies impose alpha-beta search.(defvar *optimize-fun* ())           ;; Stuff for constrained minimization. Works OK but not efficiently!!!!(defvar *alpha-test-fun* ())(defvar *alpha-maxval* 1)(defvar *alpha-minval* 0);;utilities for specific representation of a sequence: vector of  base-note + intervals (alternating)(defun successives (diff test i j) "two chords are consecutive if i,j are even and i=j+2"  (and (= (- i j) diff) (funcall test (mod i 2) 0)))(defun notes-of (dxs start)  "Constructs a list of numbers from <start> and the consecutive intervals <dxs>."  (let ((x start))    (cons x (mapcar #'(lambda (dx) (incf x dx)) dxs))))(defun max-note (ints base)  (+ base (apply '+ ints)))(defun min-note (ints base) (declare (ignore ints)) base)(defun min-horizontal-interval (index chords)  (- (min-note (nth index chords) (nth (1+ index) chords))     (min-note (nth (+ 2 index) chords) (nth (+ 3 index) chords))))(defun max-horizontal-interval (index chords)  (- (max-note (nth index chords) (nth (1+ index) chords))     (max-note (nth (+ 2 index) chords) (nth (+ 3 index) chords))))(defun middle-note (ints base)  (let ((notes (notes-of ints  base)))    (nth (1- (ceiling (1+ (length notes)) 2)) notes)))(defun low-interval (ints) (first ints))(defun high-interval (ints) (first (last ints)))(defun last-note (chord) (car (last chord)))(defun central-note (chord) (nth (1- (ceiling (1+ (length chord)) 2)) chord))(defun coef-homog (chord)  ;coefficient of homogeneity  (- (apply 'max chord) (apply 'min chord)));;stability stuff (M. Stroppa)(defun getweights (number weights octave-scalers)  (* (or (second (assoc (floor number 12) octave-scalers)) 1)                   (or (second (assoc (rem number 12) weights)) 0)))(defun coef-stability (chord weights octave-scalers)  (let ((val 0) (accum 0) (numints 0))    (do ((subchords chord (rest subchords)) (base-int (first chord) (first subchords)))        ((null subchords) (/ val numints))      (incf val (getweights base-int weights octave-scalers))      (incf numints)      (setq accum 0)      (dolist (int (rest subchords))        (incf numints)        (incf val (getweights (incf accum int) weights octave-scalers))))))(defun stability-inf (index)  (when (>= index (* 2 (length *stabilities*))) (setq index (* 2 (length *stabilities*))))  (first (nth (1- (floor index 2)) *stabilities*)))(defun stability-sup (index)  (when (>= index (* 2 (length *stabilities*))) (setq index (* 2 (length *stabilities*))))  (second (nth (1- (floor index 2)) *stabilities*)));;Utilities for parsing horizontal intervals constraint expressions(defun voice-interval-test (x y) (if (numberp y) (<= x y) nil))(defun parse-voice-exp (voice exp &optional internal max-voice)  (if (numberp (first exp))    (and (not internal) exp)    (if max-voice      (first (rest (member voice exp :test #'(lambda (x y) (and (numberp y) (<= x y))))))      (first (rest (member voice exp))))))    ;; (first (last exp)))))(defun voice-interval (voice index form &optional internal max-voice)  (and form       (let ((subexp               (or (cdr (member index form :test #'voice-interval-test))                  (list (first (last form))))))         (unless (consp (first subexp)) (setq subexp (cdr subexp)))         (parse-voice-exp voice (first subexp) internal max-voice))))(defun arithm-ser (begin step end)  "Returns a list of numbers starting from <begin> to <end> with step <step>"  (let ((l ()))    (for (i begin step end) (push i l))    (nreverse l)));;faster remove-duplicates (commutative)(defun my-remove-dups (list &optional (test #'equal))  (cond ((null list) list)        ((member (car list) (cdr list) :test test)         (my-remove-dups (cdr list) test))        (t (cons (car list) (my-remove-dups (cdr list) test)))))(defun permut-random (list)  "Returns a destructive random permutation of <list>."  (let ((result ()) (length (length list)) (list (copy-list list)))    (nconc list list)    (repeat length      (setq list (nthcdr (random length) list)            result (rplacd (prog1 (cdr list) (rplacd list (cddr list))) result)            length (1- length)))    result))  ;;;==================================;;; Fail statistics(defvar *fail-table*)(defvar *fail-list* '(no-repet check-melodie check-ambitus check-notes+ints parallel-moves))(defun make-fail-hash (list)  (setf *fail-table* (make-hash-table  :size 128))  (dotimes (i (length list)) (setf (gethash i *fail-table*) 0)));(make-fail-hash '(no-repet check-melodie check-ambitus check-notes+ints parallel-moves))(defun count-fail (result name)  (unless result (incf (gethash name *fail-table*)))  result)(pw::defunp statistics () nil " "  (dotimes (i (length *fail-list*))    (format t "constraint: ~A has failed ~S times ~%"            (nth i *fail-list*) (gethash i *fail-table*))))(defun with-statistics () (make-fail-hash *fail-list*));;;==================================================;;; An object to be given to user specific constraints (OLD STUFF) please delete me!!!#|(defclass C-user-constraint-data ()  ((bases :initform () :accessor bases)   (intervals :initform () :accessor intervals)   (h-table :initform nil :accessor h-table)))(setf *the-user-constraint-object* (make-instance 'C-user-constraint-data))|#;;;=====================================;;; Constraint predicates(defun choose-repet? (target-index source-index)  (and (successives 1 #'= target-index source-index)       (>= target-index 3)))(defun repet-notes-vars ()  (arithm-ser 0 1 (max 0 (- (* 2 (or *max-note-repets* 1)) 2))))(defun no-repet (tx sx target base1 &rest sources)  (let* ((note-d base1)         (note-u (+ (get-span target) note-d))         (res t)  (where 1)         (repets (* 2 (first (find-constraint-fun (floor sx 2) *melodic-note-repets*)))))    (unless (< (length sources) repets)      (setq sources (subseq sources 0 repets)))    (do* ((chords sources (cddr chords))          (base-note (second sources) (second chords))          (ints (first sources) (first chords)))         ((not chords) res)      (when (= note-u (max-note ints base-note)) (return (setq  res nil)))      (incf where 2))    (count-fail res 0)    (or res        (progn (where-to-backtrack-repet tx sx where (nth (1- where) sources) note-u) nil))));;attempt to do intelligent (to wit) backtracking when constraints of fixed notes have been imposed(defun where-to-backtrack-repet (tx sx where interv note)  (if (and *fixed-notes-hash* (= (nth (1- (floor tx 2)) *ambitus-sup*) note)           (member note (gethash (1- (/ tx 2)) *fixed-notes-hash*)))    (setf *backtrack-to*  ;; car is where to go back. cdr is a function to call when you're there.          (cons (- sx where)                (let ((span (apply '+ interv)))                #'(lambda (index domain) (declare (ignore index))                    (dolist (node (get-nodes-at-depth domain 1 *filter-node-pred*))                      (if (= (apply '+ (form-tree-values node)) span) (assert-not-in-domain node)))))))))(defun check-melodie-base (tx sx target source)  (declare (ignore sx))  (member (abs (- target source))         (or (voice-interval 0 (floor tx 2) *valid-intervals*) (list  (abs (- target source)))) :test #'=)      )(defun check-melodie (tx sx target base2 ints1 base1)  (declare (ignore sx))  (let ((intervals (voice-interval 2 (floor (1- tx) 2) *valid-intervals*)))    (count-fail      ;;just count number of failures (in case someone finds this useful)     (or (not intervals)         (and (member (abs (- (+ base2 (get-span target))                              (max-note ints1 base1))) intervals :test #'=)))  1)))(defun check-middle-melodie (tx sx target base2 ints1 base1)  (declare (ignore sx))  (let ((internal-ints (voice-interval 1 (floor tx 2) *valid-intervals* t)))    (or (not internal-ints)        (member (abs (- (middle-note target base2) (middle-note ints1 base1)))                internal-ints :test #'=))))(defun get-//-source-vars ()  (arithm-ser 0 2 (max 0 (- (* 2 (1- (apply 'max *max-//-ints*))) 2))))(defun test-//-ints? (tx sx)  (and (successives 2 #'= tx sx) (>= tx (* 2 (get-nth (1- tx) *max-//-ints*)))))(defun check//ints-low (tx sx target &rest sources)  (declare (ignore sx))  (setq sources (subseq sources 0 (1- (get-nth (1- tx) *max-//-ints*))))  (funcall (find-constraint-fun (floor (1- tx) 2) *parallel-ints*)           (nreverse (cons (get-low-int target) (mapcar #'low-interval sources)))))(defun check//ints-high (tx sx target &rest intervals)  (declare (ignore sx))  (setq intervals (subseq intervals 0 (1- (get-nth (1- tx) *max-//-ints*))))  (funcall (find-constraint-fun (floor (1- tx) 2) *parallel-ints*)           (nreverse (cons (get-high-int target) (mapcar #'high-interval intervals)))))(defun check-fixed-notes (tx sx intervals base-note)  (declare (ignore sx))  (let ((notes (gethash (1- (/ tx 2)) *fixed-notes-hash*)))    (or (not notes)         (let ((chord (notes-of intervals base-note)))          (if (>= (length chord) (length notes))            (= (length (intersection notes chord :test #'=)) (length notes))            (= (length (intersection chord notes :test #'=)) (length chord))))        )))(defun check-ambitus (tx sx chord-ambitus base-note)  (declare (ignore sx))  (count-fail   (<= (+ (get-span chord-ambitus) base-note) (nth (1- (floor tx 2)) *ambitus-sup*))  2))(defun density-info (item) (if (base-note-already-given item) (third item) (apply 'min item)))(defun test-span&fixed? (tx sx)  (and (successives 1 #'= tx sx)       (let ((notes (gethash (floor sx 2) *fixed-notes-hash*))             (min-dens (density-info (aref *density* (floor sx 2)))))         (and notes (>= min-dens (length notes))))))(defun check-span&fixed-notes (tx sx chord-ambitus base-note)  (declare (ignore tx))  (let ((max-note (gethash (floor sx 2) *fixed-notes-hash*)))    (or (not max-note)        (>= (+ base-note (get-span chord-ambitus)) (apply 'max max-note)))))(defun get-interv-zone (zone-pair intervs base-note)  (let (res (low-pair (car zone-pair)) (up-pair (second zone-pair))            (accum base-note))    (dolist (interval intervs (nreverse res))      (if (and (>= accum low-pair) (<= (+ accum interval) up-pair))        (push interval res)        (when (>= (+ accum interval) up-pair) (return (nreverse res))))      (incf accum interval))))(defun vertical-passbands (zone) zone)(defun get-passband-zone (index expression)  (do () ((null expression))    (if (consp (first expression))      (if (member index (pop expression))        (return (first expression))        (pop expression))      (if (and (>= index (pop expression)) (<= index (pop expression)))        (return (first expression))        (pop expression)))))(defun check-base-limit (tx sx intervals base-note)  (declare (ignore sx))  (let* ((horizontal-zone (get-passband-zone (1- (floor tx 2)) *limite-grave*))         (zones (and horizontal-zone (first horizontal-zone)))         (functions (and zones (second horizontal-zone)))        interv)   (do ((subzones zones (cdr subzones)) (subfuns functions (cdr subfuns)))        ((null subzones) t)      (when (setq interv (get-interv-zone (car subzones) intervals base-note))        (unless (funcall (car subfuns) interv) (return nil))))));;(get-interv-zone '(48 59) '(2 5 2 7 4 5 2) 49);;(vertical-passbands  (get-passband-zone 1 *limite-grave*))(defun choose-low-filter? (tx sx)  (and (>= tx (1+ (* 2 (get-nth tx *low-pat-length*))))       (successives 2 #'/= tx sx) ))(defun low-filters-vars ()  (arithm-ser 0 2 (max 0 (- (* 2  (apply 'max *low-pat-length*)) 2))))(defun find-constraint-fun (index form)  (let ((subexp (or (cdr (member index form :test #'voice-interval-test))                  (list (first (last form))))))         (if (numberp (first subexp)) (first (cdr subexp)) (first subexp))))(defun get-nth (index exp) (or (nth (floor index 2) exp) (first (last exp))))(defun check-low-filter (tx sx &rest base-notes)  (declare (ignore sx))   (setq base-notes (subseq base-notes 0 (1+ (get-nth tx *low-pat-length*))))  (funcall (find-constraint-fun (floor tx 2) *low-filter*)           (mapcar #'(lambda (note1 note2) (abs (- note1 note2)))                   base-notes (rest base-notes))))(defun choose-h-filter? (tx sx)  (and (>= tx (* 2 (1+ (get-nth (1- tx) *hi-pat-length*))))       (successives 1 #'= tx sx)))(defun h-filters-vars ()  (arithm-ser 0 1 (max 0 (* 2 (apply 'max *hi-pat-length*))))) (defun test-voice-h-filter (tx sx chord &rest chords)  (declare (ignore tx))  (setq chords (subseq (cons (list (get-span chord)) chords)                       0 (* 2 (1+ (get-nth sx *hi-pat-length*)))))  (funcall (find-constraint-fun (floor sx 2) *hi-filter*)           (let (res)             (do ((next-chords chords (rest (rest next-chords))))                 ((not (fourth next-chords)) res)               (push (abs (- (max-note (first next-chords) (second next-chords))                             (max-note (third next-chords) (fourth next-chords)))) res)))))(defun notes+ints-sources ()  (and *min-different-notes*       (arithm-ser 0 1 12)))(defun lower-diff-zone (zone) (first zone))(defun higher-diff-zone (zone) (second zone))(defun get-valid-zone (index zones) (subseq (member index zones :test #'>=) 0 3))(defun zone-chords (zone) (first (third zone)))(defun zone-notes (zone) (second (third zone)))(defun zone-octave-eq (zone) (third (third zone)))(defun zone-test-enabled? (index zones)  (let ((zone (get-valid-zone index zones)))    (and zone (>= index (+ (lower-diff-zone zone) (zone-chords zone) -1)))))(defun choose-notes+ints? (tx sx)  (and (successives 1 #'= tx sx)       (zone-test-enabled? (1- (floor tx 2)) *min-different-notes*)))(defun test-equal-notes (n1 n2)  (or (= n1 n2) (and *octave-equivalence* (zerop (rem (abs (- n1 n2)) 12)))))(defun check-notes+ints (tx sx &rest chords)  (declare (ignore sx))  (let* ((zone (get-valid-zone (1- (floor tx 2)) *min-different-notes*))        (min-notes (zone-notes zone)) (zone-chords (zone-chords zone))        res (dens 0))    (setf *octave-equivalence* (zone-octave-eq zone))    (for (k 0 2 (1- (* 2 zone-chords)))      (setq res (union (notes-of (nth k chords) (nth (1+ k) chords)) res :test #'test-equal-notes)            dens (+ 1 (length (remove 0 (nth k chords))) dens)))    (count-fail     (or (>= (length res) min-notes) (>= (length res) dens))     3)    ))(defun choose-equal-move? (tx sx)  (and (successives 1 #'= tx sx)       (> tx (* 2  (1+ (first (find-constraint-fun (floor sx 2) *maximum-equal-movement*)))))))(defun check-movement (tx sx &rest chords)  ;(declare (ignore tx))  (setq chords (subseq chords 0                        (* 2 (+ 2 (first (find-constraint-fun (floor sx 2) *maximum-equal-movement*))))))  (or   (do ((next-chords chords (rest (rest next-chords))) (res 0) diff)       ((not (fourth next-chords)) nil)     (setq diff (max-horizontal-interval 0 next-chords))     (if (< (abs (+ res diff)) (abs res))        (return t)       (setq res (+ res diff))))   (where-to-backtrack-move tx sx (fourth chords) (max-note (third chords) (fourth chords)))))(defun where-to-backtrack-move (tx sx min-note note)  (let ((amb (nth (1- (floor tx 2)) *ambitus-sup*))        (base min-note ))  (if (< amb note)    (setf *backtrack-to*           (cons (- sx 1)                #'(lambda (index domain)  (declare (ignore index))                    (dolist (node (get-nodes-at-depth domain 1 *filter-node-pred*))                      (if (> (max-note (form-tree-values node) base) amb) (assert-not-in-domain node)))))))))(defun check-melodic-profile (tx sx span base2 intervals base1)  (declare (ignore tx))  (let ((sign (or (nth (truncate sx 2) *melodic-profile*) (first (last *melodic-profile*)))))    (or (zerop sign)        (plusp (* sign (- (+ base2 (get-span span)) (apply '+ base1 intervals)))))))(defun two-single-notes? (index chords)  (and (zerop (first (nth index chords))) (zerop (first (nth (+ 2 index) chords)))       (not (or (rest (nth index chords)) (rest (nth (+ 2 index) chords))))))(defun first-movement-OK (max min chords)  (minusp (* (- max (max-note (first chords) (second chords)))             (- min (min-note (first chords) (second chords))))))(defun test-parallel-moves? (tx sx)  (and (successives 1 #'= tx sx)       (> tx (* 2 (1+ (first (find-constraint-fun (floor sx 2) *max-parallel-moves*)))))))(defun parallel-moves (tx sx &rest chords)  (declare (ignore tx))  (setq chords (subseq chords 0                        (* 2 (+ 2 (first (find-constraint-fun (floor sx 2) *max-parallel-moves*))))))  (let ((first-min-note (second chords)))    (count-fail    (or (first-movement-OK  (+ first-min-note (get-span (first chords)))                            first-min-note (cddr chords))        (do ((next-chords (cddr chords) (cddr next-chords)))            ((not (fourth next-chords)) nil)          (when (or (two-single-notes? 0 next-chords)                    (minusp (* (max-horizontal-interval 0 next-chords)                               (min-horizontal-interval 0 next-chords))))            (return t))))   4)))#|(defun check-stability (tx sx chord &rest chords)  (declare (ignore sx chords))  (let ((stab (coef-stability chord *stability-table* *octave-scale-table*)))    (and (>= stab (stability-inf tx)) (<= stab (stability-sup tx)))))|#(defun define-all-constraints ()  (setf *problem-constraints*        (remove nil                (list                  (and *valid-intervals*                      (make-full-constraint  :rule-name "base-mel"                                              :choose-pred #'(lambda (tx sx) (successives 2 #'/= tx sx))                                             :test-level 0 :source-vars '(0)                                             :predicate #'check-melodie-base))                 (make-monotone-constraint  :rule-name "ambitus"                                            :choose-pred #'(lambda (tx sx) (successives 1 #'= tx sx))                                            :test-level 1 :source-vars '(0)                                            :left-cut-point #'(lambda (list) (apply 'min list))                                            :right-cut-point #'(lambda (list) (apply 'min list))                                            :predicate #'check-ambitus)                 (and *low-filter*                      (make-HD-constraint   :rule-name "vi-filter"                                            :choose-pred #'choose-low-filter?                                             :test-level 1 :source-vars (low-filters-vars) :predicate #'check-low-filter))                 (and *hi-filter*                      (make-HD-constraint   :rule-name  "vs-filter"                                            :choose-pred #'choose-h-filter?                                             :test-level 1 :source-vars (h-filters-vars) :predicate #'test-voice-h-filter))                 (and *melodic-note-repets*                      (make-HD-constraint   :rule-name  "vs-rep"                                            :choose-pred #'choose-repet?                                              :test-level 1 :source-vars (repet-notes-vars) :predicate #'no-repet))                 (and *maximum-equal-movement*                      (make-HD-constraint   :rule-name "dir=ok"                                            :choose-pred  #'choose-equal-move?                                            :source-vars (arithm-ser 0 1 (max 0 (* 2  (1+ (or *max-max-equal* 0)))))                                            :predicate #'check-movement :test-level 1                                            :necessity-degree 1))                 (and *melodic-profile*                      (make-HD-constraint   :rule-name "melodic-profile"                                            :choose-pred  #'(lambda (tx sx) (and (successives 1 #'= tx sx) (> tx 2)))                                            :source-vars '(0 1 2)                                            :predicate #'check-melodic-profile :test-level 1                                            :necessity-degree 1))                 (and *valid-intervals*                      (make-HD-constraint  :rule-name "all-mel"                                           :choose-pred #'(lambda (tx sx) (and (successives 1 #'= tx sx) (> tx 2)))                                           :test-level 1 :source-vars '(0 1 2) :predicate #'check-melodie))                 (and *max-parallel-moves*                       (make-HD-constraint   :rule-name "mouv//"                                            :choose-pred #'test-parallel-moves?                                            :test-level 1                                             :source-vars (arithm-ser 0 1 (max 0 (* 2  (1+ (or *max-of-all-parallel* 0)))) )                                            :predicate #'parallel-moves                                            :necessity-degree 1))                 (and *fixed-notes-hash*                      (make-HD-constraint   :rule-name "span&fixed-notes"                                            :choose-pred #'test-span&fixed?                                            :test-level 1 :source-vars '(0) :predicate #'check-span&fixed-notes))                 (and *parallel-ints*                      (make-HD-constraint   :rule-name "int//-high"                                            :choose-pred #'test-//-ints?                                            :source-vars (get-//-source-vars)                                            :test-level 4 :predicate #'check//ints-high))                 (and *vertical-filters*                      (make-HD-constraint   :rule-name "int-vert"                                            :choose-pred #'(lambda (tx sx) (declare (ignore sx)) (zerop (mod tx 2)))                                            :source-vars '(0)                                            :test-level 4 :predicate #'(lambda (tx sx intervals &rest notes)                                                                         (declare (ignore tx sx notes))                                                                         (funcall *vertical-filters* intervals))))                 (and *fixed-notes-hash*                      (make-HD-constraint   :rule-name "fixed-notes"                                            :choose-pred #'(lambda (tx sx) (successives 1 #'= tx sx))                                            :test-level 4 :source-vars '(0) :predicate #'check-fixed-notes))                 (and *limite-grave*                      (make-HD-constraint   :rule-name "pass-band"                                            :choose-pred #'(lambda (tx sx) (successives 1 #'= tx sx))                                            :test-level 4 :source-vars '(0) :predicate #'check-base-limit))                 (and *valid-intervals*                      (make-HD-constraint   :rule-name "middle-mel"                                            :choose-pred #'(lambda (tx sx) (and (successives 1 #'= tx sx) (> tx 2)))                                            :test-level 4 :source-vars '(0 1 2) :predicate #'check-middle-melodie))                 (and *min-different-notes*                      (make-HD-constraint   :rule-name "renouv-haut"                                            :choose-pred #'choose-notes+ints?                                            :test-level 4 :predicate #'check-notes+ints                                            :source-vars (notes+ints-sources)                                            :necessity-degree 1))                 (and *parallel-ints*                      (make-HD-constraint   :rule-name "int//-low"                                            :choose-pred #'test-//-ints?                                            :source-vars (get-//-source-vars)                                            :test-level 4 :predicate #'check//ints-low))                 ))));;(mapcar #'(lambda (c) (rule-name c)) *problem-constraints*);;;==============================================================;;;domain generation. Uses trees as representation of domain sets(defvar *span-table-size* 128)(defconstant *1+interval-nodes* 2)(defconstant *mark-on* 1)(defconstant *mark-off* -1)(defvar *bucket-sort-vector* ());;a linear time sort(defun bucket-sort (x)  (dolist (i x) (incf (vref *bucket-sort-vector* i))))(defun equal-sorted (source target)  (let ((result         (when (dolist (i target t)                 (if (zerop (vref *bucket-sort-vector* i))                   (return nil)                   (decf (vref *bucket-sort-vector* i))))           (dolist (j source t)             (unless (zerop (vref *bucket-sort-vector* j)) (return nil))))))    (dolist (j source) (setf (vref *bucket-sort-vector* j) 0))    result))(defun unique-intervals? (x y)  (bucket-sort x) (equal-sorted  x y));;chord domains are 3 levels trees: root->chord-span->rest-of-the-chord;;e.g. chords ((7 4 7 11) (7 4 4 7) (7 4 7 4)) are represented as the tree:;;                         root;;                        /   \;;                       /     \;;                     29      22             <ambitus & melodic movement level>;;                    /         |;;             (7 4 7 11)    ((7 4 4 7)(7 4 7 4))    <chord filtering level>;;(defun AB1-tree-domain (intervals unary-constraints densities index)  (let ((others         (when (member 1 densities :test #'=)           (setq densities (remove 1 densities))           (list (make-tree-domain                  :tree-data 0                  :subtrees (list (make-AB1-leaf (series-from-list '((0))))))))))    (remove-useless-subtrees     (make-tree-domain       :tree-data 'root      :subtrees       (permut-random       (append others                (and densities                    (form-equal-span-trees unary-constraints densities                                           intervals index))))))))(defun set-bucket-sort-vector (ints)  (setf *bucket-sort-vector*         (make-array (list (1+ (apply 'max ints))) :initial-element 0)))(defun get-special-node (&optional (mark -1))    (make-AB1-leaf () :mark mark))(defun get-low-dens-node (low-int)  (make-tree-domain :tree-data low-int :subtrees                    (list (make-tree-domain :tree-data (list low-int)))))(defvar *span-vector-size* '(128))(defun merge-span-vectors (target-vector from-vector)  (dotimes (index (first (array-dimensions target-vector)))    (when (vref from-vector index)      (setf (vref target-vector index)            (nconc (vref target-vector index) (vref from-vector index))))))(defun form-equal-span-trees (unary-constraints densities intervals index)  (let (shuffled-series        (span-vector (make-array *span-vector-size* :initial-element ())))    (dolist (one-dens densities)      (merge-span-vectors span-vector            (form-all-interval-lists (- one-dens 1)                                     intervals unary-constraints                                     (repetitions-dans-accord index one-dens))))    (dotimes (index (first *span-vector-size*) shuffled-series)      (when (vref span-vector index)        (push (make-tree-domain                :tree-data index               :subtrees                (list (make-ab1-leaf  (apply #'append-series                                            (permut-random (mapcar #'all-permutations                                                                  (vref span-vector index))))))               )              shuffled-series))      )));(time (form-equal-span-trees #'(lambda (chord) t) '(5) '(1 2 3 4 5 6 7 8 9 10 11))  );(time (vref (form-all-interval-lists 10 '((1 2 3 4 5 6 7 8 9 10 11)) #'(lambda (chord) (< (apply '+ chord) 33)) 4) 0) );(length (make-base-lists 7 '( 2  4 5  7 ) 3)    )(defun  push-to-span-vector (span-vector list)  (dolist (int list) (push int (vref span-vector (apply '+ int)))))(defun form-all-interval-lists (size ints unary-constraints reps)  (let ((span-vector (make-array *span-vector-size* :initial-element ()))        the-series        (base-lists (mapcan #'(lambda (ints) (make-base-lists size (pw::rem-dups ints) reps)) ints)))    (if (= reps 1)       (push-to-span-vector span-vector base-lists)      (progn        (dolist (one-list base-lists)          (setq the-series nil)          (dolist (item one-list)            (push (all-replacements one-list item reps)                  the-series))          (push-to-span-vector span-vector                               (remove-if-not unary-constraints (mapcan #'series-to-list the-series)))  )        (dotimes (index (first *span-vector-size*))          (when (> (length (vref span-vector index)) 1)            (set-bucket-sort-vector (apply 'append ints))            (setf (vref span-vector index)                  (my-remove-dups (vref span-vector index) #'unique-intervals?))))        ))    span-vector))(defun make-base-lists (size ints reps)  (cond ((> (length ints) size) (series-to-list (combinations ints size)) )        ((>= (* (length ints) reps) size)         (do* ((rest-ints ints (append ints rest-ints)))              ((>= (length rest-ints) size)               (list (butlast rest-ints (- (length rest-ints) size))))))));;;==========================================================================================(defun repetitions-dans-accord (index dens)  (or (second (assoc  dens (find-in-time-expr index *rep-by-density-a-list*) :test #'=)) (1- dens)))(defun within-ambitus? (index amb-inf amb-sup)  #'(lambda (list) (<= (apply '+ (nth index amb-inf) list) (nth index amb-sup))))(defun coef-homogeneity? (index homog)  #'(lambda (chord) (and (>= (coef-homog chord) (first (nth index homog)))                         (<= (coef-homog chord) (second (nth index homog))))))(defun permut-invariant-constraints (index amb-inf amb-sup homog)  (let ((ind1 (if (>= index (length amb-inf)) (1- (length amb-inf)) index))        (ind2 (if (>= index (length homog)) (1- (length homog)) index)))    (eval     `(function (lambda (chord)                   (and (funcall ,(within-ambitus? ind1 amb-inf amb-sup) chord)                       ,(or (not homog) `(funcall ,(coef-homogeneity? ind2 homog) chord))))))))(defun listify (list) (if (consp (first list)) list (list list)))(defun the-fixed-notes-in (fixed index) (sort (copy-list (gethash index fixed)) '< ))(defun make-fixed-note-domain (notes)  (let ((intervals (mapcar #'pw::x->dx notes)) span-list span pair node-list)    (dolist (int intervals)      (setq span (apply '+ int))      (if (setq pair (assoc span span-list))        (push int (rest pair))        (push (list span int) span-list)))    (make-tree-domain      :tree-data 'root     :subtrees (dolist (element span-list node-list)                 (push                  (make-tree-domain :tree-data (first element)                                     :subtrees (list (make-ab1-leaf  (series-from-list (rest element)))))                  node-list)))))(defun filter-by-possible-intervals (list ints)  (let ((l-ints (if (consp (car ints)) ints (list ints))))    (remove-if-not #'(lambda (item)                       (let ((interv (pw::x->dx item)))                         (dolist (int l-ints nil)                           (if (pw::included? interv int) (return t)))))                   list)));;;;;;;;;;;======================================================================(defclass C-chord-domain ()  ((base-notes :initform nil :initarg :base-notes :accessor base-notes)   (the-intervals :initform nil :initarg :the-intervals :accessor the-intervals)))(pw::defunp chord-domain ((bases list (:value '(60))) (ints list (:value '(4 7)))) nil "represents a list of base notes & a list of intervals as a suitable object"  (make-instance 'C-chord-domain :base-notes bases :the-intervals ints))(defmethod construct-valid-chords ((self C-chord-domain) amb-inf amb-sup)  (let* ((bases (remove amb-inf (base-notes self) :test #'>))         (intervals (remove-if #'plusp (the-intervals self)                                :key #'(lambda (item) (- (apply '+ amb-inf item) amb-sup)))))    (cons (make-ab2-leaf bases) (set-up-intervals-tree intervals))))    (defun set-up-intervals-tree (intervals)   (let ((span-vector (make-array *span-vector-size* :initial-element ()))        shuffled-series)    (dolist (int intervals)      (push int (aref span-vector (apply '+ int))))    (make-tree-domain      :tree-data 'root     :subtrees (dotimes (index (first *span-vector-size*) shuffled-series)                 (when (aref span-vector index)                   (push (make-tree-domain :tree-data index                                           :subtrees                                            (list (make-ab1-leaf  (series-from-list (vref span-vector index)))))                         shuffled-series))))))(defun note-represent? (list)  (and (consp list) (standard-chords? (first list)) list))(defmethod standard-chords? ((self cons)) t)(defmethod standard-chords? ((self t)) nil)(defun set-interval-representation (data-vector struct size amb-inf amb-sup)  (dotimes (index size)    (setf (aref data-vector index)          (construct-valid-chords (get-nth (+ index index) struct)                                  (get-nth (+ index index) amb-inf) (get-nth (+ index index) amb-sup))))  data-vector);;;;;;;;==========================================================================;;;; Constructs the vector of objects representing the chord's domains.;;;; Several possibilities: 1) Base-note + intervals representation (the standard);;;;                        2) user supplied sequence of lists of chords.;;;;                        3) User supplied sequence of objects (using the PW box "chord-domain") (defun def-domains (vert-ints dens accords amb-inf amb-sup homog &optional previous fixed)  (or (note-represent? previous)  ;;user supplied lists of chords?      (if previous                ;;User supplied sequence of objects?        (set-interval-representation (setf *intervalles* (make-array (list accords))) previous accords amb-inf amb-sup)        (multiple-value-bind (dens-inf dens-sup) (construct-amb-lists dens accords)          (setf *density* (make-array (list accords)))          (setf *intervalles* (make-array (list accords)))          (let* ((verticals (if (consp (first vert-ints)) vert-ints (list vert-ints)))                 (default-vertical (first (last verticals)))                 fixed-notes lower-dens higher-dens all-possibles)            (dotimes (var accords t)              (setq lower-dens (nth var dens-inf) higher-dens (nth var dens-sup))              (cond ((and fixed (setq fixed-notes (remove-duplicates (the-fixed-notes-in fixed var)))                          (= lower-dens higher-dens) (= (length fixed-notes) lower-dens))                     (setf (vref *density* var) (list 'nodens (list (apply 'min fixed-notes)) lower-dens))    ;;no density needed in this case                     (setf (vref *intervalles* var) (make-fixed-note-domain (list fixed-notes))))                    ((and fixed fixed-notes (= lower-dens higher-dens) (> (length fixed-notes) lower-dens))                     (setq all-possibles (filter-by-possible-intervals                                          (mapcar #'(lambda (list) (sort list '<))                                                  (series-to-list (combinations fixed-notes lower-dens)))                                          (or (nth var verticals) default-vertical)))                     (unless all-possibles (return nil))                     (setf (vref *density* var) (list 'nodens (mapcar #'first all-possibles) lower-dens))                      (setf (vref *intervalles* var) (make-fixed-note-domain all-possibles)))                    (t (setf (vref *intervalles* var)                             (AB1-tree-domain (remove-duplicates (listify (or (nth var verticals) default-vertical))                                                                 :test #'equal)                                              (permut-invariant-constraints var amb-inf amb-sup homog)                                              (setf (vref *density* var)                                                    (arithm-ser lower-dens 1 higher-dens))                                              var))   ))              (when (not-in-domain? (vref *intervalles* var)) (return nil))))))))(defun base-note-already-given (form) (eq (first form) 'nodens))(defun hash-fixed-notes (list size)  (if list    (let ((table (make-hash-table :size size))          (the-list list) notes)      (while the-list        (setq notes nil)        (while (not (listp (car the-list)))          (push (pop the-list) notes))        (dolist (position (pop the-list))          (setf (gethash position table)                (append notes (gethash position table)))))      table)));;(hash-fixed-notes '(23 (0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48)) 4);;;;============================;;;; Ambitus expressions can be: 1) a number of semitones 2) a list of pairs (low high);;;;                             3) a multi-bpf   4) an interpolation expression.(defmethod construct-amb-lists ((self number) n)  (values (make-list n :initial-element 0)          (make-list n :initial-element self)))(defmethod construct-amb-lists ((self cons) n)  (cond ((and (numberp (first self)) (not (consp (second self))))         (values (make-list n :initial-element (first self))                 (make-list n :initial-element (if (second self)  (second self) (first self)))))        ((consp (first self))         (let ((length (if (>= (length self) n) 0 (- n (length self)))))           (values (append (mapcar #'first self)                            (make-list length :initial-element (first (first (last self)))))                   (append (mapcar #'second self)                            (make-list length :initial-element (second (first (last self))))))))        ((subtypep (type-of (first self)) 'pw::C-break-point-function)         (let ((bpfA (construct-amb-lists (first self) n))               (bpfB (construct-amb-lists (second self) n)))           (if (> (apply 'max bpfA) (apply 'max bpfB))             (values bpfB bpfA)             (values bpfA bpfB))))        (t         (let (x-vals y-vals bpf-low bpf-hi                      (series (arithm-ser 0 1 (1- n))))           (while self             (push (pop self) x-vals)             (push (pop self) y-vals))           (setq x-vals (nreverse x-vals)                 y-vals (nreverse y-vals))           (setq bpf-low (pw::make-break-point-function x-vals (mapcar #'first y-vals))                 bpf-hi (PW::make-break-point-function x-vals (mapcar #'second y-vals)))           (values (mapcar #'(lambda (time) (pw::bpf-out bpf-low time ())) series)                   (mapcar #'(lambda (time) (pw::bpf-out bpf-hi time ())) series))))))(defmethod construct-amb-lists ((self pw::C-break-point-function) n)  (pw::transfer self (arithm-ser 0 1 (1- n))));;;====================================;;;pre-filter domains by unary constraints(defun filter-domains (function n) )   ;; no unary constraints, for the moment...(defun min-chord (intervs dens repets)  (unless (consp (first intervs)) (setq intervs (list intervs)))  (let (res to-give chord (min-dens (1- (apply 'min dens))))    (dolist (ints intervs to-give)      (setq chord            (dolist (one-int ints res)              (setq res (append (make-list repets :initial-element one-int) res))              (if (>= (length res) min-dens)                (return (nthcdr (- (length res) min-dens) res)))))      (push (apply '+ chord) to-give) )    (apply #'min to-give)))(defun list-make-series (m n)  (unless (> m n)    (cons m (list-make-series (1+ m) n))))(defun construct-min-chord (amb-inf amb-sup repets ints dens index)  (let ((base-hash (and *fixed-notes-hash* (gethash index *fixed-notes-hash*)))        (max (max amb-inf (- amb-sup (min-chord ints dens repets)))))    (list-make-series amb-inf         (if base-hash (min (apply 'min base-hash) max) max))))(defun get-min-repet (a-list dens)  (apply #'min (mapcar #'second (mapcar #'(lambda (d) (or (assoc d a-list) (list d (1- d)))) dens))));;;=====================;;a function to call when a solution is found(defun succeed (d &optional n alpha user-alpha)  (setf *done-for-user*        (progn           (push (if alpha (list alpha (nicely-put d (or n *num-vars*)))                    (nicely-put d (or n *num-vars*))) *all-solutions*)          (format t "~%une!!! value=~S maximized-val=~S~%" alpha (float user-alpha))          (> (length *all-solutions*) *max-num-solns*))));;a function to accumulate partial results(defvar *partial-results* ())(defun user-accumulate (k value &optional alpha)  (let (    ;(value (nicely-put value))        (length (length *partial-results*)))    (if (<= k length)      (setf (nth (- length k) *partial-results-save*) value)      (progn (push value *partial-results-save*)             (setf *partial-results* (mapcar #'nicely-put *partial-results-save*))))));;a function to display number of chords found(defun user-display-process (k value &optional alpha)  (declare (ignore value))  (if *standard-chord-representation*    (when (zerop (mod k 2))      (format t "chords: ~S " (floor k 2)))    (format t "chords: ~S " k)))(pw::defunp part-sols ()list "Returns the maximum number of chords satisfying the constraints thatthe box harmonic-constraints was able to find before it was stoppedby <Break> or <Abort> "  (reverse (if (consp (first *partial-results*))  *partial-results* (rest *partial-results*))))(defun construct-bands (exp)  (and exp       (let (res)         (do ((item (car exp) (car exp)))             ((null exp) (nreverse res))           (push (pop exp) res)           (unless (consp item)              (push (pop exp) res))           (push (get-vertical-bands (pop exp)) res)))))(defun get-vertical-bands (exp)  (let (res couple zones)    (do*  ((subexp exp (cdr subexp)) (item (car exp) (car subexp)))          ((null subexp) (list (nreverse zones) (nreverse res)))      (if (consp item)        (progn (push (nreverse couple) zones) (setq couple nil)               (push  (set-domain-constraint-fun item) res))        (push item couple)))))(defun find-in-time-expr (index expr)  (if (numberp (first expr))    (find-constraint-fun index expr)    expr))(defun get-max-advance (melodic) 2 )    ;;no hope (space) for this: (max (- (* 2 melodic) 2) 3));;;building a domain tree from a given list of possible values(defun chords-of (list) (make-AB1-leaf (series-from-list (pw::g/ list 100))))(defun real-item (index list)   (let ((length (length list)))    (nth (if (>= index length) (1- length) index) list)));;;==============================;;Specific stuff: Maximizing common notes between chords. Not really part of the system.(defun make-saved-common (n)  (setf *saved-common* (make-array (list (1+ n)) :initial-element 0)))(defvar *saved-common*())(defvar *min-common* 0)(defvar *saved-common-max*())(defvar *user-min-beta* 0)(defun make-saved-common (n)  (setf *saved-common* (make-array (list (1+ n)) :initial-element 0))  (setf *saved-common-max* (make-array (list (1+ n)) :initial-element 0))  (setf *min-common* (/ *user-min-beta* n)))(defun reasonable-expectation (alpha beta n k)  (and (> alpha beta)        (or (= k 1) (= k n) (>= (aref *saved-common* k) beta)           (>= (aref *saved-common* k) (round (*  *min-common* k))))       (>= (aref *saved-common* k) (aref *saved-common-max* k))      ))(defun common-notes (alpha k n chord1 &rest inputs)  (let ((base-incr (- alpha (length chord1))))    (if (>= k 2)      (let ((common  (length (intersection chord1 (first inputs)))))        (setf (aref *saved-common* k) (+ (aref *saved-common* (1- k)) common))        (setf (aref *saved-common-max* k) (max (aref *saved-common* k) common))        (max (+ common base-incr) (aref *saved-common* k)))      base-incr)));;;================================;;go through constraints looking for necessity value (if any)(defun assign-constraints-necessity ()  (let (constraint)    (dolist (pair *importance-list*)      (when         (setq constraint               (first (member (first pair) *problem-constraints*                              :key #'rule-name :test #'string=)))        (setf (necessity-degree constraint) (rest pair))))))(defun intervals-given? (interval-vector)  (consp (aref interval-vector 0)));;=================================================;;A real mess (on parole by historical circunstances).;; Fill out global vars from user supplied constraint parameters. Construct all domains. Call AC-5 to reduce them;; and then the forward checking backtrack engin for exploration.(defun probleme-AB1 (method accords amb repet min-diff base-limit-thirds                            int// max=move prev-solution)  (setf  *all-solutions* nil)  (setf *domains* (make-array (list (1+  (* 2 accords)))))  (setf *num-vars* (* 2 accords)        *melodic-note-repets* (if (numberp repet) (list 0 accords (list repet)) repet)        *max-note-repets*        (and repet (apply 'max (compute-maximum-patterns *melodic-note-repets* #'first)))        *min-different-notes* min-diff        *octave-equivalence* (third min-diff)        *limite-grave* (construct-bands base-limit-thirds)        *parallel-ints* (and int// (form-constraint-functions int//))        *max-//-ints* (compute-maximum-patterns int// #'get-max-patterns-length)        *parallel-length* (get-max-patterns-length int//)        *maximum-equal-movement* (get-max=move-form max=move accords)        *melodic-profile* (get-melodic-profile max=move accords)        *max-max-equal*         (and max=move (apply 'max (compute-maximum-patterns *maximum-equal-movement* #'first)))        *no-density-checking*  t        *done-for-user* nil        )  (setf *max-advance* (get-max-advance *melodic-note-repets*))  (setf *ambitus-sup* (second amb))  (setf *ambitus-inf* (first amb))  (if prev-solution (define-given-chords-constraints) (define-all-constraints))  (assign-constraints-necessity)  (setf *standard-chord-representation* (not prev-solution))    (cond (prev-solution                                                    ;;user supplied chords         (dotimes (index accords)           (setf (aref *domains* (1+ index))                 (chords-of (real-item index prev-solution)))))        ((intervals-given? *intervalles*)                                 ;;user supplied base-notes + intervals.         (do ((index 1 (+ 2 index))) ((> index *num-vars*))           (setf (aref *domains* index) (first (vref *intervalles* (floor index 2))))           (setf (aref *domains* (1+ index)) (rest (vref *intervalles* (floor index 2))))))        (t                                                                ;;no previous chords given         (do ((index 1 (+ 2 index)) (current-dens)) ((> index *num-vars*))           (setq current-dens (vref *density* (floor index 2)))           (setf (aref *domains* index)                 (if (base-note-already-given current-dens)                   (make-AB2-leaf (second current-dens))                   (make-AB2-leaf                    (permut-random                      (construct-min-chord                       (nth (floor index 2) (first amb)) (nth (floor index 2) (second amb))                      (get-min-repet  (find-in-time-expr (floor index 2) *rep-by-density-a-list*) current-dens)                      (nth (floor index 2) *vertical-intervals*) current-dens (floor index 2))))))           (setf (aref *domains* (1+ index))                 (vref *intervalles* (floor index 2))))))  (setf *intervalles* nil)   ;;give some stuff to GC  (with-statistics)  (if prev-solution (setf *num-vars* accords))  (when (HD-AC5-consistency *problem-constraints* *domains* *num-vars* *max-advance*)    (make-saved-common *num-vars*)    (print "exploring...")    (funcall method (append *problem-constraints* *user-defined-constraints*)   ;;;*problem-constraints*             *domains* *num-vars*             :succeed-fun #'succeed :accum-fun #'user-accumulate              :display-fun #'user-display-process :advance *max-advance*             :min-beta *min-beta*              :max-time *maximum-search-time*             :user-alpha *alpha-maxval*  ;accords             :maximize-function *optimize-fun* ;;#'common-notes             :user-test-fun *alpha-test-fun*  ;;#'reasonable-expectation             :user-beta *alpha-minval*             ))  );; for parsing different equal movement expressions(defmethod get-max=move-form ((self number) &optional n)  (list 0 n (list self)))(defmethod get-max=move-form ((self cons) &optional n) (declare (ignore n)) self)(defmethod get-max=move-form ((self null) &optional n) (declare (ignore n)) self)(defmethod get-max=move-form ((self pw::C-break-point-function) &optional n)  (declare (ignore n)) nil)(defmethod get-melodic-profile ((self pw::C-break-point-function) &optional n)  (pw::x->dx (pw::transfer self (arithm-ser 0 1 (1- n)))))(defmethod get-melodic-profile ((self t) &optional n) (declare (ignore n)) nil)  ;;;form boolean functions equivalent to the supplied constraint expressions.(defun form-std-expr (hor-intervals accords)  (and hor-intervals       (if (consp (first (last hor-intervals)))         hor-intervals   (list 0 (1- accords) hor-intervals))))(defun form-constraint-functions (constraint-expr)  (if (numberp (first constraint-expr))    (let ((expr (copy-list constraint-expr)))      (do* ((i 2 (+ i 3))             (fun (set-domain-constraint-fun (set-pat-length (nth i expr)))                 (set-domain-constraint-fun (set-pat-length (nth i expr)))))            ((>= i (length expr)) expr)        (setf (nth i expr) fun)))    (list 0 most-positive-fixnum (set-domain-constraint-fun (set-pat-length constraint-expr)))))(defun compute-maximum-patterns (expr fun)  (if (numberp (first expr))    (do* ((i 2 (+ i 3)) (max (funcall fun (nth i expr))                             (funcall fun (nth i expr)))          (res (list max) (cons max res)))         ((>= i (1- (length expr))) (nreverse res)))    (list (get-max-patterns-length expr))));;user constraints talk about chords. Make stdrd representation (base-notes & intervals) talk the same lang.(defmethod form-user-constraint-pred ((self C-hd-constraint))  (let ((offset (if (= (advance self) most-positive-fixnum) 2 (* 2 (advance self)))))    (setf (predicate self)          (eval `(function (lambda (tx sx &rest chords) (declare (ignore sx))                        (apply ,(predicate self) (/ tx 2) (/ (- tx ,offset) 2)                                 (cons (pw::dx->x (second chords) (first chords))                                       (do ((i (1- (length chords)) (- i 2)) (res nil res))                                           ((< i ,offset) res)                                         (push (pw::dx->x (nth i chords)                                                          (nth (1- i) chords)) res))))))))));; user supplied constraints are always chosen for consecutive chords.(defmethod form-user-constraint-choose ((self C-hd-constraint))  (setf (choose-pred self)        #'(lambda (tx sx)             (and (zerop (mod tx 2))                 (>= sx (if (= (advance self) most-positive-fixnum) 2 (* 2 (advance self))))                 (= (- tx sx) 1)))))(defmethod get-user-constraints ((self C-hd-constraint) prev)  (unless prev    (form-user-constraint-pred self)    (form-user-constraint-choose self))  self)(defmethod get-user-constraints ((self cons) prev)  (pw::ask-all self #'get-user-constraints prev))(defmethod get-user-constraints ((self null) prev) (declare (ignore prev)) nil)(defun set-necessity-item (necessity rule-names)  (dolist (name rule-names)    (push (cons name necessity) *importance-list*)))(defun set-importance (expression &rest names)  (if (and (consp expression) (symbolp (first expression))             (string= (first expression) 'n))    (progn (set-necessity-item (second expression) names)           (third expression))    expression));;;the big box(pw:defunp harmonic-constraints           ((n-solutions fix>0 (:view-size #@(80 14)))            (n-accords fix>0(:view-size #@(80 14)))             (ambitus midics? (:value 1 :view-size #@(80 14)))            (densite list (:value '(1) :view-size #@(80 14)))            (int-vert list (:value '(1) :view-size #@(80 14)))            (int-hori list (:value '() :view-size #@(80 14)))            (int-vert-filt list (:value '() :view-size #@(80 14)))            (vs-filt-hori list (:value '() :view-size #@(80 14)))            (vs-seuil-rep list (:value '() :view-size #@(80 14)))            (vi-filt-hori list (:value '() :view-size #@(80 14)))            (fixed-notes list (:value '() :view-size #@(80 14)))            (rep-par-dens list (:value '() :view-size #@(80 14)))            (renouv-haut list (:value '() :view-size #@(80 14)))             (filt-pas-band list (:view-size #@(80 14) :value '()))            (int//forbid list (:value '() :view-size #@(80 14)))            (nb-mouv//ok list (:value '() :type-list (fixnum)                                       :view-size #@(80 14)))            (nb-dir=ok  list (:value '() :view-size #@(80 14)))            &optional             (user-constraint list (:value '() :view-size #@(80 14)))            (prev-solution list (:value '() :view-size #@(80 14)))            (paramtres list (:value '() :view-size #@(80 14)))            ) list           "constraint satisfaction: Graph exploration"  (setf *importance-list* nil)   ;;necessity degree of constraints  (setq int-hori (set-importance int-hori "base-mel" "middle-mel" "all-mel")        int-vert-filt (set-importance int-vert-filt "int-vert")        vs-filt-hori (set-importance vs-filt-hori "vs-filter")        vs-seuil-rep (set-importance vs-seuil-rep "vs-rep")        vi-filt-hori (set-importance vi-filt-hori "vi-filter")        fixed-notes (set-importance fixed-notes "fixed-notes")        renouv-haut (set-importance renouv-haut "renouv-haut")        filt-pas-band (set-importance  filt-pas-band "pass-band")        int//forbid (set-importance int//forbid "int//-low" "int//-high")        nb-mouv//ok (set-importance  nb-mouv//ok "mouv//")        nb-dir=ok (set-importance  nb-dir=ok "dir=ok")        user-constraint (set-importance user-constraint "user"))  (let ((*maximum-search-time* (or (first paramtres) *maximum-search-time*))        (*min-beta* (or (second paramtres) *min-beta*))        (*optimize-fun* (or (third paramtres) *optimize-fun*))        (*alpha-test-fun* (or (fourth paramtres) *alpha-test-fun*))        (*alpha-maxval* (or (fifth paramtres) *alpha-maxval*))        (*alpha-minval* (or (sixth paramtres) *alpha-minval*))        (*fixed-notes-hash* (hash-fixed-notes fixed-notes (1- n-accords))))    (setf *partial-results* nil *partial-results-save* nil *Intervalles* nil *domains* nil)  ;;free some old stuff for GC    (setf *rep-by-density-a-list* rep-par-dens)    (setf *valid-intervals* (form-std-expr int-hori n-accords)          *vertical-intervals* (if (consp (first int-vert)) int-vert (list int-vert)))    (setf *user-defined-constraints* (get-user-constraints (pw::list! user-constraint) (note-represent? prev-solution)))    (print "Building&reducing domains...")    (multiple-value-bind (amb-inf amb-sup) (construct-amb-lists ambitus n-accords)      (unless (set-domain int-vert densite n-accords amb-inf amb-sup nil prev-solution *fixed-notes-hash*)        (ed-beep)        (format t "no solution. Probably a wrong ambitus ")        (setf *Intervalles* nil))      (setq ambitus (list amb-inf amb-sup)))    (when (or *Intervalles* (note-represent? prev-solution))      (let ((*ignore-shorter-expressions* t))        (setf *vertical-filters*               (and int-vert-filt (set-domain-constraint-fun int-vert-filt))))      (let* ((*max-num-solns* (1- n-solutions))             (*max-parallel-moves* (if (numberp nb-mouv//ok) (list 0 n-accords (list nb-mouv//ok))                                       nb-mouv//ok))             (*max-of-all-parallel*               (and nb-mouv//ok (apply 'max (compute-maximum-patterns *max-parallel-moves* #'first))))             (*ignore-shorter-expressions* nil)             (*hi-filter* (and vs-filt-hori (form-constraint-functions vs-filt-hori)))             (*low-filter* (and vi-filt-hori (form-constraint-functions vi-filt-hori)))             (*low-pat-length*              (compute-maximum-patterns vi-filt-hori #'get-max-patterns-length))             (*hi-pat-length*              (compute-maximum-patterns vs-filt-hori #'get-max-patterns-length))             )        (time          (probleme-AB1 #'soft-constr::soft-forward-check;;#'HD-forward-check                       n-accords ambitus vs-seuil-rep                       renouv-haut filt-pas-band int//forbid nb-dir=ok (note-represent? prev-solution))         )        *all-solutions*))))(pw::defunp set-domain ((v-ints list (:value '(4 7 11)))                        (dens list (:value '(3 4 5)))                        (n fix) (amb-inf list) (amb-sup list) (homog list)                        &optional (previous list) (fixed list)) no-connection  "set domain of variables for constraints exploration"  (def-domains v-ints dens n amb-inf amb-sup homog previous fixed));;====================================;; set-up chords from intervals list and a base note(defun form-chords (base sol)  (let (res        (sol (if (consp (second (second sol))) (first (rest sol)) sol)))    (if (numberp (first sol))      (progn        (while sol          (push (my-remove-dups (pw::dx->x (+ base (* 100 (pop sol)))                                           (pw::l* 100 (pop sol)))) res))        (nreverse res))      (pw::g+ base (pw::g* sol 100)))))(pw:defunp construct-sols ((base-n midic) (sols list)) list  "Takes in <sols> the output of the harmonic-constraints box (i.e lists of pairs [base-note, intervals]) and outputs lists of chords represented in midics, transposed according to <base-n> "  (mapcar #'(lambda (sol) (form-chords base-n sol)) sols))(pw::defunp interval-interp ((exp list (:value '(0 (4 7) 10 (7 11))))                             &optional (curve fix>=0 (:value 1))) list "<exp> is a list of the form (index1 <list1> index2 <list1> ... indexn <list1>)where the indexes represent positions in a sequence. Returns a list of lengthindexn + 1 where each <list> is in the position given by the index to its leftand positions within two consecutive indexes are filled with interpolationsbetween their associated <list>'s. For example<exp> = (0 (4 7) 10 (7 11)) gives((4 7) (4 7) (5 8) (5 8) (5 9) (6 9) (6 9) (6 10) (6 10) (7 11) (7 11)).<curve> is an optional value for the type of interpolation curve,[1 = straight line,    <1 = convex,    >1 = concave].  "  (let (interpols)    (cons      (first (rest exp))     (do* ((subexps exp (cddr subexps)) (from (first exp) (first subexps))           (from-list (second exp) (second subexps))           (to (third exp) (third subexps)) (to-list (fourth exp) (fourth subexps)))          ((null to-list) interpols)       (setq interpols              (nconc interpols                     (rest (pw::g-round (pw::interpolation  from-list to-list                                                            (1+ (- to from)) curve 1)))))))));;================================;;Specific stuff (Antoine Bonnet)(defun form-constraint-dyn (constraint-expr curve)    (let ((expr (copy-list constraint-expr)))      (do* ((i 2 (+ i 3))            (fun (interval-interp (nth i expr) curve)                 (interval-interp (nth i expr) curve)))           ((>= i (length expr)) expr)        (setf (nth i expr) fun))))(pw::defunp dynamique-interp ((accords list) (exp list (:value '(0 (4 7) 10 (7 11))))                             &optional (curve fix>=0 (:value 1))) list " "  (let ((new-exp (form-constraint-dyn exp curve)) inter)    (do ((chords accords (rest chords)) (i 0 (1+ i))) ((null chords) accords)      (dolist (note (pw::notes (first chords)))        (setq inter (find-constraint-fun (floor (pw::midic note) 100) new-exp))        (if inter (setf (pw::vel note) (first (nth i inter))))))))(pw::defunp chan-reg ((accords list) (reg-exp list)) list " "  (dolist (accord accords)    (dolist (note (pw::notes accord))      (setf (pw::chan note) (first (find-constraint-fun (floor (pw::midic note) 100) reg-exp)))))  accords)(pw::defunp rand-expl ((list list) (test list (:value '())) (times fix>0)) list " "  (time    (let (res)     (dotimes (i times)       (push        (do ((x list (pw::permut-random list))) ()          (if (funcall test x) (return x))) res))     res)))(pw::defunp stability ((chord list) (weights list) (octave-scalers list)) numbers?      "computes stabilities of a chord or list of chords"  (let ((res (mapcar #'(lambda (ch) (coef-stability ch weights octave-scalers))                     (if (consp (first chord)) chord (list chord)))))    (if (consp (first chord)) res (first res)))) ;;======================================(pw::defunp ch->domain ((chords list) &optional (quarter fix>=0)) list "transforms a standard chord format to a base-note+intervals domain representation"  (if (plusp quarter)    (mapcar #'(lambda (chord)                 (list (+ (* 2 (floor (first chord) 100)) (floor (rem  (first chord) 100) 50))                      (or (pw::g/ (pw::x->dx chord) 100) '(0)))) chords)  ;;to be corrected, quarter tones!!!!!!!!    (mapcar #'(lambda (chord) (list (floor (first chord) 100)                                    (or (pw::g/ (pw::x->dx chord) 100) '(0)))) chords)))(pw::defunp set-param ((maxtime fix>0 (:value 120))                        &optional                         (min-nec fix/float) (opt-fun list (:value '() :type-list ()))                        (test-fun list (:value '() :type-list ()))                        (maxval fix/float (:value 1)) (minval fix/float)) list" A box that can be connected to the 'paramtres' entry of the harmonic-constraints box.It sets maximum search time, minimum requested necessity value, optimizing function,'good' partial solution value testing function, maximum initial value of optimizingfunction and minimum required value of optimizing function."  (list maxtime min-nec opt-fun test-fun maxval minval))(pw::defunp set-structure ((struct list) (posn fix>=0)                       (value fix/float (:value 0 :type-list ()))) list"sets the posn'th element of struct with val"(setf (nth posn struct) value)struct)(pw::defunp funct-and ((exp1 list) (exp2 list) &rest (exp* list)) list            "usual and"  (or (and exp1 exp2) (dolist (one-exp exp* (car (last exp*))) (unless one-exp (return nil)))))(pw::defunp funct-or ((exp1 list) (exp2 list) &rest (exp* list)) list            "usual or"  (or exp1 exp2 (dolist (one-exp exp*) (when one-exp (return one-exp)))))(pw::defunp funct-not ((exp1 list)) list            "usual not"  (not exp1));;;The object which is the only argument of a user defined constraint function.(defclass C-user-object ()  ((item1 :initform () :accessor item1)   (item2 :initform () :accessor item2)   (other :initform nil :accessor other)   (i1 :initform 0 :accessor i1)   (i2 :initform 1 :accessor i2)   (h-table :initform () :accessor h-table)))(defvar *the-user-general-object* ())(setf *the-user-general-object* (make-instance 'C-user-object))(pw::defunp form-pattern ((pattern list (:value '(not (* 4 7 *))))) nil"returns a one argument function which matches its input to the given pattern. Pattern is either a list representing a regular expression or a boolean formula having patternsas arguments. Regular expressions are lists which may contain the special symbols '*' or '?'. Symbol '?' matches any element (only one), whereas symbol '*' matches any sequence of zero or more elements. For example,pattern (* 4 7 * 9 ? 11 *) matches (1 3 2 4 7 9 4 11) or (4 7 5 3 9 10 11 17) but does NOT match (1 3 2 4 7 9 11) or (4 2 7 5 3 9 4 11). The pattern expressions can be within booleanformulae. For example,(and (not (* 4 7 *)) (or (* 4 ? 11 *) (* 7 ? 11 *)))"(set-domain-constraint-fun pattern))(pw::defunp constraint ((patch list (:value '() :type-list nil))                        (i1 fix>=0) (i2 fix>=0)                        &optional (vars menu                            (:menu-box-list (("seq" . 1) ("fix". 2) ("all". 3))                             :type-list (no-connection)))) nil"constructs a constraint object given a predicate (the function returned by patch) and two variable indexes <i1> and <i2>. The constraint is tested (by evaluating <patch>)for elements of the sequence corresponding to these indexes. The optional <vars> argument specifies whether the indexes are movedalong the sequence ('seq'), are only those given ('fix') or are ignored becauseall pairs in the sequence are tested with the constraint ('all'). "  (make-user-constraint      :rule-name  (format () "C~A" (gensym))   :choose-pred (case vars                   (2 #'(lambda (tx sx) (and (= sx (min i1 i2)) (= tx (max i1 i2)))))                  (3 #'(lambda (tx sx)  (declare (ignore sx tx)) t))                  (otherwise #'(lambda (tx sx) (= (- tx sx) (- (max i1 i2) (min i1 i2)))))                  )   :test-level 10   :advance (if (= vars 3) most-positive-fixnum (abs (- i2 i1)))   :predicate #'(lambda (tx sx &rest instances)                  (setf (item2 *the-user-general-object*) (first  instances))                  (setf (item1 *the-user-general-object*) (second instances))                  (setf (other *the-user-general-object*) instances)  ;;(nthcdr 2 instances)                  (setf (i1 *the-user-general-object*) sx)                  (setf (i2 *the-user-general-object*) tx)                  (setf (h-table *the-user-general-object*) soft-constr::*solution-hash-table*)                  (funcall patch *the-user-general-object*))))(defun standard-user-succeed (d &optional n alpha user-alpha)  (push (if alpha (list alpha (nicely-put d (or n *num-vars*)))            (nicely-put d (or n *num-vars*))) *all-solutions*)  (format t "~%une!!! value=~S maximized-val=~S~%" alpha (float user-alpha))  (>  (length  *all-solutions*) (1- *max-num-solns*)))(defun make-user-leaf (domain)  (if (or (lazy? domain) (and (consp domain) (or (lazy? (first domain)) (lazy? (second domain)))))    (make-ab1-leaf domain)    (make-ab2-leaf domain)))(defun compute-max-advance (constraints)  (apply 'max (pw::ask-all constraints 'advance)))(pw::defunp solve ((n-sols fix>0) (length fix>0) (domain list (:value '((1 2 3))))                   (constraints list (:value '() :type-list ()))) list"explores <domain> trying to obtain <n-sols> sequences of length <length> satisfying <constraints>. <domain> should be a list whose elements are the set of possibilities of instanciation for each position in the sequence.This set can be a list or a series (delayed list). <constraints> is a constraintobject (as output by the constraint box) or a list of constraints objects"(let ((default (car (last domain)))      (*domains* (make-array (list (1+ length)))))  (dotimes (index length)    (setf (aref *domains* (1+ index)) (make-user-leaf (or (nth index domain) default))))  (setf *all-solutions* nil        *problem-constraints* (pw::list! constraints)        *max-num-solns* n-sols)  (print "exploring...")  (time (soft-constr::soft-forward-check *problem-constraints* *domains* length           :succeed-fun #'standard-user-succeed           :advance (compute-max-advance *problem-constraints*)           :min-beta 0            :max-time *maximum-search-time*           :user-alpha 1))  *all-solutions*))  (defvar *situation-menu* (pw::new-menu "Situation"))(defvar *harmony-menu* (pw::new-menu "Harmony"))(defvar *rhythm-menu* (pw::new-menu "Rhythm"))(defvar *utilities-menu* (pw::new-menu "Utilities"))(defvar *dyn-menu* (pw::new-menu "Constraints"))(unless (member *situation-menu* (menu-items pw::*pw-menu-patch*))  (add-menu-items *situation-menu* *harmony-menu* *rhythm-menu* *dyn-menu*                  *utilities-menu*)  (pw::pw-addmenu *harmony-menu* '(harmonic-constraints set-param construct-sols part-sols))   (pw::pw-addmenu *dyn-menu* '(constraint solve))  (pw::pw-addmenu *utilities-menu* '(form-pattern ;;statistics                                      interval-interp                                     ;;rand-expl                                     ;;stability set-structure                                     funct-and funct-or funct-not))  (add-menu-items pw::*pw-menu-patch* *situation-menu*))#|(defmethod debug-tree ((collection vector))  (dotimes (i (1- *num-vars*))    (when (and (> i 0) (zerop (mod i 2)))      (format t "path: ~S ~%"               (mapcar #'(lambda (node) (list (tree-data (father (father node)))                                             (tree-data (father node))                                             (tree-data node)))                      (get-nodes-at-depth (vref collection i) 4                                          #'(lambda (x) (not (not-in-domain? x)))))))))(defmethod debug-tree ((collection cons))  (dotimes (i (1- *num-vars*))    (unless (zerop (mod i 2))      (format t "path: ~S ~%"               (mapcar #'(lambda (node) (list (tree-data (father (father node)))                                             (tree-data (father node))                                             (tree-data node)))                      (get-nodes-at-depth (nth i collection) 4                                          #'(lambda (x) (not (not-in-domain? x)))))))))(debug-tree *domains*)(debug-tree (reverse *partial-results*))|#