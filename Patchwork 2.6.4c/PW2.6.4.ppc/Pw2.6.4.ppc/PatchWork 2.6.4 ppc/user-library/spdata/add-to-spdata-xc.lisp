;;;;======================================================================================;;;;[lp] 1/9/94               add-to-pw-spdata-seq.lisp;;;;;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(mask-read mask-write freqs-comp amps-comp))(import '(pw:defunp pw::make-num-lambda pw::mat-trans));; read-mask-data(defunp mask-read ((filename list ( :value  '() :type-list '(string)))                   (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                   &optional (beg float (:value '())) (end float (:value '()))                   (nmax float (:value '()))) spdata        "reads mask analysis data and returns a spdata object (c-spdata-seq class)"  (let ((spdata-seq (make-instance 'C-spdata-seq )))    (unless filename       (setf filename (CCL:choose-file-dialog :directory  *lastspfile*                                             :button-string "mask file")))    (when  filename       (setf *lastspfile* filename)      (ecase format        (ascii (read-mask-data spdata-seq filename beg end nmax))        (bin (warn "mask-read: sorry, reading mask analysis data in binary format is not yet implemented")))      )    )  );*******************************************************(defmethod read-mask-data ((self C-spdata-seq) filename beg end &optional nmax)  (cond ((and beg end) (assert (> end beg) () "mask-read: beg must be > end"))        (beg (assert (>=  beg 0) () "mask-read: beg must be >= 0"))        (end (assert (>  end 0) () "mask-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (curline readframe cursize curmask-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil)))                (setf cursize (round (if nmax (min nmax cursize) cursize)))  ;si limitation du nombre de pics (sera peut-être modifié par les developpeurs)                (setf readframe (read in))        ;;;;;(format t "readfdrame : ~a~%" readframe)        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) ())                                        ((<= readframe end )  t)                                        (t  ())))               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0.0))          (setf curmask-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (dotimes (i cursize)          (cond (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 ;;; (setf (partials curmask-frame) (cons (read in) (partials curmask-frame)))                 (setf (freqs curmask-frame) (cons (read in) (freqs curmask-frame)))                 (setf (amps curmask-frame) (cons (read in) (amps curmask-frame)))                 (setf (weights curmask-frame) (cons (read in) (weights curmask-frame))))                (t (setf curline (read-line in))) ;; dump because out of interval beg-end                )          )        (when (and calculeflag (> cursize 0))          curline  ;for no more warnings          (setf (frame curmask-frame) readframe)          (setf (size curmask-frame) cursize)          (setf (partials curmask-frame) (arith0 1 1 cursize))          (setf (freqs curmask-frame) (reverse (freqs curmask-frame)))          (setf (amps curmask-frame) (reverse (amps curmask-frame)))          (setf (weights curmask-frame) (reverse (weights curmask-frame)))          (setf (bws curmask-frame) (make-list (length (amps curmask-frame)) :initial-element 1))  ; lp 20/8/94          ;(setf normalized-amps (normalize-amp amps))          ;(setf (phases curmask-frame) (reverse (phases curmask-frame)))          (setf (spdata self) (cons curmask-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self)))            (when beg ;; if begin time was specified, adjust all time frame values        (when (= beg (frame (first (spdata self))))           (setf beg (- beg (- (first (spdata self)) (second (spdata self))))))        (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )            (setf (file self) (mac-namestring filename))      (setf (type self) 'mask)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))      ))  self)(defun arith0 (dep pas n)  (let ((L ()))    (dotimes (i n (reverse L))      (push (+ (* pas i) dep) L))));(arith0 -1 2 10);**********************************************;redefini read-addsyn pour même nbre de partiels partout;; change xc 28.9.94 output type sepdata-seq;; change xc 29/9/94 stop reading after if end input is specified(defunp addsyn-read2 ((filename list ( :value  '() :type-list '(string)))                      (npart float (:value 25))                       (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                      &optional (beg float (:value '())) (end float (:value '()))) spdata-seq        "reads additive synthesis data and returns a spdata object (c-spdata-seq class)"  (let ((spdata-seq (make-instance 'C-spdata-seq )))    (unless filename       (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata-seq)                                             :button-string "addsyn file")))    (when  filename       ;(format t "last file is ~D~%" (last-loaded-file spdata-seq))      (setf (last-loaded-file spdata-seq) filename)      ;;(setf *lastspfile* filename)      (ecase format        (ascii (read-addsyn-data2 spdata-seq filename npart beg end))        (bin (warn "addsyn-read: sorry, reading additive synthesis data in binary format is not yet implemented")))      )    )  )(defmethod read-addsyn-data2 ((self C-spdata-seq) filename npart beg end)  (cond ((and beg end) (assert (> end beg) () "addsyn-read: beg must be > end"))        (beg (assert (>=  beg 0) () "addsyn-read: beg must be >= 0"))        (end (assert (>  end 0) () "addsyn-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (readframe cursize curaddsyn-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil))) ;; loop on frames        (setf readframe (read in))        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) (setf continueflag t) ())                                        ((<= readframe end ) (setf continueflag t) t)                                        (t  (setf continueflag ()) ()))) ; after end, stop reading               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0))          (setf curaddsyn-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (let (pos (n 1) (last-f 10)(nlast cursize))     ;valeurs arbitraires par défaut si 1er part absent          (cond (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 (dotimes (i npart)                   (setf (partials curaddsyn-frame) (cons (1+ i) (partials curaddsyn-frame)))                    (if (or pos (zerop nlast))()(setf pos (read in nil)))    ; lecture n° partiel                   (if (and (eq pos (1+ i))(not (zerop nlast)))             ; si n°part = n°part ou nlast=0                     (progn (setf pos nil)                            (setf last-f (read in))                         ; dernière fréquence lue                            (setf nlast (1- nlast))                            (setf n (1+ i))                                 ; repère l'indice de la dernière fréquence trouvée                            (setf (freqs curaddsyn-frame)(cons last-f (freqs curaddsyn-frame)))                            (setf (amps curaddsyn-frame) (cons (read in) (amps curaddsyn-frame)))                            (setf (phases curaddsyn-frame) (cons (read in) (phases curaddsyn-frame)))                            )                     (progn (setf (freqs curaddsyn-frame)(cons (* (/ (1+ i) n) last-f) (freqs curaddsyn-frame)))                            (setf (amps curaddsyn-frame) (cons 0 (amps curaddsyn-frame)))                            (setf (phases curaddsyn-frame) (cons 0 (phases curaddsyn-frame)))                            ))))                 (t                   (dotimes (i cursize)                    (read-line in))) ;; dump because out of interval beg-end                  ))        (when (and calculeflag (> cursize 0))          (setf (frame curaddsyn-frame) readframe)          (setf (size curaddsyn-frame) cursize)          (setf (partials curaddsyn-frame) (reverse (partials curaddsyn-frame)))            (setf (freqs curaddsyn-frame) (reverse (freqs curaddsyn-frame)))          (setf (amps curaddsyn-frame) (reverse (amps curaddsyn-frame)))          (setf (bws curaddsyn-frame) (make-list (length (amps curaddsyn-frame)) :initial-element 1))  ; lp 20/8/94          ; (setf normalized-amps (normalize-amp amps))          (setf (phases curaddsyn-frame) (reverse (phases curaddsyn-frame)))          (setf (spdata self) (cons curaddsyn-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self)))      (when beg ;; if begin time was specified, adjust all time frame values   ;;;;;;;;;(when (= beg (frame (first (spdata self)))) ;;;;;;;;;;; Was ist das denn ????????   ;;;;;;;;;(setf beg (- beg (- (print (first (spdata self))) (second (spdata self))))))        (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )       (setf (file self) (mac-namestring filename))      (setf (type self) 'addsyn)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D ~%from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))      ))  self);********************************************(defun freqs-comp (par-sp-f frames)"ajoute les valeurs de freq qui manquent dans les analysespour réaliser une synthèse par csoundune freq qui disparait reste a la meme valeurune freq qui disparait et réapparait avec une autre valeur est interpolée"(let ((Lfram (first par-sp-f))      (Lfreq (second par-sp-f))      (L ()) prev next)  (dotimes (n (length frames)(reverse L))    (setf prev (nth (max 0 (1- n)) frames)          next (nth (min (1- (length frames))(1+ n)) frames))    (cond ((find (nth n frames) Lfram)           (push (pop Lfreq) L))          ((not (find next Lfram))           (push (car L) L))          ((not (find prev Lfram))           (push (car Lfreq) L))          (t           (push (intpol prev (nth n frames) next                          (car L)(car Lfreq)) L))))));(freqs-comp '((0 2 3 7)(10 20 30 40)) '(0 1 2 3 4 5 6 7))(defun intpol (x1 x2 x3 y1 y3)(if (zerop (- x3 x1)) y1  (+ y1 (/ (* (- x2 x1)(- y3 y1))(- x3 x1)))));(intpol 0 2 8 0 4);****************************************************(defun amps-comp (par-sp-a frames)  " en cours, veuillez patienter"  (let ((Lfram (first par-sp-a))        (Lamp (second par-sp-a))        (L ()))    (dotimes (n (length frames)(reverse L))      (if (find (nth n frames) Lfram)        (push (pop Lamp) L)        (push 0 L)))));(amps-comp '((0 2 3 7)(10 20 30 40)) '(0 1 2 3 4 5 6 7))(pw-addmenu  *spd-io*  '(addsyn-read2 mask-read ));(pw-addmenu   *spd-create* '( mk-spdata  mk-spdata-seq))(pw-addmenu   *spd-processing*  '(freqs-comp amps-comp));;;------------------------------------------------------;; mettre dqns pw-spdata-seq(defunp addsyn-read ((filename list ( :value  '() :type-list '(string)))                      (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                     &optional (beg float (:value '())) (end float (:value '()))) spdata"reads additive synthesis data and returns a spdata object (c-spdata-seq class)" (let ((spdata-seq (make-instance 'C-spdata-seq )))   (unless filename      (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata-seq)                                           :button-string "addsyn file")))   (when  filename ;(format t "last file is ~D~%" (last-loaded-file spdata-seq))(setf (last-loaded-file spdata-seq) filename);;(setf *lastspfile* filename)     (ecase format       (ascii (read-addsyn-data spdata-seq filename beg end))       (bin (read-addsyn-bindata spdata-seq filename beg end))))));; mettre dans spdata-seq-class.lisp(defmethod read-addsyn-bindata ((self C-spdata-seq) filename beg end)  (cond ((and beg end) (assert (> end beg) () "addsyn-read: beg must be > end"))        (beg (assert (>=  beg 0) () "addsyn-read: beg must be >= 0"))        (end (assert (>  end 0) () "addsyn-read: end must be > 0"))        )  (with-open-file (in filename :direction :input :element-type '(unsigned-byte 32))(format t "je lis ~D~%" filename)(dotimes (i 10)    (format t "~D: " i)    (ff (coerce (read-byte in nil nil) 'short-float))    )))(defun ff(x)  (multiple-value-bind (ss ee si)                        (decode-float x)    (format t "~D, ~D ~D~%" ss ee si)    ));; (ff  0.2)