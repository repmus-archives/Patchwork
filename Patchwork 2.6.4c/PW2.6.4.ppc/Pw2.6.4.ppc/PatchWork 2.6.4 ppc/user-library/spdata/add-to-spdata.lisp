;;;;======================================================================================;;;;[lp] 1/9/94               add-to-pw-spdata-seq.lisp;;;;;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(freqs-comp amps-comp conc-dats calc-phases times-csnd));********************************************(defun freqs-comp (par-sp-f frames)"ajoute les valeurs de freq qui manquent dans les analysespour réaliser une synthèse par csoundune freq qui disparait reste a la meme valeurune freq qui disparait et réapparait avec une autre valeur est interpolée"(let ((Lfram (first par-sp-f))      (Lfreq (second par-sp-f))      (L ()) prev next)  (dotimes (n (length frames)(reverse L))    (setf prev (nth (max 0 (1- n)) frames)          next (nth (min (1- (length frames))(1+ n)) frames))    (cond ((find (nth n frames) Lfram)           (push (pop Lfreq) L))          ((not (find next Lfram))           (push (car L) L))          ((not (find prev Lfram))           (push (car Lfreq) L))          (t           (push (intpol prev (nth n frames) next                          (car L)(car Lfreq)) L))))));(freqs-comp '((0 2 3 7)(10 20 30 40)) '(0 1 2 3 4 5 6 7))(defun intpol (x1 x2 x3 y1 y3)(if (zerop (- x3 x1)) y1  (+ y1 (/ (* (- x2 x1)(- y3 y1))(- x3 x1)))));(intpol 0 2 8 0 4);****************************************************(defun amps-comp (par-sp-a frames)  " en cours, veuillez patienter"  (let ((Lfram (first par-sp-a))        (Lamp (second par-sp-a))        (L ()))    (dotimes (n (length frames)(reverse L))      (if (find (nth n frames) Lfram)        (push (pop Lamp) L)        (push 0 L)))));(amps-comp '((0 2 3 7)(10 20 30 40)) '(0 1 2 3 4 5 6 7));**********************************************************;pour obtenir le spdata d'une séquence en fct de la frame (version simple)(defun t->spd (frame spseq)  "pour obtenir le spdata d'une séquence en fct de la frame"  (let ((spds (get-slot spseq 'spdata)) (n 0)(stop t))    (if (get-slot (nth n spds) 'frame)      (while (and stop (< (get-slot (nth n spds) 'frame) frame))        (if (get-slot (nth (1+ n) spds) 'frame) (incf n)(setf stop nil))        ))    (nth n spds)));********************************************************(defun conc-dats (l1 l2 i1 i2 dur)  "pour donner les frames d'une séquence interpolées entre deux séquencesavec décalages (seq1 interpolée à partir du temps i1, seq2 i2"  (let (elt (l ()) (stop t))    (while (and stop (<= (setf elt (pop l1)) (+ i1 dur)))      (progn (push elt l)             (if (car l1) ()                  (format t  "~%caï-caï !! value of i1+dur > tmax of l2 ~a" (setf stop nil))                 )             ))    (print (setf stop t))    (if (car l2) ()         (format t  "~%caï-caï !! value of i2+dur > tmax of l2 ~a" (setf stop nil)))    (while (and stop (<= (car l2)(+ i2 dur)))                (progn (pop l2)                       (if (car l2) ()                            (format t  "~%caï-caï !! value of i2+dur > tmax of l2 ~a" (setf stop nil)))))      (append (reverse l)(mapcar '+ l2 (pw::cirlist (- i1 i2))))));(conc-dats '(0 1 2 3 4 5 6 7 8) '(0 1 2) 10 0 15)(let (stop)(if stop 0 1));********************************************************(defun calc-phas (f0 f1 dur ph0)  "ph = ph0 + f0.t + 1/2.g.t^2 avec g = (f-f0)/tsoit ph = ph0 + 1/2.t.(f+f0)calcul de la phase à un instant donné connaissant f0, ph0, t"  (multiple-value-bind (x y)                       (floor (+ ph0 (* 1/2 dur (+ f1 f0))))    x y));(calc-phas 100 102 .2 0)(defun calc-phases (Lf Ldur ph0)  (let ((Lph (list ph0))(length (length Ldur)))    (do ((n 0 (1+ n)))        ((= n length)(reverse Lph))      (push (calc-phas (nth n Lf)(nth (1+ n) Lf)(nth n Ldur)(first Lph)) Lph))));(calc-phases '(100 100 102 100 100) '(.2 .2 .2 .2) 0);********************************************************(defun times-csnd (dates-i)"donne, à partir des dates des analyses, trois listes:les dates pour une resynthèse en partant de zéros et en décalant de 0.02 secpour l'attaque de la première note, les durées des notes (de l'analyse précédente à la suivanteles durées d'attaques des notes"  (let ((dates ())(durs ())(attacs ())(ref (- (second dates-i)(first dates-i))))    (dotimes (n (length dates-i)(list (reverse dates)(reverse durs)(reverse attacs)))      (cond ((zerop n)             (progn               (push 0 dates)               (push (* 2 ref) durs)               (push ref attacs)))            ((= n (1- (length dates-i)))             (progn                (push (- (nth n dates-i)(first dates-i)) dates)               (push (* 2 (- (nth n dates-i)(nth (1- n) dates-i))) durs)               (push (- (nth n dates-i)(nth (1- n) dates-i)) attacs)))            (t             (progn                (push (- (nth n dates-i)(first dates-i)) dates)               (push (- (nth (1+ n) dates-i)(nth (1- n) dates-i)) durs)               (push (- (nth n dates-i)(nth (1- n) dates-i)) attacs)))))))     ;;;;;;;;;(times-csnd '(.2 .4 .65 .8));*************************************************************;;;;;(pw-addmenu   *analyse-menu*  '(freqs-comp amps-comp));*************************************************************;*************************************************************#|intégré dans le code "fcts centrage"(defunp L-moy-modif         ((spdata object (:type-list (list spdata spdata-seq)))         (Lf-typ menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))                                      :type-list (no-connection)))         (m integer)(sigma integer)) list        "calcule la fréquence moyenne et l'écarttype d'une série de formantspuis transforme la liste des amplitudes et des bws en fct des nouvellesvaleurs de moy et ecartype"           (if (equal Lf-typ "midic")    (m-moy-modif (freqs spdata) (amps spdata) (bws spdata) m sigma)    (f-moy-modif (freqs spdata) (amps spdata) (bws spdata)  m sigma )))(defunp L-moy        ((spdata object (:type-list (list spdata spdata-seq)))         (Lf-typ menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))                                      :type-list (no-connection)))         ) list        "calcule la fréquence moyenne d'une série de formants"   (let ((vbws (bws spdata)))    (if (= (length (amps spdata))(length (bws spdata))) ()         (setf vbws (make-list (length (freqs spdata)):initial-element 1)))    (if (equal "midic" Lf-typ)      (midic-moy (list (freqs spdata) (amps spdata) vbws))      (freq-moy (list (freqs spdata) (amps spdata) vbws)))))(defunp L-ecart        ((spdata object (:type-list (list spdata spdata-seq)))         (Lf-typ menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))                                      :type-list (no-connection)))) list        "calcule la fréquence moyenne d'une série de formants"           (let ((vbws (bws spdata)))    (if (= (length (amps spdata))(length (bws spdata))) ()         (setf vbws (make-list (length (freqs spdata)):initial-element 1)))    (if (equal "midic" Lf-typ)      (midic-ecartyp (list (freqs spdata) (amps spdata) vbws))      (freq-ecartyp (list (freqs spdata) (amps spdata) vbws)))));=====================================;MODIFS MOY-MODIFS GAUSS CENTRÉE NORMÉE(defun modif-midic (midic  mmid1 mmid2 sigma-midi1 sigma-midi2)"this is the old version"     (exp(- (/ (expt (- midic mmid1) 2) (if (= 0 sigma-midi1) 1                                            (* 2 (expt sigma-midi1 2))))           (/ (expt (- midic mmid2) 2) (if (= 0 sigma-midi2) 1                                            (* 2 (expt sigma-midi2 2)))))))(defun modif-midic-new (midic  mmid1 mmid2 sigma-midi1 sigma-midi2)"this is a new version"(* midic (/ (gauss midic mmid2 sigma-midi2)(gauss midic mmid1 sigma-midi1))))(defun moy (freqs amps)  (float (/ (apply '+ (mapcar '* freqs amps))(apply '+ amps))));(moy '(1 2 3 4)'(1 1 1 1))(defun ecart (freqs amps)  (let ((moy (moy freqs amps)))     (float (/ (expt     (apply '+            (mapcar #'(lambda (x y) (* (expt (- x moy) 2) y)) freqs amps)            )     1/2) (apply '+ amps)))));(ecart '(10 20)'(1 10))(defun gauss (x moy ecart)  (let ((v (expt (* 2 pi) 1/2)))    (if (zerop ecart) nil        (* (/ 1 (* ecart v))(expt 2.7 (- (/ (expt (- x moy) 2)(* 2 (expt ecart 2)))))))));(gauss 100 100 100)|#;===============================================#|(defunp mask-read ((filename list ( :value  '() :type-list '(string)))                   (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                   &optional (beg float (:value '())) (end float (:value '()))                   (nfix float (:value '()))(nmax float (:value '()))) spdata        "reads mask analysis data and returns a spdata object (c-spdata-seq class)"  (let ((spdata-seq (make-instance 'C-spdata-seq )))    (unless filename       (setf filename (CCL:choose-file-dialog :directory  *lastspfile*                                             :button-string "mask file")))    (when  filename       (setf *lastspfile* filename)      (ecase format        (ascii (read-mask-data-new spdata-seq filename beg end nfix nmax))        (bin (warn "mask-read: sorry, reading mask analysis data in binary format is not yet implemented")))      )    )  )(defmethod read-mask-data-new ((self C-spdata-seq) filename beg end &optional nfix nmax) ;nfix & nmax lp 26/4/96  (cond ((and beg end) (assert (> end beg) () "mask-read: beg must be > end"))        (beg (assert (>=  beg 0) () "mask-read: beg must be >= 0"))        (end (assert (>  end 0) () "mask-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (curline readframe cursize curmask-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil)))                (setf cursize (round (if nfix (min nfix cursize) cursize)))  ;si limitation du nombre de pics (sera peut-être modifié par les developpeurs)                (setf readframe (read in))        ;;;;;(format t "readfdrame : ~a~%" readframe)        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) (setf continueflag t) ())                                        ((<= readframe end ) (setf continueflag t) t)                                        (t  (setf continueflag ()) ())))               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0))          (setf curmask-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (dotimes (i cursize)          (cond ((> i nmax)(repeat 3 (read in)))                (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 (setf (freqs curmask-frame) (cons (read in) (freqs curmask-frame)))                 (setf (amps curmask-frame) (cons (read in) (amps curmask-frame)))                 (setf (weights curmask-frame) (cons (read in) (weights curmask-frame))))                (t (setf curline (read-line in))) ;; dump because out of interval beg-end                )          )        (when (and calculeflag (> cursize 0))          curline  ;for no more warnings          (setf (frame curmask-frame) readframe)          (setf (size curmask-frame) cursize)          (setf (partials curmask-frame) (arith0 1 1 cursize))          (setf (freqs curmask-frame) (reverse (freqs curmask-frame)))          (setf (amps curmask-frame) (reverse (amps curmask-frame)))          (setf (weights curmask-frame) (reverse (weights curmask-frame)))          (setf (bws curmask-frame) (make-list (length (amps curmask-frame)) :initial-element 1))  ; lp 20/8/94          ;(setf normalized-amps (normalize-amp amps))          (setf (phases curmask-frame) (make-list (length (amps curmask-frame)) :initial-element 0))           (setf (spdata self) (cons curmask-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self)))            (when beg ;; if begin time was specified, adjust all time frame values       (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )            (setf (file self) (mac-namestring filename))      (setf (type self) 'mask)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))      ))  self);--|#