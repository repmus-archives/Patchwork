(in-package :spdata);; interpol must be loaded before this file(defvar *lfilename* "root:users")(defvar *rfilename* ());mieux à employer avec mk-modres ou ll-mod ou a-mod:(defunp intpol-models ((spd1 object (:type-list (spdata)))                       (spd2 object (:type-list (spdata)))                       (seuil fix/float (:value 100 :type-list (chant-vector-buff fixnum float)))                       (scaler fix/float (:value 0 :type-list (chant-buff fixnum float)))                       (flag integer (:value 1  :min-val 0 :max-val 7))                       &optional                        (th-type menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))                                                     :type-list (no-connection)))                        (mod-type menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))))                       ) spdata          "donne un nouveau modèle interpolé à partir de deux modèles de départ, les frames sont calculées sur le modèle gauche (1)"  (let* (Lfg Lfd Lag Lad Lbwg Lbwd  resmoy1/2             objetf objeta objetbw)    (setf Lfg  (freqs  spd1))    (setf Lag  (amps spd1 ))    (if (zerop (apply '+ Lag))(setf Lag (arith0 0.00001 0 (length Lfg)))) ;;new lp 28/9/94    (setf Lbwg  (bws spd1))    (setf Lfd  (freqs  spd2))    (setf Lad  (amps spd2 ))    (if (zerop (apply '+ Lad))(setf Lad (arith0 0.00001 0 (length Lfd)))) ;;new lp 28/9/94   (setf Lbwd  (bws spd2))    (setf objetf (make-ldouble Lfg Lfd))    (setf objeta (make-ldouble Lag Lad))    (setf objetbw (make-ldouble Lbwg Lbwd))    (progn      (setf resmoy1/2 (/ (res-moy (lg objeta) (lg objetbw))                         (if (zerop (res-moy (ld objeta) (ld objetbw))) 1                             (res-moy (ld objeta) (ld objetbw))))) ;; a ameliorer si amps = 0      (appariement2 objetf seuil (list th-type mod-type) ) ;; --> old 31/11/93 lp      ;(appariement3 objetf seuil (list th-type mod-type) flag) -> modif bof      (compar-apari  objetf objeta)      (compar-apari objetf objetbw)      ;(list (intpolfreqs objetf scaler flag)  --> old 19/8/93 lp      ;            (intpolamps objeta scaler flag)      ;            (intpolbws objetbw scaler flag resmoy1/2))      (when (and objetf objeta objetbw)        (let ((modele (make-instance   'C-spdata ))(liste-ref (intpolfreqs objetf scaler flag)))          (setup modele liste-ref (intpolamps  objeta scaler flag)                 (intpolbws objetbw scaler flag resmoy1/2)                 (make-list  (length liste-ref) :initial-element 0)                 (arith0 1 1 (length liste-ref)) (make-list  (length liste-ref) :initial-element 0)                 'empty ())           (setf (frame modele) (frame  spd1))                  modele)        ))));(arith0 -1 0 10) ;in add-to-spdata;(zerop (apply '+ '(0 0 0 0.001)));------------------;; appariement multiple;;(defclass C-appari (C-patch-reson-lib);;((nbre-reson :initform 0 :initarg :nbre-reson :accessor nbre-reson)))(defunp apari-mult        ((spd1 object (:type-list (spdata)))         (spd2 object (:type-list (spdata)))         (seuil fix/float (:type-list (chant-buff fixnum float) :value 100))         &optional (th-type menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))                                                :type-list (no-connection)))          (mod-type menu (:menu-box-list (("midic" . "midic") ("Hz" . "Hz"))))                                        )                   spdata "interpolation multiple. les arguments sont des objets modres créés par ll-mod ou a-mod ou mk-modres.La sortie est un objet modres"                   (when (and spd1 spd2)                     (let* ((objf (make-lmultiple                   (mapcar #'flat2 (freqs spd1))                   (mapcar #'flat2 (freqs spd2))))           (obja (make-lmultiple                   (mapcar #'flat2 (amps spd1))                   (mapcar #'flat2 (amps spd2))))           (objbw (make-lmultiple                    (mapcar #'flat2 (bws spd1))                    (mapcar #'flat2 (bws spd2)))))      (progn (appariement2 objf seuil (list th-type mod-type))           ; (appariement3 objf seuil (list th-type mod-type) flag) ;lp modif ? bof, 31/11/93             (compar-apari objf obja)             (compar-apari objf objbw)             (make-instance   'C-spdata                  :freqs (LdeP objf)               :amps (LdeP obja)               :bws (LdeP objbw)               )))))(defunp int-mult        ((spdata object (:type-list (spdata)))         (scalers list (:value '(1 0)))         (flag integer (:value 1  :min-val 0 :max-val 7)))        spdata         "interpolation multiple. les arguments sont des objets spdata créés par ll-mod ou a-mod ou mk-spdata.La sortie est un objet modres"  (let* ((objf (xmake-LdeP (freqs spdata)))         (obja (xmake-LdeP (amps spdata)))         (objbw (xmake-LdeP (bws spdata)))         (resmoy (calc-resmoys obja objbw)))    (when (and objf obja objbw)    ;;  (let ((modele (make-instance   'C-spdata )))    ;;    (setup modele (intpolfreqs objf scalers flag) (intpolamps  obja scalers flag)    ;;   (intpolbws objbw scalers flag resmoy) () () () 'empty ())    ;;    modele)(let ((modele (make-instance   'C-spdata ))(liste-ref (intpolfreqs objf scalers flag)))          (setup modele liste-ref (intpolamps  obja scalers flag)                 (intpolbws objbw scalers flag resmoy)                 (make-list  (length liste-ref) :initial-element 0)                 (arith0 1 1 (length liste-ref)) (make-list  (length liste-ref) :initial-element 0)                 'empty ())                    modele)      )));*************************************************************************;*************************************************************************(defunp intpolr-models ((spd1 object (:type-list (spdata)))                        (spd2 object (:type-list (spdata)))                        (scaler fix/float (:value 0))                        )        spdata          "donne un nouveau modèle interpolé à partir de deux modèles de départ, les frames sont calculées sur le modèle gauche (1)"  (let ((Lfg (freqs  spd1))        (Lag  (amps spd1 ))        (Lfd  (freqs  spd2))        (Lad  (amps spd2 ))        (Lf ())        (La ()) nmax objet-out)    (setf nmax (max (length Lfg)(length Lfd)))    (dotimes (n nmax)      (progn         (push (intpolr (nth n Lfg)(nth n Lfd) scaler) Lf)        (push (intpolr (nth n Lag)(nth n Lad) scaler) La)))     (setf objet-out (make-instance   'C-spdata ))    (setup objet-out (reverse Lf)(reverse La)           (make-list  (length Lf) :initial-element 1)           (make-list  (length Lf) :initial-element 0)           (arith0 1 1 (length Lf)) (make-list  (length Lf) :initial-element 0)           'empty ())     (setf (frame objet-out) (frame  spd1))            objet-out)  )(defun intpolr (n1 n2 scal)  (cond ((and n1 n2)         (+ (* n2 scal)(* n1 (- 1 scal))))        (n1 n1)        (n2 n2)        (t (error "no values to intpol"))));(intpolr 400 800 1);****************************************************************(defunp intpolw-models ((spd1 object (:type-list (spdata)))                        (spd2 object (:type-list (spdata)))                        (freq (menu (:menu-box-list (("fintpol" . 0)                                                     ( "fleft" . 1)                                                      ("fright" . 2)))))                        (amp (menu (:menu-box-list (("aintpol" . 0)                                                    ( "aleft" . 1)                                                     ("aright" . 2)))))                        (scaler fix/float (:value 0))                        )        spdata          "donne un nouveau modèle interpolé à partir de deux modèles de départ, les frames sont calculées sur le modèle gauche (1)"  (let ((Lfg (freqs  spd1))        (Lag  (amps spd1 ))        (Lphg  (phases spd1 ))        (Lfd  (freqs  spd2))        (Lad  (amps spd2 ))        (Lphd  (phases spd2 ))        (Lf ())(La ())(Lph ()) nmax objet-out)    (setf nmax (max (length Lfg)(length Lfd)))    (dotimes (n nmax)      (progn         (push (intpolw (nth n Lfg)(nth n Lfd) scaler freq) Lf)        (push (intpolwa (nth n Lag)(nth n Lad) scaler amp) La)        (push (intpolw (nth n Lphg)(nth n Lphd) scaler freq) Lph)))    (setf objet-out (make-instance   'C-spdata ))    (setup  objet-out (reverse Lf)(reverse La)           (make-list  (length Lf) :initial-element 1)           (reverse Lph)           (arith0 1 1 (length Lf))            (make-list  (length Lf) :initial-element 0)           'empty ())     (setf (frame objet-out) (frame  spd1))            objet-out)  )(defun intpolw (n1 n2 scal typ)  (case typ    (0     (cond ((and n1 n2)            (+ (* n2 scal)(* n1 (- 1 scal))))           (n1 n1)           (n2 n2)           (t (error "no values to intpol"))))     (1 (if n1 n1 n2))     (2 (if n2 n2 n1))))(defun intpolwa (n1 n2 scal typ);(print scal)  (case typ    (0     (cond ((and n1 n2)          (+ (* n2 scal)(* n1 (- 1 scal))))           (n1 (* n1 (- 1 scal)))           (n2 (* n2 scal))           (t (error "no values to intpol"))))    (1 (if n1 n1 n2))     (2 (if n2 n2 n1))));(intpolw 400 800 .5 0);********************************************************************;;;;;;(pw-addmenu *spd-processing*  '(L-moy-modif))(pw-addmenu *spd-processing*  '(L-stat-modif))(pw-addmenu *spd-processing*  '(distsp))(pw-addmenu *spd-processing*  '(aplatifreqs))(add-menu-items *spd-processing* (pw::new-leafmenu "-" ()))(pw-addmenu *spd-processing*  '(pw::xtrajts-chds));;;;;(pw-addmenu *spd-processing*  '(vire-ou-stocke))(add-menu-items *spd-processing* (pw::new-leafmenu "-" ()))(pw-addmenu *spd-processing*  '(intpol-models intpolw-models))                             (add-menu-items *spd-processing* (pw::new-leafmenu "-" ()))(pw-addmenu *spd-processing*  '(sp-jitter3 sp-voice-vibra))(pw-addmenu *analyse-menu*  '(L-moy))(pw-addmenu *analyse-menu*   '(L-ecart))(add-menu-items *analyse-menu* (pw::new-leafmenu "-" ()))(pw-addmenu *analyse-menu*   '(Response))(pw-addmenu *analyse-menu*   '(MatrixResponse));(pw-addmenu *analyse-menu*  '(apari-mult int-mult))(export '(L-moy L-ecart L-moy-modif L-stat-modif))(export '(intpol-models intpolr-models intpolw-models apari-mult int-mult sp-jitter3 sp-voice-vibra))