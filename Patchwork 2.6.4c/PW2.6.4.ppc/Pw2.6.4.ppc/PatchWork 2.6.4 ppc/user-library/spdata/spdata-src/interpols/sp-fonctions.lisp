(in-package :spdata);(defun f->mc2 (f);  (if (zerop f) 0 (* 1200 (log f 2))))(defun f->mc2 (LorA)  (cond ((null LorA)          ())        ((atom LorA)         (if (numberp LorA) (round (epw::f->mf LorA)) LorA))        (t         (cons (f->mc2 (car LorA))(f->mc2 (cdr LorA))))));(f->mc2 '(((110)) f));(mc->f2 '(((8138)) 3986))(defun mc->f2 (LorA)  (cond ((null LorA)          ())        ((atom LorA)        (if (numberp LorA) (epw::mc->f1 LorA) LorA))        (t         (cons (mc->f2 (car LorA))(mc->f2 (cdr LorA)))))) (defun flat2 (lorx)  (if (atom lorx) lorx (pw::flat lorx)));(flat2 '((1)))(defun som-dt-x (l)  (if l (+ (if (equal (car l) 'x) 0 (car l))(som-dt-x (cdr l))) 0))(defun moy-dt-x (l)  (if (atom l) (if (numberp l) l 0)      (let ((l (remove 0 (remove 'x (pw::flat l)))))        (/ (som-dt-x l)(length l)))));(moy-dt-x '(((1))));pour les largeurs de bande, on utilise l'inverse de la moy-dt-x des inverses(defun moybw (lbw)  (cond  ((atom lbw) (if (numberp lbw) lbw 0))         ((endp (remove 0 (remove 'x (pw::flat lbw)))) 0)      (t (/ (moy-dt-x (mapcar #'/ (remove 0 (remove 'x (pw::flat lbw)))))))));(float (moybw '((1 x)(x x)))(defun compar-l-scal (l scal)"remplace les elts de (pw::flat l) par 0 si on a un x ou un 0et par l'élément correspondant de scal sinon"  (let ((l2 (pw::flat l))(s2 scal) l3 )    (dolist (elt l2 (reverse l3))      (if (zerop (moy-dt-x elt))(and (push 0 l3)(pop s2))          (push (pop s2) l3)))));(compar-l-scal '((0 1)(x x)) '(2 0 0 1))(defun scalbw (bw1 bw2 scaler)"donne la largeur de bande moyenne (inverse) entre bw1 et bw2 pondéré par scal"  (/ (* bw1 bw2)(+ (* (- 1 scaler) bw2)(* scaler bw1))));(scalbw 10 1 0);(time (repeat 500 (moy-dt-x '(100 0 100 100 x 100)))) ;-->31 ticks;(time (repeat 5000 (moy-dt-x 15))) ;-->4 ticks(defun find-elt-seuil (elt l2 seuil)  (if (> 0 seuil) (find-elt-seuilf elt l2 (- seuil))      (find-elt-seuilmc elt l2 seuil)));(find-elt-seuil 440 '(430 440 450 480) 20)(defun find-elt-seuilmc (elt l2 seuil)  (let ((L ())        (elt1 (f->mc2 elt)))    (dolist (elt2 l2 (reverse L))         (if (<= (abs (- elt1 (f->mc2 elt2))) seuil)         (setf L (cons (list elt elt2) L))        ()))))(defun find-elt-seuilf (elt l2 seuil)  (let ((L ()))    (dolist (elt2 l2 (reverse L))         (if (<= (abs (- elt elt2)) seuil)         (setf L (cons (list elt elt2) L))        ()))));(find-elt-seuilf 440 '(430 440 450 480) 20)(defun xfind-elt-seuil (elt l2 seuil)  (if (> 0 seuil) (xfind-elt-seuilf elt l2 (- 0 seuil))      (xfind-elt-seuilmc elt l2 seuil)))(defun xfind-elt-seuilmc (elt l2 seuil)  (let ((L ())(elt1 (f->mc2 (moy-dt-x elt))))        (dolist (elt2 l2 (reverse L))             (if (<= (abs (- elt1 (f->mc2 (moy-dt-x elt2)))) seuil)           (setf L (cons (list elt elt2) L))        ()))))(defun xfind-elt-seuilf (elt l2 seuil)  (let ((L ()) (elt1 (moy-dt-x elt)))        (dolist (elt2 l2 (reverse L))             (if (<= (abs (- elt1 (moy-dt-x elt2))) seuil)           (setf L (cons (list elt elt2) L))        ()))));(f->mc2 (moy-dt-x 440));(time (repeat 500 (find-elt-seuil 440 '(440 480 550 660 880) 1000)))-->88 /10 ticks;(time (repeat 500 (find-elt-seuil '(6700 6750) '(6600 6658 6680 6705 7000) 50)))-->108 ticks;(time (repeat 500 (find-elt-seuil '(6700 6750) '((6600 x) (6680 6705)) 30)))-->124/95 ticks;;;;;;Différence |d-g|(defun diff-de-P (Paire)  (abs (- (car Paire)(cadr Paire))))(defun xdiff-de-P (Paire)  (abs (- (moy-dt-x (car Paire))(moy-dt-x (cadr Paire)))));(time (repeat 500(diff-de-P  '((50 55) 58))))  ;-->54/35 ticks(defun cons-x-paire (elt rang)  (if (null elt)()      (if (eq rang 0)(cons elt (cons 'x ()))          (cons 'x (cons elt ())))))(defun cons-x-elt (elt rang n)(cond ((null elt )())      ((eq rang 0)       (if (eq n 1)(cons elt '(x))           (cons elt (list (make-list n :initial-element 'x)))))      (t (if (eq n 1)(cons 'x (cons elt ()))             (list (make-list n :initial-element 'x)                    elt)))));(cons-x-elt 1 0 2)  (defun make-x (elt n)  (if (eq n 1) elt      (make-list n :initial-element elt)));(make-x 5 2)(defun taille (LorA)  (if (atom LorA) 1 (length LorA)))(defun rescale (Lamps scaler)  (let ((l () ))    (dolist (elt Lamps (reverse L))      (push (* elt scaler) L))));(rescale '(0 1 2 3 4) 2) -->(0 2 4 6 8)(defun res-moy (Lamps Lbws)    (do* ((n 0 (1+ n))          (sumres (* (car Lamps)(expt (/ 1 (car Lbws)) 2))                  (+ sumres (* (nth n Lamps) (expt (/ 1 (nth n Lbws)) 2))))          (sumamp (car Lamps)(+ sumamp (nth n Lamps))))         ((eq n (1- (length Lamps)))(expt (/ sumres sumamp) 0.5))));(res-moy '(1 ) '(0.1));************;nouvelle def. , nom plus logique(defun amp-corr (amp bw)(if bw  (if (zerop bw) amp      (/ amp bw)) amp));(amp-corr 1 1.0);(amp-corr 1 1)(defunp coef-resmoy ((Lamps list)(Lbws list))        number "calcule la durée de resonance du sonen seconde"   (if (= (length Lamps)(length Lbws))    (res-moy Lamps Lbws)    (break "error length Lbws difft from length Lamps")));pour menus(defunp resmoy-coef ((spdata spdata))        number "calcule la durée de resonance du sonen seconde"  (let ((Lamps (amps spdata))(Lbws (bws spdata)))    (if (= (length Lamps)(length Lbws))      (res-moy Lamps Lbws)      (break "error length Lbws difft from length Lamps"))));******************************************************(defun extrait (liste debut nbre)  (let ((L()))    (do ((n debut (1+ n)))        ((eq n (+ nbre debut))(reverse L))      (push (nth n liste) L))))(defun lin->sin (x)  (/ (+ 1 (cos (* pi (- x 1)))) 2));(lin->sin 0.2)  ;double emploi avec atan maintenant;---------------extraction d'une colonne dans une liste de type tableau---------------------(defun liste-n-aux  (table nieme LdeL pas)  (if (endp table) (reverse LdeL)          (let ((elt (abs (pop table))))            (if (= 1 nieme) (liste-n-aux table pas (push elt LdeL) pas )                (liste-n-aux table (- nieme 1) LdeL pas )))))(defun liste-n (table nieme pas)(if (> nieme pas) ()  (let ((LdeL ()))    (liste-n-aux  table nieme LdeL pas)))); table = liste de type tableau; nieme = n° de la colonne recherchée (1ere = 1); LdeL = resultat; pas = nombre de colonnes du tableau(defun scal-Pair-dtx (Paire scaler)  (let ((A (car Paire))        (B (second Paire)))    (setf A (if (numberp A) A 0)          B (if (numberp B) B 0))    (abs (+ (* (- 1 scaler) A)(* scaler B)))));(scal-Pair-dtx  '(ser 60) 0)