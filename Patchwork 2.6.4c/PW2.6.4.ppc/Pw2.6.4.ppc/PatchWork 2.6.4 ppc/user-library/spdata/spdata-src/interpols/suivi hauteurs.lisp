(in-package "PW")(defun xtrajt-tabs (LdeL seuil)  (let* ((L ())         (LdeLr ())         (Ltemp ())         vmin)    (dotimes (n (length LdeL))      (push (pop (nth n LdeL)) L))    (setf L (reverse L))            (until (null-l LdeL)            (setf vmin (applymin L) Ltemp ()) ;initialisation            (dotimes (n (length L)(push (reverse Ltemp) LdeLr))                (if (distinf (nth n L) vmin seuil)          (progn             (push (nth n L) Ltemp)            (setf (nth n L) (if (endp (nth n LdeL)) nil (pop (nth n LdeL)))))          (push nil Ltemp))))    (reverse LdeLr)));(xtrajt-tabs '((1 3 5 7 9)(2 8 16 32)(6 36 72)) 2);*****************************************************;applications pour chds (sans amplitudes)(defun xtrajt-chds (Lchds seuil)  (xtrajt-tabs (mapcar 'midics Lchds) seuil))(defun midics (chd)  (mapcar 'midic (notes chd)))(defun velocs (chd)  (mapcar 'vel (notes chd)));*****************************************************(defun xtrajts-tabs (Ldelf Ldela seuil)   (let* ((Lf ())(La ())         (LdeLr ())         (Ltempf ())(Ltempa ())         vmin)    (dotimes (n (length LdeLf))      (push (pop (nth n LdeLf)) Lf)      (push (pop (nth n LdeLa)) La))    (setf Lf (reverse Lf) La (reverse La)) (until (and (null-l LdeLf)(null-l Lf))       (setf vmin (applymin Lf) Ltempf ()  Ltempa ()) ;initialisation      (dotimes (n (length Lf)(push (list (rem-nil-f (reverse Ltempf))                                         (reverse Ltempa)) LdeLr))                (if (distinf (nth n Lf) vmin seuil)          (progn             (push (nth n Lf) Ltempf)            (push (nth n La) Ltempa)            (setf (nth n Lf) (if (endp (nth n LdeLf)) nil (pop (nth n LdeLf))))            (setf (nth n La) (if (endp (nth n LdeLa)) 0 (pop (nth n LdeLa)))))          (progn             (push nil Ltempf)(push 0 Ltempa)))))    (reverse LdeLr)));(xtrajts-tabs '((1 3 5 7 9)(2 8 16 32)(6 36 72)) '((10 9 8 7 6)(4 3 2 1)(0.5 0.3 0.1)) 2)(defun xtrajts-chds (Lchds seuil)"xtrajts-chds construit des listes de listes.   Chaque liste est une liste double et correspond à un partiel donné suivi au cours du temps : liste de hauteurs (en midics) et liste d'amplitudes associées (vels)le seuil donne le glissé max. (en midic) autorisé pour une hauteur entre deux analyses."  (xtrajts-tabs (mapcar 'midics Lchds)(mapcar 'velocs Lchds) seuil));*****************************************************;utils(defun rem-nil-f (liste)  (if (null-l liste) nil      (let ((L ()) prev next)        (dotimes (n (length liste))          (setf prev (prev-non-null liste n))          (setf next (next-non-null liste n))          (cond ((and (null prev)(null next))                 (error "liste vide"))                ((null prev)                 (push (car (next-non-null liste n)) L))                ((null next)                 (push (car (prev-non-null liste n)) L))                ((= 1 (- (cadr (next-non-null liste n)) n)                    (- n (cadr (prev-non-null liste n))))                 (push (/ (+ (car (next-non-null liste n))                             (car (prev-non-null liste n))) 2) L))                ((<= (- (cadr (next-non-null liste n)) n)                    (- n (cadr (prev-non-null liste n))))                 (push (car (next-non-null liste n)) L))                ((> (- (cadr (next-non-null liste n)) n)                    (- n (cadr (prev-non-null liste n))))                 (push (car (prev-non-null liste n)) L))                (t                 (push (nth n liste) L))))        (reverse L))));(rem-nil-f '(1 2 3 nil 4 5 6 nil nil 7 8 9 nil nil nil nil 10));(rem-nil-f '(nil 5900 nil nil));(rem-nil-f '(6700 nil 6700 6700));** to get la valeur plus proche vers le bas ou vers le haut avec son indice **(defun first-non-null (liste)   (if (null-l liste) nil      (do ((val (pop liste)(pop liste))           (n 0 (1+ n)))          ((numberp val)           (list val n)))))        ;(first-non-null '(nil nil 1 2));(first-non-null '(nil));(null-l '(nil))(defun next-non-null (liste n)  (let ((l (first-non-null (nthcdr n liste))))    (if (null l) l    (list (car l)(+ (second l) n)))));(next-non-null '(nil nil nil 1 2 3) 5);(next-non-null '(nil) 5)(defun prev-non-null (liste n)  (let ((l (first-non-null (nthcdr (- (length liste) n 1)(reverse liste)))))    (if (null l) l        (list (car l)(- n (second l))))));(prev-non-null '(3 2 1 nil nil nil 1 2 3) 8);(prev-non-null '(nil 2 1 nil nil nil 1 2 3) 0);(first-non-null (nthcdr (- (length '(nil 2 1 nil nil 1 3)) 0 1)(reverse '(nil 2 1 nil nil 1 3))))(defun applymin (liste)  (let ((l (remove nil liste)))    (if (endp l) nil (apply 'min l))))(defun distinf (x y seuil)  "donne t si x inf à y meme si x est nil"  (if (null x) nil (< (- x y) seuil)));(distinf 3 5 3);(distinf 3 5 1);(distinf nil 4 2)(defun null-l (L)"test si L est nil ou en ensemble de nil"  (cond ((null L)          t)        ((atom L)         nil)        (t         (and (null-l (car L))(null-l (rest L))))));(null '(()()));(null '());(null-l '(()()));(null-l '((1)()));***************************************************