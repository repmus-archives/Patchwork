;;;;======================================================================================;;;;[chabot] 6.12.93               pw-spdata-seq.lisp;;;;;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(addsyn-read addsyn-write addsyn-read2 mask-read mask-write par-spdata-seq mk-spdata-seq write-qlist))(import '(pw:add-pw-input-type pw:add-output-type pw:defunp pw::C-ttybox          pw::make-num-lambda pw::mat-trans));;(shadowing-import '(pw::mat-trans));; the spdata type is a pointer to an instance of C-spdata(add-pw-input-type 'spdata-seq 'C-ttybox '(:view-size #@(36 14)                                           :doc-string "spdata"                                           :value nil                                          :dialog-item-text "()"                                           :type-list (spdata-seq list)))(add-output-type 'spdata-seq '(spdata-seq obj))(defunp mk-spdata-seq ((frames list (:value '()))                     (spdata spdata)) spdata-seq"creates a spdata-seq object with a list of spdata objects and a list of frames"  (when spdata    (unless (listp spdata) (setf spdata (list spdata)))    (when (< (length frames) (length spdata)) ;;when frames list is too short      ;(setf frames (append frames (make-list (- (length spdata) (length frames))      ;                                   :initial-element (car (last frames)))))      (warn "frames list is too short")  ; lp 20/8/94            )  ;  ;; converts in seconds, cumulate for absolute time and store in frame slot  ;  (let (atimes (cumtime 0))  ;    (setf atimes (cons 0 (mapcar #'(lambda( time ) (setf cumtime (+ (/ time 100.) cumtime))) frames)))    ;; write frame slot in spdata      (mapcar #'(lambda (spd time) (setf (frame spd) time)) spdata frames)   ; lp 20/8/94    (make-instance 'C-spdata-seq :duration (car (last frames))                   :spdata spdata :typ (typ (first spdata))                   :file (file (first spdata)))    ));; change 15.04.94: return ((dates) (values))(defunp par-spdata-seq ((spdata-seq spdata-seq)                  (slot (menu (:menu-box-list (("freqs" . freqs)                                              ("amps" . amps)                                              ("bws" . bws)                                              ("weights" . weights)                                              ("phases" . phases)))))                  (partials fix>0s?)) list"returns data in spdata-seq object from the specified slot. format is ((dates ..) (values..)) for one partialand (((dates ..) (values..)) ((dates ..) (values..)) ...) if a list of partials is given in input 3"  (when (and spdata-seq (spdata spdata-seq))    (let ((ret-list ()))    (cond ((listp partials) (remove nil (mapcar #'(lambda(x) (par-spdata-seq spdata-seq slot x)) partials)))          (t            (when (debug spdata-seq) (format t "values for partial ~D slot ~D ((dates..) (values ..))~%" partials slot))             (setf ret-list (remove nil (mapcar  #'(lambda(x) (list (frame x) (get-partial-data x slot partials)))                                  (spdata spdata-seq))                     :key 'cadr))             (when ret-list (mat-trans ret-list))             )))));; read-addsyn-data(defunp read-addsyn ((filename list ( :value  '() :type-list '(string)))                     &optional (beg float (:value '())) (end float (:value '()))                     ) spdata"obsolete name: see addsyn-read"(declare (ignore filename beg end))(warn "addsyn read is an obsolete name; replace this module with addsyn-read"))(defunp addsyn-read ((filename list ( :value  '() :type-list '(string)))                      (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                     &optional (beg float (:value '())) (end float (:value '()))                     (npart float (:value '()))) spdata"reads additive synthesis data and returns a spdata object (c-spdata-seq class)" (let ((spdata-seq (make-instance 'C-spdata-seq )))   (unless filename      (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata-seq)                                           :button-string "addsyn file")))   (when  filename ;(format t "last file is ~D~%" (last-loaded-file spdata-seq))(setf (last-loaded-file spdata-seq) filename);;(setf *lastspfile* filename)     (ecase format       (ascii (read-addsyn-data spdata-seq filename beg end npart))       (bin (read-addsyn-bindata spdata-seq filename beg end)))   )   ));; write-addsyn-data(defunp addsyn-write ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list (spdata-seq)))) spdata"takes a spdata-seq "  (assert spdata () "spdata input is nil~D")  (unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                           :button-string "save")))  (when  filename     (setf (last-loaded-file spdata) filename)    (write-addsyn-data spdata filename)))(defunp addsyn-read2 ((filename list ( :value  '() :type-list '(string)))                      (npart float (:value 0))                       (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                      &optional (beg float (:value '())) (end float (:value '()))) spdata        "reads additive synthesis data and returns a spdata object (c-spdata-seq class)"  (declare (ignore filename format npart beg end))  (warn "use now addsyn-read"  ))(defunp mask-read ((filename list ( :value  '() :type-list '(string)))                   (format (menu (:menu-box-list (("ascii" . ascii) ("bin" . bin)))))                   &optional (beg float (:value '())) (end float (:value '()))                   (nmax float (:value '()))) spdata        "reads mask analysis data and returns a spdata object (c-spdata-seq class)"  (let ((spdata-seq (make-instance 'C-spdata-seq )))    (unless filename       (setf filename (CCL:choose-file-dialog :directory  *lastspfile*                                             :button-string "mask file")))    (when  filename       (setf *lastspfile* filename)      (ecase format        (ascii (read-mask-data spdata-seq filename beg end nmax))        (bin (warn "mask-read: sorry, reading mask analysis data in binary format is not yet implemented")))      )    )  );; write-mask-data(defunp mask-write ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list (spdata-seq)))) spdata"takes a spdata-seq "  (assert spdata () "spdata input is nil~D")  (unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                           :button-string "save")))  (when  filename     (setf (last-loaded-file spdata) filename)    (write-mask-data spdata filename)));;------------------------------ PW-MAX --------------------------------------------(defunp write-qlist ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list ( spdata spdata-seq)))                     (msg list (:value '(setpartial n freq amp)))                      &optional (freq-method list (:value '()))                     (amp-method list (:value '()))                     (phase-method list (:value '()))                     (reset-flag list (:value '(1)))                     (resfact-flag list (:value '()))) spdata"writes spdata to qlist with format defined by msg;msg must be in the form:'(<msg> {n}{<slot-name}*)<msg> will be a global message name in the qlist sent with spdata parameters. qlist lines consistof a line such as/msg slotvalue slotvalue ...;(exemple '(setpartials partials freqs) producessetpartials 1 100.0 ;setpartials 2 120.0; etc... if 'n' is present right after <msg>, an index is appended to the message name:'(setpartial n freqs amps) producessetpartial1 100.0 0.1;setpartial2 120.0 0.8; etc....When reset flag is true (default), data to reset the spectrum is added with the time tag -1.When qlist is used with the module nqlist-del, the message <rewind, next> will triggerspectrum onset and stop at the -1 time tag of the reset data. In order to trigger reset data, simply send message <next> to the qlist."  (unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                                 :button-string "save")))  (when  filename  (setf (last-loaded-file spdata) filename)(cond ((and spdata (listp spdata)) (warn "write-qlist: list is not yet permitted in the spdata input"))      (spdata (write-spdata-qlist spdata filename msg                                   freq-method amp-method phase-method                                  reset-flag resfact-flag))      (t ()))    )spdata);;(setq toto (make-instance 'c-spdata-seq));; (last-loaded-file toto);;(setf (last-loaded-file toto) "root:")(defunp write-msgbox ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list ( spdata spdata-seq)))                     (msg list (:value '(partials freqs amps)))                      &optional (freq-method list (:value '()))                     (amp-method list (:value '()))                     (phase-method list (:value '()))                     (reset-flag list (:value '(1)))                     (resfact-flag list (:value '()))) spdata"OBSOLETE DOC: REDO!!!!!!!!writes spdata to qlist with format defined by msg;msg must be in the form:'(<msg> {n}{<slot-name}*)<msg> will be a global message name in the qlist sent with spdata parameters. qlist lines consistof a line such as/msg slotvalue slotvalue ...;(exemple '( partials freqs) producessetpartials 1 100.0 ;setpartials 2 120.0; etc... if 'n' is present right after <msg>, an index is appended to the message name:'(setpartial n freqs amps) producessetpartial1 100.0 0.1;setpartial2 120.0 0.8; etc....In this module the reset-flag is not used. Two message boxes are produced:one to set the data and one for reset with all amplitudes = 0. Of course this is useless if the amps slot is not specified in the <msg> input. Data is output through theoutlet in streams of messages"  (unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                                 :button-string "save")))  (when  filename  (setf (last-loaded-file spdata) filename)(cond ((and spdata (listp spdata)) (warn "write-qlist: list is not yet permitted in the spdata input"))      (spdata (write-spdata-msgbox spdata filename msg                                   freq-method amp-method phase-method                                  reset-flag resfact-flag))      (t ()))    )spdata)