;;;;======================================================================================;;;;[chabot] 22.11.93               pw-spdata.lisp;;;;;;;; C-spdata Class;                 ;;;;;;;; Class: C-spdata;;;; Slots:;;;;      ;;;; Constructor:;;;;      ;;;; Methods:;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(llmod-read iana-read par-spdata filter-spdata scale-spdata mk-spdata write-qlist))(import '(pw:add-pw-input-type pw:add-output-type pw:defunp pw::C-ttybox          pw::make-num-lambda epw:arithm-ser pw::mat-trans));;(shadowing-import '(pw::mat-trans));; the spdata type is a pointer to an instance of C-spdata(add-pw-input-type 'spdata 'C-ttybox '(:view-size #@(36 14)                                           :doc-string "spdata"                                           :value nil                                          :dialog-item-text "()"                                           :type-list (spdata list)))(add-output-type 'spdata '(spdata object));;-----------------------------------------------------------------------------;; module reader of lelisp model of resonance(defunp llmod-read ((filename list ( :value  '() :type-list '(string)))) spdata        "reads list of formant parameters and returns  model of resonanceData is in a text file formatted in the lelisp way: frequencies amplitudes and bandwidth are stored in three lists which if evaluated are in globalvariables as follows (however be aware that the original lelisp format has a package #:ana which should be taken away). List must consistent and of equal size(setq l-freqf '( n n n n n))(setq l-amplf '(n n n n n n))(setq l-bandf '(n n n n n))" (let (result (spdata (make-instance 'C-spdata )))      (unless filename         (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata)                                                :button-string "llmodres file")))  (when  filename     ;;(setf *lastspfile* filename)    (cond ((listp filename) ;; filename is a list of filenames (as a result of fct directory for example           (setf result (mapcar #'(lambda (x) (llmodres-data-read (make-instance 'C-spdata ) x)) filename))           (setf (last-loaded-file spdata) (first filename)))          (t ;; single filename           (setf result (llmodres-data-read spdata filename))           (setf (last-loaded-file spdata) filename))          )  result)))(defunp llmod-write ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list (spdata)))) spdata"write spdata object to file in the lelisp model of resonance format"(unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                           :button-string "save")))  (when  filename (setf (last-loaded-file spdata) filename)                   (llmod-data-write spdata filename)));;------------------------------------------------------;; reader for iana data(defunp iana-read ((filename list ( :value  '() :type-list '(string)))               (bwscale fix/float (:value 0.0001))) spdata        "reads iana data and return a spdata object whose parameters are that of the iana file.the bwscale input is used to set bandwidth  arbitrarily to freq/bwscale. iana (iana is an implementation of the spectral analysis algorithm by Terhard; refer to articles)data is a text file formatted in three columns of floating point numbers:frequency   amplitude (linear)   weightComplete spectral data is obtained by using all partials and reduced set is obtainedby keeping only partials with a non zero perceptual weight; see the module filter"        (let (result (spdata (make-instance 'C-spdata )))          (unless filename     (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata)                                           :button-string "iana file")))  (when  filename      (setf (last-loaded-file spdata) filename)   (cond ((listp filename)  ;; several files to read --> return a list of spdata           (setf result (mapcar #'(lambda (x) (iana-data-read (make-instance 'C-spdata ) x bwscale)) filename)))           (t (setf (last-loaded-file spdata) filename) ;; only one file to read              (setf result (iana-data-read spdata filename bwscale))))          )  result));; write-addsyn-data(defunp iana-write ((filename list ( :value  '() :type-list '(string)))                     (spdata object (:type-list (spdata)))) spdata"takes a spdata-seq "  (unless filename     (setf filename (CCL:choose-new-file-dialog :directory  (last-loaded-file spdata)                                           :button-string "save")))  (when  filename (setf (last-loaded-file spdata) filename)         (iana-data-write spdata filename)));;------------------------------------------------------;; access  data in spdata;; change xc 24.04.94 if spdata-seq, returns (<dates> values)(defunp par-spdata ((spdata spdata)                  (slot (menu (:menu-box-list (("freqs" . freqs)                                              ("amps" . amps)                                              ("bws" . bws)                                              ("partials" . partials)                                              ("weights" . weights)                                              ("phases" . phases)                                              ("size" . size)))))) list"get data in spdata object from the specified slot" (when (or (and (atom spdata) (debug spdata))           (and (listp spdata) (debug (first spdata)))) (format t "values for slot ~D~%" slot))  (let (ret-list)    (cond ((listp spdata) (setf ret-list (remove nil (mapcar #'(lambda(x) (funcall slot x)) spdata))))          ((typep spdata 'C-spdata-seq)            (setf ret-list (remove nil (mapcar #'(lambda(x) (list (frame x) (funcall slot x))) (spdata spdata)) :key 'cadr))           (when ret-list (setf ret-list (mat-trans ret-list))))          (t (setf ret-list (funcall slot spdata))))    ret-list))(defunp print-spdata ((spdata spdata)) list"print spdata in column" (when spdata   (cond ((listp spdata) (mapcar #'print-spdata spdata))       ((typep spdata 'C-spdata-seq) (error "do not know how to print spdata-seq yet"))       (t (print-data spdata)))))(defunp mk-spdata ((freqs fix/fl/list )                       (amps fix/fl/list )                       (phases fix/fl/list )                       (partials fix/fl/list )                      (weights fix/fl/list (:value 60))                      (bws fix/fl/list (:value 1)))       spdata"creates a new spdata object or a list of spdata objects. Inputs are simple list to createa single object or a list of lists to create a series of spdata objects. See sp-data-seq"  (let (spdata llsizes)    ; looking for double lists (list of lists) in order : freqs, amps, bws, phases    ; collecting list of sublist sizes if double list, () otherwise    (setf llsizes (or (ll-length freqs)                       (ll-length amps)                      (ll-length bws)                       (ll-length phases)                      ))    (cond (llsizes ;; at least one list of lists --> sequence of spectra    ;; preparing data lists; in order freqs, amps, bws, phases, partials, weights    (setf freqs (fill-if-not-ll "freqs" freqs llsizes))    (setf amps (fill-if-not-ll "amps" amps llsizes))    (setf bws (fill-if-not-ll "bws" bws llsizes))    (setf phases (fill-if-not-ll "phases" phases llsizes))    (setf weights (fill-if-not-ll "weights" weights llsizes))    (setf partials (fill-partials-ll partials llsizes))           ; loop to create list of spdata;(format t "llflag ~D bw ~D~%" llflag bws)           (dotimes (i (length llsizes))           (setf spdata (cons (make-instance 'C-spdata :freqs (nth i freqs)                                                     :amps  (nth i amps)                                                     :phases (nth i  phases)                                                     :partials  (nth i  partials)                                                     :bws (nth i bws)                                                     :weights (nth i weights)                                                     :size (length (nth i freqs))                                                     )                              spdata)))           (setf spdata (reverse spdata)))           (t ;; all inputs are numbers or simple lists --> only one spectrum            (setf llsizes (or (listp-size freqs) (listp-size amps) ; set size to list size if any                            (listp-size bws) (listp-size phases)                             (listp-size weights)))            (when (not llsizes) (error "mk-spdata: all inputs are numbers. At least one list is needed"))            (setf spdata (make-instance 'C-spdata :freqs (fill-if-not-l freqs llsizes)                                                     :amps (fill-if-not-l amps llsizes)                                                     :phases (fill-if-not-l phases llsizes)                                                     :partials (fill-if-not-l partials llsizes)                                                     :bws (fill-if-not-l bws llsizes)                                                     :weights (fill-if-not-l weights llsizes)                                                     :size llsizes                                                     ))            ))    spdata));;------------------------- list utilities -------------------------------------------(defun fill-if-not-l ( obj size)  (cond ((not obj) (error "null input in mk-spdata (fill-if-not-l )"))        ((listp obj)          (cond ((= (length obj) size) obj)               ((< (length obj) size)                 (append obj (make-list (- size (length obj)) :initial-element (car (last obj)))))               ((> (length obj) size) (subseq obj 0 size))               ))        (t ;; should be number         (make-list size :initial-element obj))));; test if list of list. returns list of sublists length if list of lists, length if simple length(defun ll-length (obj)  (cond ((not obj) ()) ;; null object        ((and (listp obj) (not (member-if-not #'listp obj))) (mapcar #'length obj)) ;; list of lists        ((listp obj) ()) ;; simple list        ((numberp obj) ())        (t ())));; if not list of list, make a list repeating element(defun fill-if-not-ll (varname obj sizes)  (let ((lle (ll-length obj)))    (cond (lle (unless (equal lle sizes) (error "bad format for ~D: ~D instead of ~D~%" varname lle sizes))               obj)          ((listp obj) (check-parlist (make-list (length sizes) :initial-element obj) sizes))          (t (mapcar #'(lambda(x) (make-list x :initial-element obj)) sizes))        )    ));; adjust list of lists; obj is a list of lists and sizes is a list of sizes(defun check-parlist (obj sizes)  (when (or (not (listp obj)) (not (listp sizes)) (not (= (length obj) (length sizes))))    (error "check-parlist: bad formats for ~D and ~D~%" obj sizes))  (let (curemt result cursize curlength)  (dotimes (i (length obj))    (setf curemt (pop obj))    (setf cursize (nth i sizes))    (setf curlength (length curemt))    (setf curemt (cond ((< curlength cursize) ;; list in list of lists is too short           (append curemt (make-list (- cursize curlength) :initial-element (car (last curemt)))))          ((> curlength cursize) (subseq curemt 0 cursize)) ;; current element too long          (t curemt)))    (setf result (cons curemt result)))  (setf result (reverse result))  result))(defun fill-partials-ll ( obj sizes)  (let ((lle (ll-length obj)))    (cond (lle (unless (equal lle sizes) (error "bad format for ~D: ~D instead of ~D~%" "partials" lle sizes))               obj)          ((listp obj) (check-partial-list (make-list (length sizes) :initial-element obj) sizes))        (t (mapcar #'(lambda(x) (arithm-ser 1 1 x)) sizes))        )    ));; adjust list of lists; obj is a list of lists and sizes is a list of sizes(defun check-partial-list (obj sizes)  (when (or (not (listp obj)) (not (listp sizes)) (not (= (length obj) (length sizes))))    (error "check-parlist: bad formats for ~D and ~D~%" obj sizes))  (let (curemt result cursize curlength)  (dotimes (i (length obj))    (setf curemt (pop obj))    (setf cursize (nth i sizes))    (setf curlength (length curemt))    (setf curemt (cond ((< curlength cursize) ;; list in list of lists is too short           (append curemt (arithm-ser (car (last curemt)) 1 (+ (car (last curemt)) (- cursize curlength) ))))          ((> curlength cursize) (subseq curemt 0 cursize)) ;; current element too long          (t curemt)))    (setf result (cons curemt result)))  (setf result (reverse result))  result));; returns list size is a list(defun listp-size (obj)  (cond ((listp obj) (length obj))        (t ())        ))  #|(ll-length   '((1 2 3 4) (2 3) (4 5)))(ll-length   '((1 2 3 4) (2 3) 5))(mapcar #'length '((1 2 3 4) (2 3) (2)))(fill-if-not-ll "freq" '((1) (2 3) (4 6 7)) '(1 2 3))(fill-if-not-ll "freq" '(4 6 7) '(1 2 3))(check-parlist '((1 2 3) (2 3) (4 6 7)) '(6 4 2))(member-if-not #'listp '((1 2 3 4) (2 3) (3)))|#