;;;;======================================================================================;;;;[chabot] 22.11.93               spdata-class.lisp;;;;;;;; C-spdata Class;                 ;;;;;;;; Class: C-spdata;;;; Slots:;;;;      ;;;; Constructor:;;;;      ;;;; Methods:;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(C-spdata size frame partials freqs amps normalize-amps bws phases weights resfact           setup reset llmodres-data-read iana-data-read filter scale write-qlist-header          write-qlist-tail write-spdata-qlist write-qlist-data apply-method  compute-resfact          mk-pars mk-fmt write-ttag-data apply-all-methods))(import '(epw:arithm-ser ccl:mac-namestring epw:l-min epw:l-max epw:g-scaling pw::get-slot           pw::make-num-lambda));(shadowing-import '(mk-pars mk-fmt write-ttag-data apply-all-method));; class for spectral data (additive syntesis; iana, model of resonance)(defclass C-spdata (C-spd)   ((size  :initform 0 :initarg :size :accessor size)    (frame  :initform 0 :initarg :frame :accessor frame)    (partials  :initform () :initarg :partials :accessor partials)    (freqs  :initform () :initarg :freqs :accessor freqs)   (amps  :initform () :initarg :amps :accessor amps)   (normalized-amps :initform () :accessor normalized-amps)   (bws  :initform () :initarg :bws :accessor bws)   (phases  :initform () :initarg :phases :accessor phases)   (weights :initform () :initarg :weights :accessor weights)   (resfact :initform () :accessor resfact)))(defmethod copy-instance ((self C-spdata))  (make-instance 'C-spdata :size (size self) :frame (frame self)                                    :partials (partials self) :freqs (freqs self) :amps (amps self)                                     :bws (bws self) :phases (phases self) :weights (weights self)                                    :typ (typ self) :file (file self)));;;; utilities(defmethod normalize-amps ((self C-spdata) scaling)  (when (amps self)  (let ((s0 (* scaling (reduce '+ ( amps self)))) result)   (when (debug self)  (format t " normalizing amplitudes; normalisation factor ~4F~%" s0))     (setq result (if (not (=  s0 0.0)) (mapcar #'(lambda(x) (/ x s0)) ( amps self))                      ( amps self)))     (setf (normalized-amps self) result))  ));; computes resonance factor;; correction xc 09.94: remaplce amps par 1 si somme nulle(defmethod compute-resfact ((self C-spdata))  (when (and (bws self) (not (member 0 (bws self) :test #'=)))  ;; computing resonance factor = (sqrt (/ (sum ((amps self) / (bws self)^2)) (sum (amps self))))           (setf (resfact self) (sqrt (/ (reduce #'+ (mapcar #'(lambda (x y) (/ x (* y y))) (amps self) (bws self)))                                            (let ((toto (reduce #'+ (amps self)))) (if (> toto 0) toto 1)))))                 (when (debug self) (format t "resonance factor ~,8F~%" (resfact self)))                  (resfact self)))(defmethod setup ((self C-spdata) freqs amps bws phases partials weights type file)      (setf (freqs self) freqs)      (setf (amps self) amps)      (setf (bws self) bws)    (setf (size self) (length (freqs self)))    (setf (phases self) phases)    (setf (partials self) partials)    (setf (weights self) weights)    (setf (typ self) typ)    (setf (file self) file)self)(defmethod reset  ((self C-spdata))   (setup self () () () () () () 'empty ())self)(defmethod print-data  ((self C-spdata))  (cond ((<= (size self) 0) (warn "print-data: model of resonance ~D type ~D is of null size~%" (file self) (typ self)))        (t         (format t "model of resonance ~D type ~D~%" (file self) (typ self))         (format t "n~4Tpartial~10Tfreq~22Tamp(dB)~34Tbw~44Tweight~56Tphase~%")         (dotimes (i (size self))           (cond ((> (nth i (amps self)) 0)                  (format t "~D~4T~D~10T~,2F~22T~,2F~34T~,4F~44T~,6F~56T~,4F~%"                           (+ 1 i) (nth i (partials self)) (nth i (freqs self))                          (* 20 (log (nth i (amps self)) 10))                          (if (nth i (bws self)) (nth i (bws self)) 0)                          (if (nth i (weights self)) (nth i (weights self)) 0)                          (if (nth i (phases self)) (nth i (phases self)) 0)))                 (t (format t "~D~4T~D~10T~,2F~22T-°~34T~,4F~44T~,6F~56T~,4F~%"                             (+ 1 i) (nth i (partials self)) (nth i (freqs self))                            (if (nth i (bws self)) (nth i (bws self)) 0)                            (if (nth i (weights self)) (nth i (weights self)) 0)                            (if (nth i (phases self)) (nth i (phases self)) 0))                    )                 )           )))self);;;-------------------------- methods for modres -----------------------------------------------(defmethod llmodres-data-read ((self C-spdata) filename)  (with-open-file (in filename                  :direction :input)      (let ( freqs amps bws)        (setf freqs  (eval (read in)))        (setf amps  (eval(read in)))        (setf bws  (eval(read in)))        (setup self freqs amps bws () (arithm-ser 1 1 (length freqs))                ()               'llmodres (mac-namestring filename))        (if (> (size self) 0) (format t "finished reading lisp model from file ~D model size ~D~%" filename (length freqs))            (progn (ccl::beep) (warn "iana file ~D has a null~%" filename)))  self)))(defmethod llmod-data-write ((self C-spdata) filename)  (assert (and (freqs self) (amps self) (bws self)) () "llmod-data-write: one of freqs, amps or bws slot is empty; cannot write")  (with-open-file (out filename                       :direction :output :if-exists :supersede :if-does-not-exist :create)    (format t "writing model of resonance data: ~D ...." (file self))    (format out "(setq l-freqs '~D)~%" (freqs self))    (format out "(setq l-ampl '~D)~%" (amps self))    (format out "(setq l-bandf '~D)~%" (bws self))    (format t "done~%")    ));;----------------------------- methods for iana -------------------------------(defmethod iana-data-read ((self C-spdata) filename  scalebw)  (with-open-file (in filename                      :direction :input)    (let ( cc freqs amps bws weights )      (while (setf cc (read in () ())) ;; this way to read is not very strong against bad format files        (setf freqs  (append freqs (list cc) ))        (setf amps  (append  amps (list (read in)) ))        (setf weights  (append weights (list  (read in))))        )      (setf bws (let ((bwslist ()))                  (dotimes (i (length freqs))                    (setq bwslist (cons (* (nth i freqs) scalebw) bwslist))                    )                  (reverse bwslist))            )      (setup self freqs amps bws () (arithm-ser 1 1 (length freqs)) weights 'iana (mac-namestring filename))          (if (> (size self) 0) (format t "finished reading iana file ~D model size ~D~%" filename (size self))          (progn (ccl::beep) (warn "iana file ~D has a null~%" filename)))      self)))(defmethod iana-data-write ((self C-spdata) filename)  (assert (and (freqs self) (> (size self) 0)) () "iana-data-write: either freqs slot is empty or size is null; cannot write")  (with-open-file (out filename                      :direction :output :if-exists :supersede :if-does-not-exist :create)    (let ( (freqs (freqs self))  (amps (amps self)) (weights (weights self)))      (cond ((not weights) (warn "iana-data-write: empty weight slot, setting all to 64.")             (setf weights (make-list (length freqs) :initial-element 64.))) ;; default value for weights            ((not amps) (warn "iana-data-write: empty amps slot, setting all to 1/size")             (setf amps (make-list (length freqs) :initial-element (/ 1. (size self)))))            )      (format t "writing iana data: ~D ...." (file self))      (dotimes (i (size self))        (format out  "~,2F~10T~,6F~24T~,6F~%" (nth i freqs) (nth i amps) (nth i weights))        )      (format t "done~%")      )    )  );; -------------------------------- processing data ---------------------------------(defmethod filter ((self C-spdata) fct val slot)  (assert (> (size self) 0) () "filter: cannot filter a spdata of null size")  (when (debug self) (format t "~4Fs: test ~D with val ~D on slot ~D~%" (frame self) fct val slot))    (let ( (to-spdata (copy-instance self)) condexpr (msgbp "for band-pass filter input value must be a pair (inf sup) or a list of pairs ((inf1 sup1) (inf2 sup2) ..)"))             (ecase fct  ;; building filtering expression        (band-pass (assert (listp val) (val) msgbp)                   (cond ((member-if #'listp val) (assert (and (not (member-if-not #'listp val))                                                               (not (member-if-not #'(lambda(x) (if (= (length x) 2) t ())) val))) (val)                                                          msgbp)                                                          (setf condexpr ())                          ; construct expression (or (and (x >= min) (x <= max)) (and ....)) for all band-pass values                          (dolist (bp val) (setf condexpr (append condexpr `((and (>= x ,(car bp)) (<= x ,(cadr bp)))))))                          (setf condexpr (make-num-lambda (cons 'or condexpr)))                          (filter-aux to-spdata condexpr  slot))                         (t (setf condexpr (make-num-lambda `(and (>= x ,(car val)) (<= x ,(cadr val)))))                            (filter-aux  to-spdata condexpr  slot))))        (low-pass (assert (numberp val) (val) "value for low pass must be a number")                  (setf condexpr (make-num-lambda `(<= x ,val)))                  (filter-aux to-spdata condexpr  slot))        (high-pass (assert (numberp val) (val) "value for low pass must be a number")                   (setf condexpr (make-num-lambda `(> x ,val)))                   (filter-aux to-spdata condexpr  slot))        (reject-band (assert (listp val) (val) msgbp)                     (cond ((member-if #'listp val) (assert (and (not (member-if-not #'listp val))                                                               (not (member-if-not #'(lambda(x) (if (= (length x) 2) t ())) val))) (val)                                                          msgbp)                                                          (dolist (bp val) (setf condexpr (make-num-lambda `(or (<= x ,(car bp)) (>= x ,(cadr bp)))))                                  (filter-aux to-spdata condexpr  slot)))                         (t (setf condexpr (make-num-lambda `(and (<= x ,(car val)) (>= x ,(cadr val)))))                            (filter-aux self condexpr val slot))))        (eq (cond ((listp val)                     (setf condexpr (make-num-lambda `(when (member  x  ',val) t)))                                                    (filter-aux to-spdata condexpr  slot ))                  (t (setf condexpr (make-num-lambda `(= x ,val)))                      (filter-aux to-spdata condexpr  slot))                  ))        (neq (cond ((listp val)                      (setf condexpr (make-num-lambda `(when (not (member x ',val)) t)))                           (filter-aux to-spdata condexpr  slot))                  (t (setf condexpr (make-num-lambda `(/= x ,val)))                      (filter-aux to-spdata condexpr  slot))                  ))        )        (setf (frame to-spdata) (frame self))      (setf (typ to-spdata) (typ self))      (setf (size to-spdata) (length (freqs to-spdata)))      (setf (file to-spdata) (concatenate 'string (file self) "  filtered"))      (when (<= (size to-spdata) 0) (ccl::beep) (warn "filter: output spdata of null size"))      to-spdata)    );(setq toto (make-instance 'C-spdata));(setf (debug toto) t)(defmethod filter-aux ((self C-spdata) condexpr  slot)  (when (debug self) (format t "expr ~D~%" condexpr))  (let ( condflags tmp)    (setf condflags (mapcar (eval `(function ,condexpr)) (funcall slot self))) ;; apply filter to slot and collect in flag list    (when (debug self)  (format t "result ~D~%" condflags))    (dolist (varslot '(freqs amps bws phases weights partials))      ;(format t "varslot ~D data ~D~%" varslot (funcall varslot self))      (when (slot-value self varslot) ;; if slot is not empty, then it must have lenght = size        (setf tmp (slot-value self varslot))        (setf (slot-value self varslot) ())        (mapc  #'(lambda (flag x)                   (when flag (setf (slot-value self varslot) (push x (slot-value self varslot)))) ;; if filter test was t, put parameter in slot                   ) condflags tmp)        (setf (slot-value self varslot) (reverse (slot-value self varslot))))      )    self)  )(defmethod scale ((self C-spdata) fct val slot)    (let ((to-spdata (copy-instance self)) scaleexpr           (listmin (l-min (slot-value self slot)))          (listmax (l-max (slot-value self slot))))      (ecase fct  ;; building scaling expression        (mul (setf scaleexpr #'(lambda (x) (* x val))))        ;; not useful !!!(min (setf scaleexpr #'(lambda (x) (/ (* x val) listmin))))        (max (setf scaleexpr #'(lambda (x) (/ (* x val) listmax))))        (min-max (setf scaleexpr  ;; val must be (newmin newmax) and formula = newmin + (x min)* (max - min)/(newmax - newmin)                       #'(lambda (x) (+ (car val) (* (- x listmin) (/ (- (cadr val) (car val)) (- listmax listmin)))))))        )      ;(format t "expr ~D~%" condexpr)      (setf (slot-value to-spdata slot) (mapcar scaleexpr (slot-value to-spdata slot))) ;; apply scaling to slot     ; (format t "result ~D~%" condflags)      to-spdata))(defmethod get-partial-data ((self C-spdata) slot partial)   (let (nn (ret nil))    (setf nn (position partial (partials self)))     (when nn (setf ret (nth nn (par-spdata self slot )))  ;; lp 18/08/94   ;; (format t " read partial ~D in slot ~D: ~4F~%" partial slot ret)    ret)  ));;;------------------------- PW-MAX --------------------------------------------(defmethod apply-method ((self C-spdata) fmethod)  (let (fct rvalue)      (cond (fmethod (setf fct (make-num-lambda fmethod)) ;; build lambda expression to process slot                     (format t "method is ~D~%" fct)                     ;; apply  lambda function built from the method to arguments; args must have spdata slot names                     (setf rvalue (case (length (second fct))                                    (1 (mapcar (eval `(function ,fct)) (get-slot self (first (second fct)))))                                    (2 (mapcar (eval `(function ,fct)) (get-slot self (first (second fct)))                                                 (get-slot self (second (second fct)))))                                    (3 (mapcar (eval `(function ,fct)) (get-slot self (first (second fct)))                                                 (get-slot self (second (second fct))) (get-slot self (third (second fct)))))                                    (otherwise ())))                         )            (t ()))      rvalue))#|(setq calcul '(/ (* amp 10) freq))(setq fct (pw::make-num-lambda calcul))(member 'freq (second fct))(mapcar (eval `(function ,fct)) '(100 200) '(0.1 0.2))|#;;; ------------------------------------------ qlist ----------------------------------------------;; correction 24.04.94: no time delay for note onset, always 0; if delay is needed , use spdata-seq(defmethod write-qlist-data ((self C-spdata) out msg freq-method amp-method phase-method reset-flag resfact-flag)"writes addsyn object to qlist"(let (fmt  (pars ()) (killpars ()) wfreqs wamps wphases)  ;; apply parameter correction formula (methods) if necessary  (multiple-value-setq (wamps wfreqs wphases)    (apply-all-methods self freq-method amp-method phase-method)    )  ;; parse msg and constructformat string and parameter sequence  (setf fmt (mk-fmt self msg ))  (multiple-value-setq ( pars killpars)     (mk-pars self msg wfreqs wamps wphases))      ;(format t "~%pars is ~D~%" pars)      ;(format t " command has ~D parameters~%" (length pars))      ;; finaly writing values collected in pars out to the file     (write-ttag-data self out fmt 0 msg pars)  ;; eventually put frame time tag as delay in ms????         (when resfact-flag        (if (resfact self)          (format out "#X append resfact ~,4F \\;;~%" (resfact self))          (warn "cannot write resfact because nil; check values in bws slot"))        )     (when reset-flag (write-ttag-data self out fmt -1 msg killpars)) ;; if flag, write reset data after -1 for stop qlist            ) );; construct fmt string(defmethod mk-fmt ((self C-spdata)  msg)  (let (fmt par )      (setf fmt  (format () "#X append ~D" (pop msg))) ;; start building print format for #X append lines in qlist      (while (setf par (pop msg))        ; (format t "processing ~D  " par)        ;  constructing the corresponding string format to be used for #X append lines in qlist        (cond ((string= par 'n)               (setf fmt (concatenate 'string fmt " ~D")))              ((string= par '-n)               (setf fmt (concatenate 'string fmt "~D")))              ((string= par 'partials)                (setf fmt (concatenate 'string fmt " ~D")))              ((string= par '-partials)                (setf fmt (concatenate 'string fmt "~D")))              ((string= par 'freqs)                (setf fmt (concatenate 'string fmt " ~,2F")))              ((string= par 'amps)                (setf fmt (concatenate 'string fmt " ~,6F")))              ((string= par 'bws)                (setf fmt (concatenate 'string fmt " ~,4F")))              ((string= par 'phases)                (setf fmt (concatenate 'string fmt " ~,4F")))              (t (warn "unkown parameter ~D in mk-fmt~%" par))              )        )      (setf fmt (concatenate 'string fmt " \\;;~%")) ;; terminate print format string      fmt));; --------------------------------------- msgbox ---------------------------------------------; 12.04.94 change: added outlet(defmethod write-msgbox-header ((self C-spdata) out)  (format out "max v2;~%")  (format out "#N vpatcher 101 126 501 526 ~D;~%" -1) ;; no cpu  (format out "#P comment 60 45 190 4 Spectral data of type ~D: ~D~%size ~D~%;" (typ self)          (pw:strip-pathname (file self)) (size self))  (format out "#P outlet 230 590 15 ;~%")  ; module 7  (format out "#P inlet 38 84 15;~%")  ; module 6  (format out "#P newex 38 114 62 196617 unpack 0 0;~%") ; module 5  (format out "#P newex 38 142 30 196617 sel 0;~%")   ; module 4  (format out "#P button 315 188 15 0;~%")  ; module 3  (format out "#P button 35 191 15 0;~%") ; module 2); 12.04.94 change: added connections message boxes to outlet(defmethod write-msgbox-tail ((self C-spdata) out)  (format out "#P connect 1 0 7 0;~%")        ; left msgbox to outlet   (format out "#P connect 0 0 7 0;~%")        ; right msgbox to outlet   (format out "#P connect 6 0 5 0;~%")        ; inlet to unpack        (format out "#P connect 5 1 4 0;~%")        ; unpack right output to sel 0  (format out "#P connect 4 0 2 0;~%")       ; sel left output to bang for reset (right most)  (format out "#P connect 4 1 3 0;~%") ; sel right output to bang for onset (left most)  (format out "#P connect 3 0 1 0;~%")  ; left most bang to msgbox for onset  (format out "#P connect 2 0 0 0;~%")  ; right most bang to msgbox for reset  (format out "#P pop;~%")  (format t "done~%"))(defmethod write-spdata-msgbox ((self C-spdata) filename msg                                freq-method amp-method phase-method reset-flag resfact-flag)"writes addsyn object to qlist"; makes qlist subpatch  (with-open-file (out filename                      :direction :output :if-exists :supersede :if-does-not-exist :create);; writes patch header plus a general comment      (write-msgbox-header self out)            ;; ecrire les donnees de la sequence      (format t "writing msgbox ~D in file ~D~%" (typ self) filename)      (when  amp-method (normalize-amps self 1))      (when resfact-flag (compute-resfact self)) ; avant (compute-resfact self)      ;; constructing command lines      (write-msgbox1 self out msg                         freq-method amp-method phase-method reset-flag resfact-flag)      (write-msgbox-tail self out)    ));; write data to msgbox(defmethod write-msgbox-data ((self C-spdata) out fmt  msg pars resfact-flag place)  (format out "#P message ~D 220 200 196617  "  place)      (case (length pars)        (1  (mapcar #'(lambda (x) (format out fmt   x)) (first pars)))        (2 (mapcar #'(lambda (x y) (format out fmt   x y)) (first pars) (second pars)))        (3 (mapcar #'(lambda (x y z) (format out fmt   x y z))                    (first pars) (second pars) (third pars)))        (4 (mapcar #'(lambda (x y z w) (format out fmt   x y z w))                    (first pars) (second pars) (third pars) (fourth pars)))        (otherwise (warn "too many parameters in message ~D = ~D (4 max)~%"  msg (length pars)))        )      (cond (resfact-flag             (if (resfact self)               (format out "~%\\; resfact ~,4F \\; ;~%" (resfact self))               (warn "cannot write resfact because nil; check values in bws slot"))             )            (t  (format out ";~%")                     )            ))(defmethod write-msgbox1 ((self C-spdata) out msg freq-method amp-method phase-method reset-flag resfact-flag)"writes addsyn object to qlist"(let (fmt  (pars ()) (killpars ()) wfreqs wamps wphases)  ;; apply parameter correction formula (methods) if necessary  (multiple-value-setq (wamps wfreqs wphases)    (apply-all-methods self freq-method amp-method phase-method)    )  ;; parse msg and constructformat string and parameter sequence  (setf fmt (mk-fmt-msgbox self msg ))  (multiple-value-setq ( pars killpars)     (mk-pars-msgbox self msg wfreqs wamps wphases))      ;(format t "~%pars is ~D~%" pars)      ;(format t " command has ~D parameters~%" (length pars))      ;; finaly writing values collected in pars out to the file     (write-msgbox-data self out fmt msg pars resfact-flag 318)           (when reset-flag (write-msgbox-data self out fmt msg killpars () 38)) ;; if flag, write reset data after -1 for stop qlist            ) );; construct fmt string;; 12.04.94: change no more global message. data is writen between comas(defmethod mk-fmt-msgbox ((self C-spdata)  msg)  (let (fmt par )      ;;  (setf fmt  (format () "~D" (pop msg)))       (while (setf par (pop msg))        ; (format t "processing ~D  " par)        ;  constructing the corresponding string format to be used for #X append lines in qlist        (cond ((string= par 'n)               (setf fmt (concatenate 'string fmt " ~D")))              ((string= par '-n)               (setf fmt (concatenate 'string fmt "~D")))              ((string= par 'partials)                (setf fmt (concatenate 'string fmt " ~D")))              ((string= par '-partials)                (setf fmt (concatenate 'string fmt "~D")))              ((string= par 'freqs)                (setf fmt (concatenate 'string fmt " ~,2F")))              ((string= par 'amps)                (setf fmt (concatenate 'string fmt " ~,6F")))              ((string= par 'bws)                (setf fmt (concatenate 'string fmt " ~,4F")))              ((string= par 'phases)                (setf fmt (concatenate 'string fmt " ~,4F")))              (t (warn "unkown parameter ~D in mk-fmt-msgbox~%" par))              )        )       (setf fmt (concatenate 'string fmt " \\, ")) ;; separate data lists      fmt));; construct fmt string and parameter sequence plus kill sequence(defmethod mk-pars-msgbox ((self C-spdata)  msg wfreqs wamps wphases)  (let ( par (pars ()) (killpars ()))    ;;(setf par (pop msg))       (while (setf par (pop msg))        ; (format t "processing ~D  " par)        ;; collecting list of all parameters to write --> in variable pars and reset values in killpars        ; and constructing the corresponding string format to be used for #X append lines in qlist        (cond ((or (string= par 'n) (string= par '-n) )               (setf pars (push (arithm-ser 1 1 (size self))  pars))               (setf killpars (push (arithm-ser 1 1 (size self))  killpars)))              ((or (string= par 'partials) (string= par '-partials) )               (setf pars (push (partials self)  pars))               (setf killpars (push (partials self)  killpars)))              ((string= par 'freqs)                (setf pars (push  wfreqs pars))               (setf killpars (push  wfreqs killpars)))              ((string= par 'amps)                (setf pars (push  wamps pars))               (setf killpars (push  (make-list (size self) :initial-element 0) killpars))) ; reset amplitude              ((string= par 'bws)                (setf pars (push  (bws self) pars))               (setf killpars (push  (mapcar #'(lambda (x) (/ x 4.)) wfreqs) killpars))) ; reset bws to 1/4 freq values              ((string= par 'phases)                (setf pars (push  wphases pars))               (setf killpars (push  wphases killpars)))              (t (warn "unkown parameter ~D in mk-pars~%" par))              )        )      (setf killpars (reverse killpars))      (setf pars (reverse pars))      (values  pars killpars)      )); ------------------------------------------ common ----------------------------------;; construct fmt string and parameter sequence plus kill sequence(defmethod mk-pars ((self C-spdata)  msg wfreqs wamps wphases)  (let ( par (pars ()) (killpars ()))    (setf par (pop msg)) ;; poping msg name      (while (setf par (pop msg))        ; (format t "processing ~D  " par)        ;; collecting list of all parameters to write --> in variable pars and reset values in killpars        ; and constructing the corresponding string format to be used for #X append lines in qlist        (cond ((or (string= par 'n) (string= par '-n) )               (setf pars (push (arithm-ser 1 1 (size self))  pars))               (setf killpars (push (arithm-ser 1 1 (size self))  killpars)))              ((or (string= par 'partials) (string= par '-partials) )               (setf pars (push (partials self)  pars))               (setf killpars (push (partials self)  killpars)))              ((string= par 'freqs)                (setf pars (push  wfreqs pars))               (setf killpars (push  wfreqs killpars)))              ((string= par 'amps)                (setf pars (push  wamps pars))               (setf killpars (push  (make-list (size self) :initial-element 0) killpars))) ; reset amplitude              ((string= par 'bws)                (setf pars (push  (bws self) pars))               (setf killpars (push  (mapcar #'(lambda (x) (/ x 4.)) wfreqs) killpars))) ; reset bws to 1/4 freq values              ((string= par 'phases)                (setf pars (push  wphases pars))               (setf killpars (push  wphases killpars)))              (t (warn "unkown parameter ~D in mk-pars~%" par))              )        )      (setf killpars (reverse killpars))      (setf pars (reverse pars))      (values  pars killpars)      ))(defmethod apply-all-methods ((self C-spdata) freq-method amp-method phase-method)  (let ((wamps (if amp-method (apply-method self amp-method) (amps self))) ;; amps should be set first before freqs        (wfreqs (if freq-method (apply-method self freq-method) (freqs self)))        ( wphases (if phase-method (apply-method self phase-method) (phases self))))  (values wamps wfreqs wphases)))