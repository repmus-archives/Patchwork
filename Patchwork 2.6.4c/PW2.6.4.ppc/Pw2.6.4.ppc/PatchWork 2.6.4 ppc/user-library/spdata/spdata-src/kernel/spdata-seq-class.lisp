;;;;======================================================================================;;;;[chabot] 22.11.93               spdata-seq-class.lisp;;;;;;;; C-spdata Class;                 ;;;;;;;; Class: C-spdata-seq;;;; Slots:;;;;      ;;;; Constructor:;;;;      ;;;; Methods:;;;;      ;;;;=======================================================================================(in-package :spdata)(export '(C-spdata-seq filter scale duration spdata typ file last-loaded-file))(import '());(shadowing-import '(mk-pars mk-fmt write-ttag-data apply-all-method));; class for spectral data (additive syntesis; iana, model of resonance)(defclass C-spdata-seq (C-spd)   ((duration  :initform 0 :initarg :duration :accessor duration)    (spdata  :initform () :initarg :spdata :accessor spdata) ;; list of time-tagged spectra))(defmethod filter ((self C-spdata-seq) fct val slot)  (make-instance 'C-spdata-seq :duration (duration self)                               :typ (typ self) :file (file self)                               :spdata (mapcar #'(lambda (x) (filter x fct val slot))                                               (spdata self))))(defmethod scale ((self C-spdata-seq) fct val slot)  (make-instance 'C-spdata-seq :duration (duration self)                               :typ (typ self) :file (file self)                               :spdata (mapcar #'(lambda (x) (scale x fct val slot))                                               (spdata self))));;(defmethod normalize-amps ((self C-spdata-seq) scaling)  (when (spdata self)  (when (debug self) (format t "normalizing amps in spdata-seq ~D ...." (typ self)))  (mapcar #'(lambda (x) (normalize-amps x scaling)) (spdata self))  (when (debug self) (format t "done~%"))))(defmethod compute-resfact ((self C-spdata-seq))  (when (spdata self)    (when (debug self) (format t "computing resfact in spdata-seq ~D ....." (typ self)))  (mapcar #'(lambda (x) (compute-resfact x)) (spdata self))  (when (debug self) (format t "done~%"))  ))(defmethod write-qlist-data ((self C-spdata-seq) out msg                              freq-method amp-method phase-method reset-flag resfact-flag)"writes addsyn-seq object to qlist"(declare (ignore reset-flag resfact-flag))(let ((myspdata-seq (spdata self)) ( prevtime 0) (curtime 0) curspdata fmt       (pars ()) (killpars ()) wfreqs wamps wphases)  ;; parse msg and construct format string   (setf fmt (mk-fmt (first (spdata self)) msg))   (format t "processing spectra from ~4Fs to ~4Fs~%" (frame (first myspdata-seq))            (frame (car (last myspdata-seq))))   (while  (setf  curspdata (pop myspdata-seq))     (format t "~6F " (frame curspdata))     (setf curtime (round (* 1000 (frame curspdata))))     ; computing freq amp and bw transformation if necessary     (multiple-value-setq (wamps wfreqs wphases)       (apply-all-methods curspdata freq-method amp-method phase-method))     ;; constructing list parameter values to write     (multiple-value-setq ( pars killpars)       (mk-pars curspdata msg wfreqs wamps wphases))     ;; writing values using fmt string;;(format t "pars ~D~%" pars)    (write-ttag-data self out fmt (- curtime prevtime) msg pars)    (setf prevtime curtime)     )  ; (write-ttag-data self out fmt -1 msg killpars) ;; last kill values after -1 for stop qlist    ) );; change 22.04.94: assert checks on beg and end integrity and;; frame is now absolute time;; change xc 29/9.94 stop reading afer end if end specified(defmethod read-addsyn-data ((self C-spdata-seq) filename beg end &optional npart)(if npart (read-addsyn-data2 self filename npart beg end)(progn  (cond ((and beg end) (assert (> end beg) () "addsyn-read: beg must be > end"))        (beg (assert (>=  beg 0) () "addsyn-read: beg must be >= 0"))        (end (assert (>  end 0) () "addsyn-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (curline readframe cursize curaddsyn-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil))) ;; loop on frames        (setf readframe (read in))        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) (setf continueflag t) ())                                        ((<= readframe end ) (setf continueflag t) t)                                        (t  (setf continueflag ()) ())))               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0))          (setf curaddsyn-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (dotimes (i cursize)          (cond (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 (setf (partials curaddsyn-frame) (cons (read in) (partials curaddsyn-frame)))                 (setf (freqs curaddsyn-frame) (cons (read in) (freqs curaddsyn-frame)))                 (setf (amps curaddsyn-frame) (cons (read in) (amps curaddsyn-frame)))                 (setf (phases curaddsyn-frame) (cons (read in) (phases curaddsyn-frame))))                (t (setf curline (read-line in))) ;; dump because out of interval beg-end                 )          )        (when (and calculeflag (> cursize 0))          (setf (frame curaddsyn-frame) readframe)          (setf (size curaddsyn-frame) cursize)          (setf (partials curaddsyn-frame) (reverse (partials curaddsyn-frame)))          (setf (freqs curaddsyn-frame) (reverse (freqs curaddsyn-frame)))          (setf (amps curaddsyn-frame) (reverse (amps curaddsyn-frame)))          (setf (bws curaddsyn-frame) (make-list (length (amps curaddsyn-frame)) :initial-element 1))  ; lp 20/8/94          ; (setf normalized-amps (normalize-amp amps))          (setf (phases curaddsyn-frame) (reverse (phases curaddsyn-frame)))          (setf (spdata self) (cons curaddsyn-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self))) #|  ;; add a spdata equal to the first one but with 0 amplitudes  ; lp : évitons ;      (setf curaddsyn-frame (copy-instance (first (spdata self))))      (setf (frame curaddsyn-frame) 0)      (setf (amps curaddsyn-frame) (make-list (size curaddsyn-frame) :initial-element 0))      (setf (spdata self) (cons curaddsyn-frame (spdata self))) |#      (when beg ;; if begin time was specified, adjust all time frame values      ;;;;;;;;;  (when (= beg (frame (first (spdata self))))       ;;;;;;;;;;    (setf beg (- beg (- (first (spdata self)) (second (spdata self))))))        (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )         (setf (file self) (mac-namestring filename))      (setf (typ self) 'addsyn)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))    ))self)))(defmethod read-addsyn-bindata ((self C-spdata-seq) filename beg end)  (cond ((and beg end) (assert (> end beg) () "addsyn-read: beg must be > end"))        (beg (assert (>=  beg 0) () "addsyn-read: beg must be >= 0"))        (end (assert (>  end 0) () "addsyn-read: end must be > 0"))        )  (with-open-file (in filename :direction :input :element-type '(unsigned-byte 32))(warn "lecture binaire, pas encore implémenté")))(defmethod write-addsyn-data ((self C-spdata-seq) filename)  (with-open-file (out filename :direction :output :if-exists :supersede :if-does-not-exist :create)    (let ((spdatalist (spdata self)) curspdata (curtime 0) cursize curpartials curfreqs curamps curphases)      (format t "writing addsyn data: ~D (~Ds)~%" (file self) (duration self))      (while (setf curspdata (pop spdatalist))        (setf curtime (+ curtime (frame curspdata)))        (setf cursize (size curspdata)              curpartials (partials curspdata)              curfreqs (freqs curspdata)              curamps (amps curspdata)              curphases (phases curspdata))        (format t "~4F   " (frame curspdata))        (format out "~D~10T~,6F~%" cursize (frame curspdata))        (dotimes (i cursize)          (format out "~D~10T~6F~,20T~,6F~35T~,6F~%" (nth i curpartials) (nth i curfreqs) (nth i curamps)                   (nth i curphases))          )        )      (format t "done~%")      )    ));*********************************************;; read-mask-data(defmethod read-mask-data ((self C-spdata-seq) filename beg end &optional nmax)  (cond ((and beg end) (assert (> end beg) () "mask-read: beg must be > end"))        (beg (assert (>=  beg 0) () "mask-read: beg must be >= 0"))        (end (assert (>  end 0) () "mask-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (curline readframe cursize curmask-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil)))                (setf cursize (round (if nmax (min nmax cursize) cursize)))  ;si limitation du nombre de pics (sera peut-être modifié par les developpeurs)                (setf readframe (read in))        ;;;;;(format t "readfdrame : ~a~%" readframe)        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) (setf continueflag t) ())                                        ((<= readframe end ) (setf continueflag t) t)                                        (t  (setf continueflag ()) ())))               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0))          (setf curmask-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (dotimes (i cursize)          (cond (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 (setf (freqs curmask-frame) (cons (read in) (freqs curmask-frame)))                 (setf (amps curmask-frame) (cons (read in) (amps curmask-frame)))                 (setf (weights curmask-frame) (cons (read in) (weights curmask-frame))))                (t (setf curline (read-line in))) ;; dump because out of interval beg-end                )          )        (when (and calculeflag (> cursize 0))          curline  ;for no more warnings          (setf (frame curmask-frame) readframe)          (setf (size curmask-frame) cursize)          (setf (partials curmask-frame) (arith0 1 1 cursize))          (setf (freqs curmask-frame) (reverse (freqs curmask-frame)))          (setf (amps curmask-frame) (reverse (amps curmask-frame)))          (setf (weights curmask-frame) (reverse (weights curmask-frame)))          (setf (bws curmask-frame) (make-list (length (amps curmask-frame)) :initial-element 1))  ; lp 20/8/94          ;(setf normalized-amps (normalize-amp amps))          (setf (phases curmask-frame) (make-list (length (amps curmask-frame)) :initial-element 0))           (setf (spdata self) (cons curmask-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self)))            (when beg ;; if begin time was specified, adjust all time frame values       (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )            (setf (file self) (mac-namestring filename))      (setf (typ self) 'mask)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))      ))  self)(defun arith0 (dep pas n)  (let ((L ()))    (dotimes (i n (reverse L))      (push (+ (* pas i) dep) L))));(arith0 -1 2 10)(defmethod write-mask-data ((self C-spdata-seq) filename)  (with-open-file (out filename :direction :output :if-exists :supersede :if-does-not-exist :create)    (let ((spdatalist (spdata self)) curspdata (curtime 0) cursize curfreqs curamps curweight)      (format t "writing mask data: ~D (~Ds)~%" (file self) (duration self))      (while (setf curspdata (pop spdatalist))        (setf curtime (+ curtime (frame curspdata)))        (setf cursize (size curspdata)              curfreqs (freqs curspdata)              curamps (amps curspdata)              curweight (weights curspdata))        (format t "~4F   " (frame curspdata))        (format out "~D~10T~,6F~%" cursize (frame curspdata))        (dotimes (i cursize)          (format out "~D~10T~10F~,20T~,6F~%"  (nth i curfreqs) (nth i curamps) (nth i curweight))          )        )      (format t "done~%")      )    ));(format t "~D~10T~9F~,20T~,6F~%"  10 11 12);~a #\tab;**********************************************;redefini read-addsyn pour même nbre de partiels partout(defmethod read-addsyn-data2 ((self C-spdata-seq) filename npart beg end)  (cond ((and beg end) (assert (> end beg) () "addsyn-read: beg must be > end"))        (beg (assert (>=  beg 0) () "addsyn-read: beg must be >= 0"))        (end (assert (>  end 0) () "addsyn-read: end must be > 0"))        )  (with-open-file (in filename :direction :input)    (let (readframe cursize curaddsyn-frame  (continueflag t) (calculeflag ()))      (while (and continueflag (setf cursize (read in nil nil))) ;; loop on frames        (setf readframe (read in))        (cond ((and (not end) (not beg)) ;; if beg and end nil, read it all               (setf calculeflag t)               )              ((and end (not beg)) ;; start from 0 until specified end in ms               (setf calculeflag (<= readframe end)))              ((and beg end)               (setf calculeflag  (cond ((< readframe beg) (setf continueflag t) ())                                        ((<= readframe end ) (setf continueflag t) t)                                        (t  (setf continueflag ()) ())))               )              ((and (not end) beg)               (setf calculeflag (>= readframe beg)))              )        (when (and calculeflag (> cursize 0))          (setf curaddsyn-frame (make-instance 'C-spdata))           (format t "~Ds : ~D partials~%" readframe cursize)          )        (let (pos (n 1) (last-f 10)(nlast cursize))     ;valeurs arbitraires par défaut si 1er part absent          (cond (calculeflag  ;; when partial to read, push items in lists, if not, read all line and dump                 (dotimes (i npart)                   (setf (partials curaddsyn-frame) (cons (1+ i) (partials curaddsyn-frame)))                    (if (or pos (zerop nlast))()(setf pos (read in nil)))    ; lecture n° partiel                   (if (and (eq pos (1+ i))(not (zerop nlast)))             ; si n°part = n°part ou nlast=0                     (progn (setf pos nil)                            (setf last-f (read in))                         ; dernière fréquence lue                            (setf nlast (1- nlast))                            (setf n (1+ i))                                 ; repère l'indice de la dernière fréquence trouvée                            (setf (freqs curaddsyn-frame)(cons last-f (freqs curaddsyn-frame)))                            (setf (amps curaddsyn-frame) (cons (read in) (amps curaddsyn-frame)))                            (setf (phases curaddsyn-frame) (cons (read in) (phases curaddsyn-frame)))                            )                     (progn (setf (freqs curaddsyn-frame)(cons (* (/ (1+ i) n) last-f) (freqs curaddsyn-frame)))                            (setf (amps curaddsyn-frame) (cons 0 (amps curaddsyn-frame)))                            (setf (phases curaddsyn-frame) (cons 0 (phases curaddsyn-frame)))                            ))))                 (t                   (dotimes (i cursize)                    (read-line in))) ;; dump because out of interval beg-end                  ))        (when (and calculeflag (> cursize 0))          (setf (frame curaddsyn-frame) readframe)          (setf (size curaddsyn-frame) cursize)          (setf (partials curaddsyn-frame) (reverse (partials curaddsyn-frame)))            (setf (freqs curaddsyn-frame) (reverse (freqs curaddsyn-frame)))          (setf (amps curaddsyn-frame) (reverse (amps curaddsyn-frame)))          (setf (bws curaddsyn-frame) (make-list (length (amps curaddsyn-frame)) :initial-element 1))  ; lp 20/8/94          ; (setf normalized-amps (normalize-amp amps))          (setf (phases curaddsyn-frame) (reverse (phases curaddsyn-frame)))          (setf (spdata self) (cons curaddsyn-frame (spdata self)))          )        )      (setf (spdata self) (reverse (spdata self)))      (when beg ;; if begin time was specified, adjust all time frame values         (mapc #'(lambda (x) (setf (frame x) (- (frame x) beg))) (spdata self))        )       (setf (file self) (mac-namestring filename))      (setf (typ self) 'addsyn)      (setf (duration self) (- (frame (car (last (spdata self)))) (frame (first (spdata self)))))      (format t "finished reading additive synthesis  file ~D from time ~5F to ~5F duration ~5F ~%" filename               (if beg beg 0) (if end end readframe) (duration self))      ))  self);*******************************#|(setq toto (make-instance 'C-spdata-seq))(describe toto)(setf (file  toto) "titi")|#