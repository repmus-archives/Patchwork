(in-package :spdata)(defclass c-spdata-fg (C-spdata)((flags  :initform nil :initarg :flags :accessor flags)   ))(defmethod setup ((self c-spdata-fg) freqs amps bws phases partials weights type file)  (setf (freqs self) freqs)  (setf (amps self) amps)  (setf (bws self) bws)  (setf (size self) (length (freqs self)))  (setf (flags self) (make-list (length (freqs self)) :initial-element t))  (setf (phases self) phases)  (setf (partials self) partials)  (setf (weights self) weights)  (setf (type self) type)  (setf (file self) file)  self)(defunp llmod-fg-read ((filename list ( :value  '() :type-list '(string)))) spdata        "reads list of formant parameters and returns  model of resonanceData is in a text file formatted in the lelisp way: frequencies amplitudes and bandwidth are stored in three lists which if evaluated are in globalvariables as follows (however be aware that the original lelisp format has a package #:ana which should be taken away). List must consistent and of equal size(setq l-freqf '( n n n n n))(setq l-amplf '(n n n n n n))(setq l-bandf '(n n n n n))" (let (result (spdata (make-instance 'C-spdata-fg ))) ;;;create spdata with flags      (unless filename         (setf filename (CCL:choose-file-dialog :directory  (last-loaded-file spdata)                                                :button-string "llmodres file")))  (when  filename     ;;(setf *lastspfile* filename)    (cond ((listp filename) ;; filename is a list of filenames (as a result of fct directory for example           (setf result (mapcar #'(lambda (x) (llmodres-data-read (make-instance 'C-spdata ) x)) filename))           (setf (last-loaded-file spdata) (first filename)))          (t ;; single filename           (setf result (llmodres-data-read spdata filename))           (setf (last-loaded-file spdata) filename))          )  result)))(defmethod filter ((self C-spdata-fg) fct val slot)  (assert (> (size self) 0) () "filter: cannot filter a spdata of null size")  (when (debug self) (format t "~4Fs: test ~D with val ~D on slot ~D~%" (frame self) fct val slot))    (let ( ;;;;;(to-spdata (copy-instance self)) condexpr (msgbp "for band-pass filter input value must be a pair (inf sup) or a list of pairs ((inf1 sup1) (inf2 sup2) ..)"))             (ecase fct  ;; building filtering expression        (band-pass (assert (listp val) (val) msgbp)                   (cond ((member-if #'listp val) (assert (and (not (member-if-not #'listp val))                                                               (not (member-if-not #'(lambda(x) (if (= (length x) 2) t ())) val))) (val)                                                          msgbp)                                                          (setf condexpr ())                          ; construct expression (or (and (x >= min) (x <= max)) (and ....)) for all band-pass values                          (dolist (bp val) (setf condexpr (append condexpr `((and (>= x ,(car bp)) (<= x ,(cadr bp)))))))                          (setf condexpr (make-num-lambda (cons 'or condexpr)))                          (filter-aux self condexpr  slot))                         (t (setf condexpr (make-num-lambda `(and (>= x ,(car val)) (<= x ,(cadr val)))))                            (filter-aux  self condexpr  slot))))        (low-pass (assert (numberp val) (val) "value for low pass must be a number")                  (setf condexpr (make-num-lambda `(<= x ,val)))                  (filter-aux self condexpr  slot))        (high-pass (assert (numberp val) (val) "value for low pass must be a number")                   (setf condexpr (make-num-lambda `(> x ,val)))                   (filter-aux self condexpr  slot))        (reject-band (assert (listp val) (val) msgbp)                     (cond ((member-if #'listp val) (assert (and (not (member-if-not #'listp val))                                                               (not (member-if-not #'(lambda(x) (if (= (length x) 2) t ())) val))) (val)                                                          msgbp)                                                          (dolist (bp val) (setf condexpr (make-num-lambda `(or (<= x ,(car bp)) (>= x ,(cadr bp)))))                                  (filter-aux self condexpr  slot)))                         (t (setf condexpr (make-num-lambda `(and (<= x ,(car val)) (>= x ,(cadr val)))))                            (filter-aux self condexpr val slot))))        (eq (cond ((listp val)                     (setf condexpr (make-num-lambda `(when (member  x  ',val) t)))                                                    (filter-aux self condexpr  slot ))                  (t (setf condexpr (make-num-lambda `(= x ,val)))                      (filter-aux self condexpr  slot))                  ))        (neq (cond ((listp val)                      (setf condexpr (make-num-lambda `(when (not (member x ',val)) t)))                           (filter-aux self condexpr  slot))                  (t (setf condexpr (make-num-lambda `(/= x ,val)))                      (filter-aux self condexpr  slot))                  ))        )         (setf (size self) (length (remove nil (flags self))))      (when (<= (size self) 0) (ccl::beep) (warn "filter: output spdata of null size"))      self)    ) (defmethod filter-aux ((self C-spdata-fg) condexpr slot)  (when (debug self) (format t "expr ~D~%" condexpr))  (let (condflags)    (setf condflags (mapcar (eval `(function ,condexpr)) (funcall slot self))) ;; apply filter to slot and collect in flag list    (when (debug self)  (format t "result ~D~%" condflags))    (dotimes (n (length condflags) self)      (unless (pop condflags)(setf (nth n (flags self)) nil)))))(defunp par-spdata-fg ((spdata spdata)                       (slot (menu (:menu-box-list (("freqs" . freqs)                                                    ("amps" . amps)                                                    ("bws" . bws)                                                    ("partials" . partials)                                                    ("weights" . weights)                                                    ("phases" . phases)                                                    ("size" . size)                                                    ("flags" . flags)))))                       &optional (test (menu (:menu-box-list (("t" . t)                                                              ("nil" . nil)                                                              ("all" . "all")))))) list        "get data in spdata object from the specified slot but only datawith flag t or with flag nil if specified in the optional input"  (when (or (and (atom spdata) (debug spdata))            (and (listp spdata) (debug (first spdata)))) (format t "values for slot ~D~%" slot))  (let (ret-list)    (cond ((listp spdata) (setf ret-list (remove nil (mapcar #'(lambda(x) (func-slot-fg slot x test)) spdata))))          ((typep spdata 'C-spdata-seq)            (setf ret-list (remove nil (mapcar #'(lambda(x) (list (frame x) (func-slot-fg slot x test))) (spdata spdata)) :key 'cadr))           (when ret-list (setf ret-list (mat-trans ret-list))))          (t (setf ret-list (func-slot-fg slot spdata test))))    ret-list)  )(defun func-slot-fg (slot spdata test)  (let ((Lr ())(L (funcall slot spdata)))    (cond ((null L) L)          ((null test)           (dotimes (n (length L) (reverse Lr))             (if (nth n (flags spdata))()(push (nth n L) Lr))))          ((equal "all" test)           (funcall slot spdata))          (t           (dotimes (n (length L) (reverse Lr))             (when (nth n (flags spdata))(push (nth n L) Lr)))           ))))(defmethod copy-instance-fg ((self C-spdata-fg) test)  (make-instance 'C-spdata-fg :size (size self) :frame (frame self)                 :partials (arith0 1 1 (size self))                  :freqs (par-spdata-fg self 'freqs test)                 :amps (par-spdata-fg self 'amps test)                  :bws (par-spdata-fg self 'bws test)                  :phases (par-spdata-fg self 'phases test)                  :weights (par-spdata-fg self 'weights test)                 :flags (par-spdata-fg self 'flags test)                 :type (type self)                  :file (file self))  )(defunp copy-spdata ((spdata spdata)(test (menu (:menu-box-list (("t" . t)                                                                 ("nil" . nil)                                                                 ("all" . "all"))))))                     spdata "copy spdata according with test" (copy-instance-fg spdata test))(make-instance 'C-spdata-fg)(pw-addmenu  *spd-io*  '(llmod-fg-read))(pw-addmenu   *spd-processing*  '(par-spdata-fg copy-spdata))